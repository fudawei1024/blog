<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Java注解]]></title>
      <url>http://yoursite.com/2016/08/07/Java%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><ul>
<li><p>注解对于开发人员来讲既熟悉又陌生，熟悉是因为只要你是做开发，都会用到注解（常见的@Override）；陌生是因为即使不使用注解也照常能够进行开发；注解不是必须的，但了解注解有助于我们深入理解某些第三方框架（比如Android Support Annotations、JUnit、xUtils、ActiveAndroid等），提高工作效率</p>
</li>
<li><p>ava注解又称为标注，是Java从1.5开始支持加入源码的特殊语法元数据；Java中的类、方法、变量、参数、包都可以被注解。这里提到的元数据是描述数据的数据，结合实例来说明：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"app_name"</span>&gt;</span>AnnotionDemo<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>这里的”app_name”就是描述数据”AnnotionDemo”的数据，这是在配置文件中写的，注解是在源码中写的，如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main_layout);</div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            setTextInOtherThread();</div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>在上面的代码中，在MainActivity.java中复写了父类Activity.java的onCreate方法，使用到了@Override注解。但即使不加上@Override注解标记代码，程序也能够正常运行。那这里的@Override注解有什么用呢？使用它有什么好处？事实上，@Override是告诉编译器这个方法是一个重写方法，如果父类中不存在该方法，编译器会报错，提示该方法不是父类中的方法。如果不小心拼写错误，将onCreate写成了onCreat，而且没有使用@Override注解，程序依然能够编译通过，但运行结果和期望的大不相同。从示例可以看出，注解有助于阅读代码</p>
</li>
<li><p>使用注解很简单，根据注解类的@Target所修饰的对象范围，可以在类、方法、变量、参数、包中使用“@+注解类名+[属性值]”的方式使用注解。比如：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@UiThread</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setTextInOtherThread</span><span class="params">(@StringRes <span class="keyword">int</span> resId)</span></span>&#123;</div><div class="line">    TextView threadTxtView = (TextView)MainActivity.<span class="keyword">this</span>.findViewById(R.id.threadTxtViewId);</div><div class="line">    threadTxtView.setText(resId);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="特别说明："><a href="#特别说明：" class="headerlink" title="特别说明："></a><strong>特别说明：</strong></h4><ul>
<li><p>注解仅仅是元数据，和业务逻辑无关，所以当你查看注解类时，发现里面没有任何逻辑处理；</p>
</li>
<li><p>javadoc中的@author、@version、@param、@return、@deprecated、@hide、@throws、@exception、@see是标记，并不是注解；</p>
</li>
</ul>
<a id="more"></a>
<h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><ul>
<li><p><strong>格式检查：</strong>告诉编译器信息，比如被@Override标记的方法如果不是父类的某个方法，IDE会报错；</p>
</li>
<li><p><strong>减少配置：</strong>运行时动态处理，得到注解信息，实现代替配置文件的功能；</p>
</li>
<li><p><strong>减少重复工作：</strong>比如第三方框架xUtils，通过注解@ViewInject减少对findViewById的调用，类似的还有（JUnit、ActiveAndroid等）；</p>
</li>
</ul>
<h3 id="注解是如何工作的？"><a href="#注解是如何工作的？" class="headerlink" title="注解是如何工作的？"></a>注解是如何工作的？</h3><ul>
<li>注解仅仅是元数据，和业务逻辑无关，所以当你查看注解类时，发现里面没有任何逻辑处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ViewInject &#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/* parent view id */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parentId</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果注解不包含业务逻辑处理，必然有人来实现这些逻辑。注解的逻辑实现是元数据的用户来处理的，注解仅仅提供它定义的属性（类/方法/变量/参数/包）的信息，注解的用户来读取这些信息并实现必要的逻辑。当使用java中的注解时（比如@Override、@Deprecated、@SuppressWarnings）JVM就是用户，它在字节码层面工作。如果是自定义的注解，比如第三方框架ActiveAndroid，它的用户是每个使用注解的类，所有使用注解的类都需要继承Model.java，在Model.java的构造方法中通过反射来获取注解类中的每个属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TableInfo</span><span class="params">(Class&lt;? extends Model&gt; type)</span> </span>&#123;</div><div class="line">    mType = type;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Table tableAnnotation = type.getAnnotation(Table.class);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (tableAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">        mTableName = tableAnnotation.name();</div><div class="line">        mIdName = tableAnnotation.id();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        mTableName = type.getSimpleName();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Manually add the id column since it is not declared like the other columns.</span></div><div class="line">    Field idField = getIdField(type);</div><div class="line">    mColumnNames.put(idField, mIdName);</div><div class="line"></div><div class="line">    List&lt;Field&gt; fields = <span class="keyword">new</span> LinkedList&lt;Field&gt;(ReflectionUtils.getDeclaredColumnFields(type));</div><div class="line">    Collections.reverse(fields);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</div><div class="line">        <span class="keyword">if</span> (field.isAnnotationPresent(Column.class)) &#123;</div><div class="line">            <span class="keyword">final</span> Column columnAnnotation = field.getAnnotation(Column.class);</div><div class="line">            String columnName = columnAnnotation.name();</div><div class="line">            <span class="keyword">if</span> (TextUtils.isEmpty(columnName)) &#123;</div><div class="line">                columnName = field.getName();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mColumnNames.put(field, columnName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="注解和配置文件的区别"><a href="#注解和配置文件的区别" class="headerlink" title="注解和配置文件的区别"></a>注解和配置文件的区别</h3><ul>
<li>通过上面的描述可以发现，其实注解干的很多事情，通过配置文件也可以干，比如为类设置配置属性；但注解和配置文件是有很多区别的，在实际编程过程中，注解和配置文件配合使用在工作效率、低耦合、可拓展性方面才会达到权衡</li>
</ul>
<hr>
<h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a><strong>配置文件：</strong></h4><p><strong>使用场合：</strong></p>
<ul>
<li><p>外部依赖的配置，比如build.gradle中的依赖配置；</p>
</li>
<li><p>同一项目团队内部达成一致的时候；</p>
</li>
<li><p>非代码类的资源文件（比如图片、布局、数据、签名文件等）；</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><p>降低耦合，配置集中，容易扩展，比如Android应用多语言支持；</p>
</li>
<li><p>对象之间的关系一目了然，比如strings.xml；</p>
</li>
<li><p>xml配置文件比注解功能齐全，支持的类型更多，比如drawable、style等；</p>
</li>
</ul>
<p><strong> 缺点：</strong></p>
<ul>
<li><p>繁琐；</p>
</li>
<li><p>类型不安全，比如R.java中的都是资源ID，用TextView的setText方法时传入int值时无法检测出该值是否为资源ID，但@StringRes可以；</p>
</li>
</ul>
<hr>
<h4 id="注解："><a href="#注解：" class="headerlink" title="注解："></a><strong>注解：</strong></h4><p><strong>使用场合：</strong></p>
<ul>
<li><p>动态配置信息；</p>
</li>
<li><p>代为实现程序逻辑（比如xUtils中的@ViewInject代为实现findViewById）；</p>
</li>
<li><p>代码格式检查，比如Override、Deprecated、NonNull、StringRes等，便于IDE能够检查出代码错误</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><p>在class文件中，提高程序的内聚性；</p>
</li>
<li><p>减少重复工作，提高开发效率，比如findViewById</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>如果对annotation进行修改，需要重新编译整个工程；</p>
</li>
<li><p>业务类之间的关系不如XML配置那样一目了然；</p>
</li>
<li><p>程序中过多的annotation，对于代码的简洁度有一定影响；</p>
</li>
<li><p>扩展性较差；</p>
</li>
</ul>
<hr>
<h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a><strong>API</strong></h4><p>Android开发过程中使用到的注解主要来自如下几个地方：</p>
<ul>
<li><p>Android SDK：在包android.annotation下；</p>
</li>
<li><p>Android Annotation Support包：在包android.support.annotation下；</p>
</li>
<li><p>JDK：在包java.lang下；</p>
</li>
<li><p>第三方框架中的自定义注解；</p>
</li>
</ul>
<h4 id="最常见注解"><a href="#最常见注解" class="headerlink" title="最常见注解"></a><strong>最常见注解</strong></h4><ul>
<li><strong>@Override</strong></li>
</ul>
<p>属于标记注解，不需要设置属性值；只能添加在方法的前面，用于标记该方法是复写的父类中的某个方法，如果在父类没有的方法前面加上@Override注解，编译器会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>@Deprecated</strong></li>
</ul>
<p>属于标记注解，不需要设置属性值；可以对构造方法、变量、方法、包、参数标记，告知用户和编译器被标记的内容已不建议被使用，如果被使用，编译器会报警告，但不会报错，程序也能正常运行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.PACKAGE, ElementType.PARAMETER, ElementType.TYPE&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>@SuppressWarnings</strong></li>
</ul>
<p>可以对构造方法、变量、方法、包、参数标记，用于告知编译器忽略指定的警告，不用再编译完成后出现警告信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</div><div class="line">    String[] value();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>@TargetApi</strong></li>
</ul>
<p>可以对接口、方法、构造方法标记，如果在应用中指定minSdkVersion为8，但有地方需要使用API 11中的方法，为了避免编译器报错，在调用API11中方法的接口、方法或者构造方法前面加上@Target(11)，这样该方法就可以使用&lt;=11的API接口了。虽然这样能够避免编译器报错，但在运行时需要注意，不能在API低于11的设备中使用该方法，否则会crash（可以获取程序运行设备的API版本来判断是否调用该方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;TYPE, METHOD, CONSTRUCTOR&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TargetApi &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This sets the target api level for the type..</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>@SuppressLint</strong></li>
</ul>
<p>和@Target的功能差不多，但使用范围更广，主要用于避免在lint检查时报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressLint &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The set of warnings (identified by the lint issue id) that should be</div><div class="line">     * ignored by lint. It is not an error to specify an unrecognized name.</div><div class="line">     */</div><div class="line">    String[] value();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Android-Annotation-Support包中的注解介绍："><a href="#Android-Annotation-Support包中的注解介绍：" class="headerlink" title="Android Annotation Support包中的注解介绍："></a>Android Annotation Support包中的注解介绍：</h3><p>Android support library从19.1版本开始引入了一个新的注解库，它包含很多有用的元注解，你能用它们修饰你的代码，帮助你发现bug。Support library自己本身也用到了这些注解，所以作为support library的用户，Android Studio已经基于这些注解校验了你的代码并且标注其中潜在的问题</p>
<p>这些注解是作为一个support包提供给开发者使用，要使用他们，需要在build.gradle中添加对android support-annotations的依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'com.android.support:support-annotations:22.2.0'</span></div></pre></td></tr></table></figure>
<p>support包中的注解分为如下几大类：</p>
<h4 id="Nullness注解："><a href="#Nullness注解：" class="headerlink" title="Nullness注解："></a><strong>Nullness注解：</strong></h4><ul>
<li><p><strong>@Nullable:</strong>用于标记方法参数或者返回值可以为空；</p>
</li>
<li><p><strong>@NonNull:</strong>用于标记方法参数或者返回值不能为空，如果为空编译器会报警告；</p>
</li>
</ul>
<h4 id="资源类型注解："><a href="#资源类型注解：" class="headerlink" title="资源类型注解："></a><strong>资源类型注解：</strong></h4><ul>
<li>这类注解主要用于标记方法的参数必须要是指定的资源类型，如果不是，IDE就会报错；因为资源文件都是静态的，所以在编写代码时IDE就知道传值是否错误，可以避免传的资源id错误导致运行时异常。资源类型注解包括@AnimatorRes、@AnimRes、@AnyRes、@ArrayRes、@BoolRes、@ColorRes、@DimenRes、@DrawableRes、@FractionRes、@IdRes、@IntgerRes、@InterpolatorRes、@LayoutRes、@MenuRes、@PluralsRes、@RawRes、@StringRes、@StyleableRes、@StyleRes、@TransitionRes、@XmlRes</li>
</ul>
<h4 id="类型定义注解："><a href="#类型定义注解：" class="headerlink" title="类型定义注解："></a><strong>类型定义注解：</strong></h4><ul>
<li>这类注解用于检查“魔幻数”，很多时候，我们使用整型常量代替枚举类型（性能考虑），例如我们有一个IceCreamFlavourManager类，它具有三种模式的操作：VANILLA，CHOCOLATE和STRAWBERRY。我们可以定义一个名为@Flavour的新注解，并使用@IntDef指定它可以接受的值类型：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCreamFlavourManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flavour;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VANILLA = <span class="number">0</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHOCOLATE = <span class="number">1</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRAWBERRY = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="meta">@IntDef</span>(&#123;VANILLA, CHOCOLATE, STRAWBERRY&#125;)</div><div class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> Flavour &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Flavour</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFlavour</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> flavour;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlavour</span><span class="params">(@Flavour <span class="keyword">int</span> flavour)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.flavour = flavour;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这时如果我们使用错误的整型值调用IceCreamFlavourManager.setFlavour时，IDE将报错如下：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A32.jpg" alt=""></center>

<ul>
<li>IDE甚至会提示我们可以使用的有效的取值：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A31.jpg" alt=""></center>

<ul>
<li>我们也可以指定整型值作为标志位，也就是说这些整型值可以使用’｜’或者’&amp;’进行与或等操作。如果我们把@Flavour定义为如下标志位：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IntDef</span>(flag = <span class="keyword">true</span>, value = &#123;VANILLA, CHOCOLATE, STRAWBERRY&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Flavour &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>那么可以如下调用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.setFlavour(IceCreamFlavourManager.VANILLA &amp; IceCreamFlavourManager.CHOCOLATE);</div></pre></td></tr></table></figure>
<h4 id="线程注解："><a href="#线程注解：" class="headerlink" title="线程注解："></a><strong>线程注解：</strong></h4><ul>
<li>用于标记指定的方法、类（如果一个类中的所有方法都有相同的线程需求，就可以对这个类进行注解，比如View.java就被@UIThread所标记）只能在指定的线程类中被调用，包括：@UiThread、@MainThread、@WorkerThread、@BinderThread；以@UIThread为例，说明这类注解的使用方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main_layout);</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                setTextInOtherThread(R.string.app_name);</div><div class="line">             <span class="comment">// setTextInOtherThread2(R.string.app_name);</span></div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@UiThread</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setTextInOtherThread</span><span class="params">(@StringRes <span class="keyword">int</span> resId)</span></span>&#123;</div><div class="line">        TextView threadTxtView = (TextView)MainActivity.<span class="keyword">this</span>.findViewById(R.id.threadTxtViewId);</div><div class="line">        threadTxtView.setText(resId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setTextInOtherThread2</span><span class="params">(@StringRes <span class="keyword">final</span> <span class="keyword">int</span> resId)</span></span>&#123;</div><div class="line">        MainActivity.<span class="keyword">this</span>.runOnUiThread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                TextView threadTxtView = (TextView)MainActivity.<span class="keyword">this</span>.findViewById(R.id.threadTxtViewId);</div><div class="line">                threadTxtView.setText(resId);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>@UIThread和@MainThread的区别：</strong>在进程里只有一个主线程。这个就是@MainThread。同时这个线程也是一个@UiThread。比如activity的主要窗口就运行在这个线程上。然而它也有能力为应用创建其他线程。这很少见，一般具备这样功能的都是系统进程。通常是把和生命周期有关的用@MainThread标注，和View层级结构相关的用@UiThread标注。但是由于@MainThread本质上是一个@UiThread，而大部分情况下@UiThread又是一个@MainThread，所以工具(lint ,Android Studio,等等)可以把他们互换，所以你能在一个可以调用@MainThread方法的地方也能调用@UiThread方法，反之亦然</li>
</ul>
<h4 id="GRB颜色值注解："><a href="#GRB颜色值注解：" class="headerlink" title="GRB颜色值注解："></a><strong>GRB颜色值注解：</strong></h4><ul>
<li>用于标记传递的颜色值必须是整型值，并且不能是color资源ID；当你的API期望一个颜色资源的时候，可以用@ColorRes标注，但是当你有一个相反的使用场景时，这种用法就不可用了，因为你并不是期望一个颜色资源id，而是一个真实的RGB或者ARGB的颜色值。在这种情况下，你可以使用@ColorInt注解，表示你期望的是一个代表颜色的整数值：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTextColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>有了这个，当你传递一个颜色id而不是颜色值的时候，lint就会标记出这段不正确的代码：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A34.jpg" alt=""></center>

<h4 id="值约束注解："><a href="#值约束注解：" class="headerlink" title="值约束注解："></a><strong>值约束注解：</strong></h4><ul>
<li>用于标记参数必须是指定类型的值，并且值的范围必须在约束的范围内，包括@Size、@IntRange、@FloatRange。如果你的参数是一个float或者double类型，并且一定要在某个范围内，你可以使用@FloatRange注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(@FloatRange(from=<span class="number">0.0</span>, to=<span class="number">1.0</span>)</span> <span class="keyword">float</span> alpha)</span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果有人使用该API的时候传递一个0-255的值，比如尝试调用setAlpha(128)，那么工具就会捕获这一问题：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A36.jpg" alt=""></center>

<ul>
<li><p>把这些注解应用到参数上是非常有用的，因为用户很有可能会提供错误范围的参数，比如上面的setAlpha例子，有的API是采用0-255的方式，而有的是采用0-1的float值的方式</p>
</li>
<li><p>对于数据、集合以及字符串，你可以用@Size注解参数来限定集合的大小(当参数是字符串的时候，可以限定字符串的长度)。举几个例子:</p>
<ol>
<li><p>集合不能为空: @Size(min=1)；</p>
</li>
<li><p>字符串最大只能有23个字符: @Size(max=23)；</p>
</li>
<li><p>数组只能有2个元素: @Size(2)；</p>
</li>
<li><p>数组的大小必须是2的倍数 (例如图形API中获取位置的x/y坐标数组: @Size(multiple=2)</p>
</li>
</ol>
</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A37.jpg" alt=""></center>

<h4 id="权限注解："><a href="#权限注解：" class="headerlink" title="权限注解："></a><strong>权限注解：</strong></h4><ul>
<li>如果你的方法需要调用者有特定的权限，你可以使用@RequiresPermission注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequiresPermission</span>(Manifest.permission.SET_WALLPAPER)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setWallpaper</span><span class="params">(Bitmap bitmap)</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure>
<ul>
<li>如果你至少需要权限集合中的一个，你可以使用anyOf属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequiresPermission</span>(anyOf = &#123;</div><div class="line">    Manifest.permission.ACCESS_COARSE_LOCATION,</div><div class="line">    Manifest.permission.ACCESS_FINE_LOCATION&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Location <span class="title">getLastKnownLocation</span><span class="params">(String provider)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>如果你同时需要多个权限，你可以用allOf属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequiresPermission</span>(allOf = &#123;</div><div class="line">    Manifest.permission.READ_HISTORY_BOOKMARKS, </div><div class="line">    Manifest.permission.WRITE_HISTORY_BOOKMARKS&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateVisitedHistory</span><span class="params">(ContentResolver cr, String url, <span class="keyword">boolean</span> real)</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>对于intents的权限，可以直接在定义的intent常量字符串字段上标注权限需求(他们通常都已经被@SdkConstant注解标注过了):</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequiresPermission</span>(android.Manifest.permission.BLUETOOTH)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTION_REQUEST_DISCOVERABLE =</div><div class="line">            <span class="string">"android.bluetooth.adapter.action.REQUEST_DISCOVERABLE"</span>;</div></pre></td></tr></table></figure>
<ul>
<li>对于content providers的权限，你可能需要单独的标注读和写的权限访问，所以可以用@Read或者@Write标注每一个权限需求：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequiresPermission</span>.Read(<span class="meta">@RequiresPermission</span>(READ_HISTORY_BOOKMARKS))</div><div class="line"><span class="meta">@RequiresPermission</span>.Write(<span class="meta">@RequiresPermission</span>(WRITE_HISTORY_BOOKMARKS))</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri BOOKMARKS_URI = Uri.parse(<span class="string">"content://browser/bookmarks"</span>);</div></pre></td></tr></table></figure>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A38.jpg" alt=""></center>


<h4 id="复写方法注解："><a href="#复写方法注解：" class="headerlink" title="复写方法注解："></a><strong>复写方法注解：</strong></h4><ul>
<li>如果你的API允许使用者重写你的方法，但你又需要你自己的方法(父方法)在重写的时候也被调用，这时候你可以使用@CallSuper标注：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallSuper</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div></pre></td></tr></table></figure>
<ul>
<li>用了这个后，当重写的方法没有调用父方法时，工具就会给予警告提示：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A39.jpg" alt=""></center>

<h4 id="返回值注解："><a href="#返回值注解：" class="headerlink" title="返回值注解："></a><strong>返回值注解：</strong></h4><ul>
<li><p>如果你的方法有返回值，你期望调用者用这个值做些事情，那么你可以使用@CheckResult注解标注这个方法</p>
</li>
<li><p>你并不需要为每个非空方法都进行标注。它主要的目的是帮助哪些容易被混淆，难以被理解的API的使用者</p>
</li>
<li><p>比如，可能很多开发者都对String.trim()一知半解，认为调用了这个方法，就可以让字符串改变以去掉空白字符。如果这个方法被@CheckResult标注，工具就会对那些没有使用trim()返回结果的调用者发出警告</p>
</li>
<li><p>Android中，Context#checkPermission这个方法已经被@CheckResult标注了：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CheckResult</span>(suggest=<span class="string">"#enforcePermission(String,int,int,String)"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">checkPermission</span><span class="params">(@NonNull String permission, <span class="keyword">int</span> pid, <span class="keyword">int</span> uid)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>这是非常重要的，因为有些使用context.checkPermission的开发者认为他们已经执行了一个权限 —-但其实这个方法仅仅只做了检查并且反馈一个是否成功的值而已。如果开发者使用了这个方法，但是又不用其返回值，那么这个开发者真正想调用的可能是这个Context#enforcePermission方法，而不是checkPermission</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A310.jpg" alt=""></center>

<h4 id="测试可见注解："><a href="#测试可见注解：" class="headerlink" title="测试可见注解："></a><strong>测试可见注解：</strong></h4><ul>
<li>你可以把这个注解标注到类、方法或者字段上，以便你在测试的时候可以使用他们</li>
</ul>
<hr>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>通过阅读注解类的源码可以发现，任何一个注解类都有如下特征：</p>
<ul>
<li><p>注解类会被@interface标记；</p>
</li>
<li><p>注解类的顶部会被@Documented、@Retention、@Target、@Inherited这四个注解标记（@Documented、@Inherited可选，@Retention、@Target必须要有）；</p>
</li>
</ul>
<p><strong>@UiThread源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(CLASS)</div><div class="line"><span class="meta">@Target</span>(&#123;METHOD,CONSTRUCTOR,TYPE&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UiThread &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>上文提到的四个注解：@Documented、@Retention、@Target、@Inherited就是元注解，它们的作用是负责注解其它注解，主要是描述注解的一些属性，任何注解都离不开元注解（包括元注解自身，通过元注解可以自定义注解），元注解的用户是JDK，JDK已经帮助我们实现了这四个注解的逻辑。这四个注解在JDK的java.lang.annotation包中。对每个元注解的详细说明如下：</p>
<h4 id="Target："><a href="#Target：" class="headerlink" title="@Target："></a><strong>@Target：</strong></h4><ul>
<li><p><strong>作用：</strong>用于描述注解的使用范围，即被描述的注解可以用在什么地方；</p>
</li>
<li><p><strong>取值：</strong></p>
</li>
</ul>
<ol>
<li><p>CONSTRUCTOR:构造器；</p>
</li>
<li><p>FIELD:实例；</p>
</li>
<li><p>LOCAL_VARIABLE:局部变量；</p>
</li>
<li><p>METHOD:方法；</p>
</li>
<li><p>PACKAGE:包；</p>
</li>
<li><p>PARAMETER:参数;</p>
</li>
<li><p>TYPE:类、接口(包括注解类型) 或enum声明</p>
</li>
</ol>
<ul>
<li><strong>示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/***</span></div><div class="line"> *</div><div class="line"> * 实体注解接口</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(value = &#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Entity &#123;</div><div class="line">    <span class="comment">/***</span></div><div class="line">     * 实体默认firstLevelCache属性为false</div><div class="line">     * <span class="doctag">@return</span> boolean</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">firstLevelCache</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</div><div class="line">    <span class="comment">/***</span></div><div class="line">     * 实体默认secondLevelCache属性为false</div><div class="line">     * <span class="doctag">@return</span> boolean</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">secondLevelCache</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</div><div class="line">    <span class="comment">/***</span></div><div class="line">     * 表名默认为空</div><div class="line">     * <span class="doctag">@return</span> String</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">tableName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">    <span class="comment">/***</span></div><div class="line">     * 默认以""分割注解</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">split</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Retention："><a href="#Retention：" class="headerlink" title="@Retention："></a><strong>@Retention：</strong></h4><ul>
<li><p><strong>作用：</strong>表示需要在什么级别保存该注解信息，用于描述注解的生命周期，即被描述的注解在什么范围内有效；</p>
</li>
<li><p><strong>取值：</strong></p>
</li>
</ul>
<ol>
<li><p>SOURCE:在源文件中有效，即源文件保留；</p>
</li>
<li><p>CLASS:在class文件中有效，即class保留；</p>
</li>
<li><p>RUNTIME:在运行时有效，即运行时保留；</p>
</li>
</ol>
<ul>
<li><strong>示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/***</span></div><div class="line"> * 字段注解接口</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(value = &#123;ElementType.FIELD&#125;)<span class="comment">//注解可以被添加在实例上</span></div><div class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)<span class="comment">//注解保存在JVM运行时刻,能够在运行时刻通过反射API来获取到注解的信息</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;<span class="comment">//注解的name属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Documented："><a href="#Documented：" class="headerlink" title="@Documented："></a><strong>@Documented：</strong></h4><ul>
<li><p><strong>作用：</strong>用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化</p>
</li>
<li><p><strong>取值：</strong>它属于标记注解，没有成员；</p>
</li>
<li><p><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(CLASS)</div><div class="line"><span class="meta">@Target</span>(&#123;METHOD,CONSTRUCTOR,TYPE&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UiThread &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Inherited："><a href="#Inherited：" class="headerlink" title="@Inherited："></a><strong>@Inherited：</strong></h4><ul>
<li><p><strong>作用：</strong>用于描述某个被标注的类型是可被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类</p>
</li>
<li><p><strong>取值：</strong>它属于标记注解，没有成员；</p>
</li>
<li><p><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**  </span></div><div class="line"> * <span class="doctag">@author</span> wangsheng </div><div class="line"> **/  </div><div class="line"><span class="meta">@Inherited</span>  </div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Greeting &#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> FontColor&#123; BULE,RED,GREEN&#125;;  </div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">FontColor <span class="title">fontColor</span><span class="params">()</span> <span class="keyword">default</span> FontColor.GREEN</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h3><p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。</p>
<ul>
<li><strong>自定义注解格式：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">元注解</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名&#123;</div><div class="line">    定义体；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>注解参数可支持的数据类型：</strong></li>
</ul>
<ol>
<li><p>所有基本数据类型（int,float,boolean,byte,double,char,long,short)；</p>
</li>
<li><p>String类型；</p>
</li>
<li><p>Class类型；</p>
</li>
<li><p>enum类型；</p>
</li>
<li><p>Annotation类型；</p>
</li>
<li><p>以上所有类型的数组</p>
</li>
</ol>
<hr>
<p><strong>特别说明：</strong></p>
<ul>
<li>注解类中的方法只能用public或者默认这两个访问权修饰，不写public就是默认，eg：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitColor &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Color&#123; BULE,RED,GREEN&#125;;</div><div class="line">    <span class="function">Color <span class="title">fruitColor</span><span class="params">()</span> <span class="keyword">default</span> Color.GREEN</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>如果注解类中只有一个成员，最好把方法名设置为”value”，比如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitName &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法</li>
</ul>
<hr>
<h4 id="实例演示："><a href="#实例演示：" class="headerlink" title="实例演示："></a><strong>实例演示：</strong></h4><ul>
<li><strong>ToDo.java：</strong>注解类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.METHOD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@interface</span> Todo &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;LOW, MEDIUM, HIGH&#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Status &#123;STARTED, NOT_STARTED&#125;    </div><div class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span> <span class="keyword">default</span> "Yash"</span>;</div><div class="line">    <span class="function">Priority <span class="title">priority</span><span class="params">()</span> <span class="keyword">default</span> Priority.LOW</span>;</div><div class="line">    <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">default</span> Status.NOT_STARTED</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>BusinessLogic:</strong>使用注解的类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessLogic</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessLogic</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compltedMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"This method is complete"</span>);</div><div class="line">    &#125;    </div><div class="line"></div><div class="line">    <span class="meta">@Todo</span>(priority = Todo.Priority.HIGH)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notYetStartedMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// No Code Written yet</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Todo</span>(priority = Todo.Priority.MEDIUM, author = <span class="string">"Uday"</span>, status = Todo.Status.STARTED)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incompleteMethod1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//Some business logic is written</span></div><div class="line">        <span class="comment">//But its not complete yet</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Todo</span>(priority = Todo.Priority.LOW, status = Todo.Status.STARTED )</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incompleteMethod2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//Some business logic is written</span></div><div class="line">        <span class="comment">//But its not complete yet</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>TodoReport.java：</strong>解析注解信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoReport</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TodoReport</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        getTodoReportForBusinessLogic();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 解析使用注解的类，获取通过注解设置的属性</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTodoReportForBusinessLogic</span><span class="params">()</span> </span>&#123;</div><div class="line">        Class businessLogicClass = BusinessLogic.class;</div><div class="line">        <span class="keyword">for</span>(Method method : businessLogicClass.getMethods()) &#123;</div><div class="line">            Todo todoAnnotation = (Todo)method.getAnnotation(Todo.class);</div><div class="line">            <span class="keyword">if</span>(todoAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">                System.out.println(<span class="string">" Method Name : "</span> + method.getName());</div><div class="line">                System.out.println(<span class="string">" Author : "</span> + todoAnnotation.author());</div><div class="line">                System.out.println(<span class="string">" Priority : "</span> + todoAnnotation.priority());</div><div class="line">                System.out.println(<span class="string">" Status : "</span> + todoAnnotation.status());</div><div class="line">                System.out.println(<span class="string">" --------------------------- "</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行结果如下图所示：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E6%B3%A8%E8%A7%A311.jpg" alt=""></center>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/21410338?f3fb8ead20=ede8379d6b659f7594e37ed09c7c0b50" target="_blank" rel="external">深入浅出Java注解</a></p>
</li>
<li><p><a href="http://www.in-droid.com/2016/06/02/Java%E6%B3%A8%E8%A7%A3/" target="_blank" rel="external">Java注解</a></p>
</li>
<li><p><a href="http://josh-persistence.iteye.com/blog/2226493" target="_blank" rel="external">深入浅出Java Annotation(元注解和自定义注解）</a></p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java垃圾收集机制]]></title>
      <url>http://yoursite.com/2016/07/23/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h3><p> Java中的垃圾回收一般是在Java堆中进行，因为堆中几乎存放了Java中所有的对象实例。谈到Java堆中的垃圾回收，自然要谈到引用。在JDK1.2之前，Java中的引用定义很很纯粹：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。但在JDK1.2之后，Java对引用的概念进行了扩充，将其分为<strong>强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种</strong>，引用强度依次减弱</p>
<ul>
<li><p><strong>强引用：</strong>如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象</p>
</li>
<li><p><strong>软引用：</strong>它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用</p>
</li>
<li><p><strong>弱引用：</strong>它也是用来描述非需对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存岛下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用</p>
</li>
<li><p><strong>虚引用：</strong>最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用</p>
</li>
</ul>
<a id="more"></a>
<h3 id="垃圾对象的判定"><a href="#垃圾对象的判定" class="headerlink" title="垃圾对象的判定"></a>垃圾对象的判定</h3><p>Java堆中存放着几乎所有的对象实例，垃圾收集器对堆中的对象进行回收前，要先确定这些对象是否还有用，判定对象是否为垃圾对象有如下算法：</p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ul>
<li><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器值就减1，任何时刻计数器都为0的对象就是不可能再被使用的</p>
</li>
<li><p>引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的选择，<strong>当Java语言并没有选择这种算法来进行垃圾回收，主要原因是它很难解决对象之间的相互循环引用问题</strong></p>
</li>
</ul>
<h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p><strong>Java和C#中都是采用根搜索算法来判定对象是否存活的。</strong>这种算法的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。在Java语言里，可作为GC Roots的兑现包括下面几种：</p>
<ul>
<li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p>
</li>
<li><p>方法区中的类静态属性引用的对象</p>
</li>
<li><p>方法区中的常量引用的对象</p>
</li>
<li><p>本地方法栈中JNI（Native方法）的引用对象</p>
</li>
</ul>
<p>实际上，在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。当对象没有覆盖finalize（）方法，或finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。如果该对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize（）方法。finalize（）方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize（）方法最多只会被系统自动调用一次），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize（）方法中让该对象重引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul>
<li>判定除了垃圾对象之后，便可以进行垃圾回收了。下面介绍一些垃圾收集算法，由于垃圾收集算法的实现涉及大量的程序细节，因此这里主要是阐明各算法的实现思想，而不去细论算法的具体实现</li>
</ul>
<h4 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h4><p>标记—清除算法是最基础的收集算法，它分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。标记—清除算法的执行情况如下图所示：</p>
<ul>
<li><p>回收前状态</p>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6.jpg" alt=""></center>
</li>
<li><p>回收后状态</p>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B61.jpg" alt=""></center>

</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B62.jpg" alt=""></center>


<p>该算法有如下缺点：</p>
<ul>
<li><p>标记和清除过程的效率都不高</p>
</li>
<li><p>标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作</p>
</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法是针对标记—清除算法的缺点，在其基础上进行改进而得到的，它讲课用内存按容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉。复制算法有如下优点：</p>
<ul>
<li><p>每次只对一块内存进行回收，运行高效</p>
</li>
<li><p>只需移动栈顶指针，按顺序分配内存即可，实现简单</p>
</li>
<li><p>内存回收时不用考虑内存碎片的出现</p>
</li>
</ul>
<p>它的缺点是：可一次性分配的最大内存缩小了一半</p>
<p>复制算法的执行情况如下图所示：</p>
<ul>
<li>回收前状态：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B63.jpg" alt=""></center>

<ul>
<li>回收后状态：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B64.jpg" alt=""></center>

<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B65.jpg" alt=""></center>

<h4 id="标记—整理算法"><a href="#标记—整理算法" class="headerlink" title="标记—整理算法"></a>标记—整理算法</h4><p>复制算法比较适合于新生代，在老年代中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。标记—整理算法的回收情况如下所示：</p>
<ul>
<li>回收前状态：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B66.jpg" alt=""></center>

<ul>
<li>回收后状态：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B67.jpg" alt=""></center>

<center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B62.jpg" alt=""></center>

<h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><ul>
<li><strong>当前商业虚拟机的垃圾收集 都采用分代收集</strong>，它根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收</li>
</ul>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><ul>
<li>垃圾收集器是内存回收算法的具体实现，Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别。Sun  HotSpot虚拟机1.6版包含了如下收集器：Serial、ParNew、Parallel Scavenge、CMS、Serial Old、Parallel Old。这些收集器以不同的组合形式配合工作来完成不同分代区的垃圾收集工作</li>
</ul>
<h3 id="垃圾回收分析"><a href="#垃圾回收分析" class="headerlink" title="垃圾回收分析"></a>垃圾回收分析</h3><p>在用代码分析之前，我们对内存的分配策略明确以下三点：</p>
<ul>
<li><p>对象优先在Eden分配</p>
</li>
<li><p>大对象直接进入老年代</p>
</li>
<li><p>长期存活的对象将进入老年代</p>
</li>
</ul>
<p>对垃圾回收策略说明以下两点：</p>
<ul>
<li><p>新生代GC（Minor GC）：发生在新生代的垃圾收集动作，因为Java对象大多都具有朝生夕灭的特性，因此Minor GC非常频繁，一般回收速度也比较快</p>
</li>
<li><p>老年代GC（Major GC/Full GC）：发生在老年代的GC，出现了Major GC，经常会伴随至少一次Minor GC。由于老年代中的对象生命周期比较长，因此Major GC并不频繁，一般都是等待老年代满了后才进行Full GC，而且其速度一般会比Minor GC慢10倍以上。另外，如果分配了Direct Memory，在老年代中进行Full GC时，会顺便清理掉Direct Memory中的废弃对象</p>
</li>
</ul>
<p>下面我们来看如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlotGc</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        <span class="keyword">byte</span>[] holder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>*<span class="number">1024</span>*<span class="number">1024</span>];  </div><div class="line">        System.gc();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>代码很简单，就是向内存中填充了32MB的数据，然后通过虚拟机进行垃圾收集。在Javac编译后，我们执行如下指令：java -verbose:gc SlotGc来查看垃圾收集的结果，得到如下输出信息：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[GC <span class="number">208</span>K-&gt;<span class="number">134</span>K(<span class="number">5056</span>K), <span class="number">0.0017306</span> secs]</div><div class="line"></div><div class="line">[Full GC <span class="number">134</span>K-&gt;<span class="number">134</span>K(<span class="number">5056</span>K), <span class="number">0.0121194</span> secs]</div><div class="line"></div><div class="line">[Full GC <span class="number">32902</span>K-&gt;<span class="number">32902</span>K(<span class="number">37828</span>K), <span class="number">0.0094149</span> sec</div></pre></td></tr></table></figure>
<ul>
<li><p>注意第三行，“-&gt;”之前的数据表示垃圾回收前堆中存活对象所占用的内存大小，“-&gt;”之后的数据表示垃圾回收堆中存活对象所占用的内存大小，括号中的数据表示堆内存的总容量，0.0094149 sec 表示垃圾回收所用的时间。</p>
</li>
<li><p>从结果中可以看出，System.gc(（）运行后并没有回收掉这32MB的内存，这应该是意料之中的结果，因为变量holder还处在作用域内，虚拟机自然不会回收掉holder引用的对象所占用的内存。</p>
</li>
<li><p>我们把代码修改如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlotGc</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        &#123;  </div><div class="line">        <span class="keyword">byte</span>[] holder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>*<span class="number">1024</span>*<span class="number">1024</span>];  </div><div class="line">        &#125;  </div><div class="line">        System.gc();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>加入花括号后，holder的作用域被限制在了花括号之内，因此，在执行System.gc（）时，holder引用已经不能再被访问，逻辑上来讲，这次应该会回收掉holder引用的对象所占的内存。但查看垃圾回收情况时，输出信息如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[GC <span class="number">208</span>K-&gt;<span class="number">134</span>K(<span class="number">5056</span>K), <span class="number">0.0017100</span> secs]</div><div class="line"></div><div class="line">[Full GC <span class="number">134</span>K-&gt;<span class="number">134</span>K(<span class="number">5056</span>K), <span class="number">0.0125887</span> secs]</div><div class="line"></div><div class="line">[Full GC <span class="number">32902</span>K-&gt;<span class="number">32902</span>K(<span class="number">37828</span>K), <span class="number">0.0089226</span> secs]</div></pre></td></tr></table></figure>
<ul>
<li>很明显，这32MB的数据并没有被回收。下面我们再做如下修改：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlotGc</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        &#123;  </div><div class="line">        <span class="keyword">byte</span>[] holder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>*<span class="number">1024</span>*<span class="number">1024</span>];  </div><div class="line">        holder = <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">        System.gc();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这次得到的垃圾回收信息如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[GC <span class="number">208</span>K-&gt;<span class="number">134</span>K(<span class="number">5056</span>K), <span class="number">0.0017194</span> secs]</div><div class="line"></div><div class="line">[Full GC <span class="number">134</span>K-&gt;<span class="number">134</span>K(<span class="number">5056</span>K), <span class="number">0.0124656</span> secs]</div><div class="line"></div><div class="line">[Full GC <span class="number">32902</span>K-&gt;<span class="number">134</span>K(<span class="number">37828</span>K), <span class="number">0.0091637</span> secs]</div></pre></td></tr></table></figure>
<ul>
<li><p>说明这次holder引用的对象所占的内存被回收了。我们慢慢来分析</p>
</li>
<li><p><strong>首先明确一点：holder能否被回收的根本原因是局部变量表中的Slot是否还存有关于holder数组对象的引用</strong></p>
</li>
<li><p>在第一次修改中，虽然在holder作用域之外进行回收，但是在此之后，没有对局部变量表的读写操作，holder所占用的Slot还没有被其他变量所复用（回忆Java内存区域与内存溢出一文中关于Slot的讲解），所以作为GC Roots一部分的局部变量表仍保持者对它的关联。这种关联没有被及时打断，因此GC收集器不会将holder引用的对象内存回收掉。 在第二次修改中，在GC收集器工作前，手动将holder设置为null值，就把holder所占用的局部变量表中的Slot清空了，因此，这次GC收集器工作时将holder之前引用的对象内存回收掉了</p>
</li>
<li><p>当然，我们也可以用其他方法来将holder引用的对象内存回收掉，只要复用holder所占用的slot即可，比如在holder作用域之外执行一次读写操作</p>
</li>
<li><p>为对象赋null值并不是控制变量回收的最好方法，以恰当的变量作用域来控制变量回收时间才是最优雅的解决办法。另外，赋null值的操作在经过虚拟机JIT编译器优化后会被消除掉，经过JIT编译后，System.gc（）执行时就可以正确地回收掉内存，而无需赋null值</p>
</li>
</ul>
<h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><p>Java虚拟机的内存管理与垃圾收集是虚拟机结构体系中最重要的组成部分，对程序（尤其服务器端）的性能和稳定性有着非常重要的影响。性能调优需要具体情况具体分析，而且实际分析时可能需要考虑的方面很多，这里仅就一些简单常用的情况作简要介绍</p>
<ul>
<li><p>我们可以通过给Java虚拟机分配超大堆（前提是物理机的内存足够大）来提升服务器的响应速度，但分配超大堆的前提是有把握把应用程序的Full GC频率控制得足够低，因为一次Full GC的时间造成比较长时间的停顿。控制Full GC频率的关键是保证应用中绝大多数对象的生存周期不应太长，尤其不能产生批量的、生命周期长的大对象，这样才能保证老年代的稳定</p>
</li>
<li><p>Direct Memory在堆内存外分配，而且二者均受限于物理机内存，且成负相关关系，因此分配超大堆时，如果用到了NIO机制分配使用了很多的Direct Memory，则有可能导致Direct Memory的OutOfMemoryError异常，这时可以通过-XX:MaxDirectMemorySize参数调整Direct Memory的大小</p>
</li>
<li><p>除了Java堆和永久代以及直接内存外，还要注意下面这些区域也会占用较多的内存，这些内存的总和会受到操作系统进程最大内存的限制：</p>
</li>
</ul>
<ol>
<li><p><strong>线程堆栈：</strong>可通过-Xss调整大小，内存不足时抛出StackOverflowError（纵向无法分配，即无法分配新的栈帧）或OutOfMemoryError（横向无法分配，即无法建立新的线程）</p>
</li>
<li><p><strong>Socket缓冲区：</strong>每个Socket连接都有Receive和Send两个缓冲区，分别占用大约37KB和25KB的内存。如果无法分配，可能会抛出IOException：Too many open files异常</p>
</li>
<li><p><strong>JNI代码：</strong>如果代码中使用了JNI调用本地库，那本地库使用的内存也不在堆中</p>
</li>
<li><p><strong>虚拟机和GC：</strong>虚拟机和GC的代码执行也要消耗一定的内存</p>
</li>
</ol>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul>
<li><a href="http://blog.csdn.net/ns_code/article/details/18076173" target="_blank" rel="external">传送门</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Javac编译与JIT编译]]></title>
      <url>http://yoursite.com/2016/07/23/Javac%E7%BC%96%E8%AF%91%E4%B8%8EJIT%E7%BC%96%E8%AF%91/</url>
      <content type="html"><![CDATA[<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><ul>
<li>不论是物理机还是虚拟机，大部分的程序代码从开始编译到最终转化成物理机的目标代码或虚拟机能执行的指令集之前，都会按照如下图所示的各个步骤进行：</li>
</ul>
<p><br></p>
<p><center><img src="http://o99dg8ap9.bkt.clouddn.com/Javac%E7%BC%96%E8%AF%91%E4%B8%8EJIT%E7%BC%96%E8%AF%91.jpg" alt=""></center><br><br></p>
<ul>
<li><p>其中绿色的模块可以选择性实现。很容易看出，上图中间的那条分支是解释执行的过程（即一条字节码一条字节码地解释执行，如JavaScript），而下面的那条分支就是传统编译原理中从源代码到目标机器代码的生成过程</p>
</li>
<li><p>如今，基于物理机、虚拟机等的语言，大多都遵循这种基于现代经典编译原理的思路，在执行前先对程序源码进行词法解析和语法解析处理，把源码转化为抽象语法树。<strong>对于一门具体语言的实现来说，词法和语法分析乃至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。也可以把抽象语法树或指令流之前的步骤实现一个半独立的编译器，这类代表是Java语言。又或者可以把这些步骤和执行引擎全部集中在一起实现，如大多数的JavaScript执行器</strong></p>
</li>
</ul>
<a id="more"></a>
<h2 id="javac编译"><a href="#javac编译" class="headerlink" title="javac编译"></a>javac编译</h2><ul>
<li><p>在Java中提到“编译”，自然很容易想到Javac编译器将<em>.java文件编译成为</em>.class文件的过程，<strong>这里的Javac编译器称为前端编译器</strong>，其他的前端编译器还有诸如Eclipse JDT中的增量式编译器ECJ等。相对应的还有<strong>后端编译器</strong>，它在程序运行期间将字节码转变成机器码<strong>（现在的Java程序在运行时基本都是解释执行加编译执行）</strong>，如<strong>HotSpot虚拟机自带的JIT（Just In Time Compiler）编译器（分Client端和Server端）</strong>。另外，有时候还有可能会碰到静态提前编译器（AOT，Ahead Of Time Compiler）直接把*.java文件编译成本地机器代码，如GCJ、Excelsior JET等，这类编译器我们应该比较少遇到。</p>
</li>
<li><p>下面简要说下Javac编译（前端编译）的过程</p>
</li>
</ul>
<h3 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h3><ul>
<li><p>词法分析是将源代码的字符流转变为标记（Token）集合。单个字符是程序编写过程中的的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符等都可以成为标记，比如整型标志int由三个字符构成，但是它只是一个标记，不可拆分</p>
</li>
<li><p>语法分析是根据Token序列来构造抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，如bao、类型、修饰符、运算符等。经过这个步骤后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在<strong>抽象语法树之</strong>上</p>
</li>
</ul>
<h3 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h3><ul>
<li>完成了语法分析和词法分析之后，下一步就是填充符号表的过程。符号表是由一组符号地址和符号信息构成的表格。符号表中所登记的信息在编译的不同阶段都要用到，在语义分析（后面的步骤）中，符号表所登记的内容将用于语义检查和产生中间代码，在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据</li>
</ul>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是读结构上正确的源程序进行上下文有关性质的审查。语义分析过程分为标注检查和数据及控制流分析两个步骤：</p>
<ul>
<li><p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量和赋值之间的数据类型是否匹配等</p>
</li>
<li><p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题</p>
</li>
</ul>
<h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><ul>
<li>字节码生成是Javac编译过程的最后一个阶段。字节码生成阶段不仅仅是把前面各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。 实例构造器<init>（）方法和类构造器<clinit>（）方法就是在这个阶段添加到语法树之中的（这里的实例构造器并不是指默认的构造函数，而是指我们自己重载的构造函数，如果用户代码中没有提供任何构造函数，那编译器会自动添加一个没有参数、访问权限与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成了）</clinit></init></li>
</ul>
<h2 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h2><ul>
<li><p>Java程序最初是仅仅通过解释器解释执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其当某个方法或代码块运行的特别频繁时，这种方式的执行效率就显得很低。于是后来在虚拟机中引入了<strong>JIT编译器（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器</strong></p>
</li>
<li><p>现在主流的商用虚拟机（如Sun HotSpot、IBM J9）中几乎都同时包含解释器和编译器（三大商用虚拟机之一的JRockit是个例外，它内部没有解释器，因此会有启动相应时间长之类的缺点，但它主要是面向服务端的应用，这类应用一般不会重点关注启动时间）。二者各有优势：<strong>当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率。解释执行可以节约内存，而编译执行可以提升效率</strong></p>
</li>
<li><p>HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作</p>
</li>
</ul>
<h3 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h3><p>运行过程中会被即时编译器编译的“热点代码”有两类：</p>
<ul>
<li><p>被多次调用的方法</p>
</li>
<li><p>被多次调用的循环体</p>
</li>
</ul>
<p>两种情况，编译器都是以整个方法作为编译对象，这种编译也是虚拟机中标准的编译方式。要知道一段代码或方法是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）。目前主要的热点 判定方式有以下两种：</p>
<ul>
<li><p><strong>基于采样的热点探测：</strong>采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测</p>
</li>
<li><p><strong>基于计数器的热点探测：</strong>采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨</p>
</li>
</ul>
<p>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器</p>
<ul>
<li><p>方法调用计数器用来统计方法调用的次数，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数</p>
</li>
<li><p>回边计数器用于统计一个方法中循环体代码执行的次数（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”</p>
</li>
<li><p>在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阀值，当计数器的值超过了阀值，就会触发JIT编译。触发了JIT编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本</p>
</li>
<li><p>由于方法计数器触发即时编译的过程与回边计数器触发即时编译的过程类似，因此这里仅给出方法调用计数器触发即时编译的流程：</p>
</li>
</ul>
<p><img src="http://o99dg8ap9.bkt.clouddn.com/Javac%E7%BC%96%E8%AF%91%E4%B8%8EJIT%E7%BC%96%E8%AF%911.jpg" alt=""></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Javac字节码编译器与虚拟机内的JIT编译器的执行过程合起来其实就等同于一个传统的编译器所执行的编译过程</li>
</ul>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul>
<li><a href="http://blog.csdn.net/ns_code/article/details/18009455" target="_blank" rel="external">传送门</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java语法糖]]></title>
      <url>http://yoursite.com/2016/07/23/Java%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
      <content type="html"><![CDATA[<h3 id="语法糖来源"><a href="#语法糖来源" class="headerlink" title="语法糖来源"></a>语法糖来源</h3><ul>
<li>语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家Peter.J.Landin发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。<strong>Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。</strong>虚拟机并不支持这些语法，<strong>它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖</strong></li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><p>泛型是JDK1.5之后引入的一项新特性，Java语言在还没有出现泛型时，只能通过Object是所有类型的父类和类型强制转换这两个特点的配合来实现泛型的功能，这样实现的泛型功能要在程序运行期才能知道Object真正的对象类型，在Javac编译期，编译器无法检查这个Object的强制转型是否成功，这便将一些风险转接到了程序运行期中</p>
</li>
<li><p>Java语言在JDK1.5之后引入的泛型实际上只在程序源码中存在，在编译后的字节码文件中，就已经被替换为了原来的原生类型，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList<string>和ArrayList<integer>就是同一个类。所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型被称为<strong>伪泛型</strong></integer></string></p>
</li>
</ul>
<h4 id="泛型示例"><a href="#泛型示例" class="headerlink" title="泛型示例"></a>泛型示例</h4><ul>
<li>下面是一段简单的Java泛型代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;();  </div><div class="line">map.put(<span class="number">1</span>,<span class="string">"No.1"</span>);  </div><div class="line">map.put(<span class="number">2</span>,<span class="string">"No.2"</span>);  </div><div class="line">System.out.println(map.get(<span class="number">1</span>));  </div><div class="line">System.out.println(map.get(<span class="number">2</span>));</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>将这段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都变回了原生类型，如下面的代码所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Map map = <span class="keyword">new</span> HashMap();  </div><div class="line">map.put(<span class="number">1</span>,<span class="string">"No.1"</span>);  </div><div class="line">map.put(<span class="number">2</span>,<span class="string">"No.2"</span>);  </div><div class="line">System.out.println((String)map.get(<span class="number">1</span>));  </div><div class="line">System.out.println((String)map.get(<span class="number">2</span>));</div></pre></td></tr></table></figure>
<ul>
<li>为了更详细地说明类型擦除，再看如下代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.List;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanxingTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"List String"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"List Int"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当我用Javac编译器编译这段代码时，报出了如下错误：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">FanxingTest.java:<span class="number">3</span>: 名称冲突：method(java.util.List&lt;java.lang.String&gt;) 和 method</div><div class="line"></div><div class="line">(java.util.List&lt;java.lang.Integer&gt;) 具有相同疑符</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</div><div class="line"></div><div class="line">                    ^</div><div class="line"></div><div class="line">FanxingTest.java:<span class="number">6</span>: 名称冲突：method(java.util.List&lt;java.lang.Integer&gt;) 和 <span class="function">metho</span></div><div class="line"></div><div class="line"><span class="title">d</span><span class="params">(java.util.List&lt;java.lang.String&gt;)</span> 具有相同疑符</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span>&#123;</div><div class="line"></div><div class="line">                    ^</div><div class="line"></div><div class="line"><span class="number">2</span> 错误</div></pre></td></tr></table></figure>
<ul>
<li><p>这是因为泛型List<string>和List<integer>编译后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样，在Class类文件结构一文中讲过，Class文件中不能存在特征签名相同的方法</integer></string></p>
</li>
<li><p>把以上代码修改如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.List;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanxingTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"List String"</span>);  </div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"List Int"</span>);  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>发现这时编译可以通过了<strong>（注意：Java语言中true和1没有关联，二者属于不同的类型，不能相互转换，不存在C语言中整数值非零即真的情况）。</strong>两个不同类型的返回值的加入，使得方法的重载成功了。这是为什么呢？</p>
</li>
<li><p>我们知道，<strong>Java代码中的方法特征签名只包括了方法名称、参数顺序和参数类型，并不包括方法的返回值</strong>，因此方法的返回值并不参与重载方法的选择，这样看来为重载方法加入返回值貌似是多余的。对于重载方法的选择来说，这确实是多余的，但我们现在要解决的问题是让上述代码能通过编译，让两个重载方法能够合理地共存于同一个Class文件之中，这就要看字节码的方法特征签名，它不仅包括了Java代码中方法特征签名中所包含的那些信息，<strong>还包括方法返回值及受查异常表。</strong>为两个重载方法加入不同的返回值后，因为有了不同的字节码特征签名，它们便可以共存于一个Class文件之中。</p>
</li>
<li><p>自动拆装箱、变长参数等语法糖也都是在编译阶段就把它们该语法糖结构还原为了原生的语法结构，因此在Class文件中也只存在其对应的原生类型，这里不再一一说明</p>
</li>
</ul>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul>
<li><a href="http://blog.csdn.net/ns_code/article/details/18011009" target="_blank" rel="external">传送门</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多态性实现机制——静态分派与动态分派]]></title>
      <url>http://yoursite.com/2016/07/23/%E5%A4%9A%E6%80%81%E6%80%A7%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/</url>
      <content type="html"><![CDATA[<h3 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h3><ul>
<li><p>Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。这个特性给Java带来了更强大的动态扩展能力，使得可以在类运行期间才能确定某些目标方法的直接引用，称为动态连接，也有一部分方法的符号引用在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。这在前面的“Java内存区域与内存溢出”一文中有提到</p>
</li>
<li><p>静态解析成立的前提是：方法在程序真正执行前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在编译器进行编译时就必须确定下来，这类方法的调用称为解析</p>
</li>
<li><p>在Java语言中，<strong>符合“编译器可知，运行期不可变”这个要求的方法主要有静态方法和私有方法两大类</strong>，前者与类型直接关联，后者在外部不可被访问，这两种方法都不可能通过继承或别的方式重写出其他的版本，<strong>因此它们都适合在类加载阶段进行解析</strong></p>
</li>
</ul>
<p>Java虚拟机里共提供了四条方法调用字节指令，分别是：</p>
<ul>
<li><p>invokestatic：调用静态方法</p>
</li>
<li><p>invokespecial：调用实例构造器<init>方法、私有方法和父类方法</init></p>
</li>
<li><p>invokevirtual：调用所有的虚方法</p>
</li>
<li><p>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象</p>
</li>
</ul>
<a id="more"></a>
<p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法四类，它们在类加载时就会把符号引用解析为该方法的直接引用。这些方法可以称为<strong>非虚方法</strong>（还包括final方法），与之相反，其他方法就称为<strong>虚方法</strong>（final方法除外）。这里要特别说明下final方法，虽然调用final方法使用的是invokevirtual指令，但是由于它无法覆盖，没有其他版本，所以也无需对方发接收者进行多态选择。Java语言规范中明确说明了final方法是一种非虚方法</p>
<ul>
<li>解析调用一定是个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用转化为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是静态的也可能是动态的，根据分派依据的宗量数（方法的调用者和方法的参数统称为方法的宗量）又可分为单分派和多分派。两类分派方式两两组合便构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况</li>
</ul>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><ul>
<li><strong>所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派，静态分派的最典型应用就是多态性中的方法重载。</strong>静态分派发生在编译阶段，因此确定静态分配的动作实际上不是由虚拟机来执行的。下面通过一段方法重载的示例程序来更清晰地说明这种分派机制：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;  </div><div class="line">&#125;    </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticPai</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Human hum)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"I am human"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Man hum)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"I am man"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Woman hum)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"I am woman"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        Human man = <span class="keyword">new</span> Man();  </div><div class="line">        Human woman = <span class="keyword">new</span> Woman();  </div><div class="line">        StaticPai sp = <span class="keyword">new</span> StaticPai();  </div><div class="line">        sp.say(man);  </div><div class="line">        sp.say(woman);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>上面代码的执行结果如下：</p>
<blockquote>
<p>I am human<br>I am human</p>
</blockquote>
</li>
<li><p>以上结果的得出应该不难分析。在分析为什么会选择参数类型为Human的重载方法去执行之前，先看如下代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Human man = <span class="keyword">new</span> Man（）;</div></pre></td></tr></table></figure>
<ul>
<li><p>我们把上面代码中的<strong>“Human”称为变量的静态类型</strong>，后面的<strong>“Man”称为变量的实际类型</strong>。静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的，而实际类型变化的结果在运行期才可确定</p>
</li>
<li><p>回到上面的代码分析中，在调用say（）方法时，方法的调用者（回忆上面关于宗量的定义，方法的调用者属于宗量）都为sp的前提下，使用哪个重载版本，完全取决于传入参数的数量和数据类型（方法的参数也是数据宗量）。代码中刻意定义了两个静态类型相同、实际类型不同的变量，可见<strong>编译器（不是虚拟机，因为如果是根据静态类型做出的判断，那么在编译期就确定了）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。</strong>并且静态类型是编译期可知的，所以在编译阶段，Javac编译器就根据参数的静态类型决定使用哪个重载版本。这就是静态分派最典型的应用</p>
</li>
</ul>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><ul>
<li>动态分派与多态性的另一个重要体现——方法覆写有着很紧密的关系。向上转型后调用子类覆写的方法便是一个很好地说明动态分派的例子。这种情况很常见，因此这里不再用示例程序进行分析。很显然，在判断执行父类中的方法还是子类中覆盖的方法时，如果用静态类型来判断，那么无论怎么进行向上转型，都只会调用父类中的方法，但实际情况是，根据对父类实例化的子类的不同，调用的是不同子类中覆写的方法，<strong>很明显，这里是要根据变量的实际类型来分派方法的执行版本的。而实际类型的确定需要在程序运行时才能确定下来，这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派</strong></li>
</ul>
<h3 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h3><ul>
<li><p>前面给出：方法的接受者（亦即方法的调用者）与方法的参数统称为方法的宗量。但分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择</p>
</li>
<li><p>为了方便理解，下面给出一段示例代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eat</span></span>&#123;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drink</span></span>&#123;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Eat arg)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"爸爸在吃饭"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Drink arg)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"爸爸在喝水"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Eat arg)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"儿子在吃饭"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Drink arg)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"儿子在喝水"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDoublePai</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        Father father = <span class="keyword">new</span> Father();  </div><div class="line">        Father child = <span class="keyword">new</span> Child();  </div><div class="line">        father.doSomething(<span class="keyword">new</span> Eat());  </div><div class="line">        child.doSomething(<span class="keyword">new</span> Drink());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>运行结果应该很容易预测到，如下：</li>
</ul>
<blockquote>
<p>爸爸在吃饭<br>    儿子在喝水</p>
</blockquote>
<ul>
<li><p>我们首先来看编译阶段编译器的选择过程，即静态分派过程。这时候选择目标方法的依据有两点：一是方法的接受者（即调用者）的静态类型是Father还是Child，二是方法参数类型是Eat还是Drink。<strong>因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型</strong></p>
</li>
<li><p>再来看运行阶段虚拟机的选择，即动态分派过程。由于编译期已经了确定了目标方法的参数类型（编译期根据参数的静态类型进行静态分派），因此唯一可以影响到虚拟机选择的因素只有此方法的接受者的实际类型是Father还是Child。<strong>因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型</strong></p>
</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/%E5%A4%9A%E6%80%81%E6%80%A7%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE.jpg" alt=""></center>

<ul>
<li>根据以上论证，我们可以总结如下：目前的Java语言（JDK1.6）是一门<strong>静态多分派、动态单分派的语言</strong></li>
</ul>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul>
<li><a href="http://blog.csdn.net/ns_code/article/details/17965867" target="_blank" rel="external">传送门</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[类加载机制]]></title>
      <url>http://yoursite.com/2016/07/22/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ul>
<li>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。它们开始的顺序如下图所示：<br><br><br><center><img src="http://o99dg8ap9.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.jpg" alt=""></center><br><br></li>
<li><p>其中<strong>类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。</strong>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序<strong>开始</strong>，而不是按顺序<strong>进行</strong>或<strong>完成</strong>，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段</p>
<p>这里简要说明下Java中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定：</p>
<ul>
<li>静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的</li>
</ul>
</li>
<li><p>动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的</p>
<a id="more"></a>
</li>
</ul>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
</li>
<li><p>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</p>
</li>
</ul>
<p>注意，这里第1条中的二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等</p>
<ul>
<li><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载</p>
</li>
<li><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据</p>
</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul>
<li><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果</p>
<p>站在<strong>Java虚拟机</strong>的角度来讲，只存在两种不同的类加载器：</p>
</li>
<li><p>启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分</p>
</li>
<li><p>所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类</p>
</li>
</ul>
<p>站在<strong>Java开发人员</strong>的角度来看，类加载器可以大致划分为以下三类：</p>
<ul>
<li><p>启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的</p>
</li>
<li><p>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器</p>
</li>
<li><p>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</p>
</li>
</ul>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。<strong>因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</strong></p>
<ul>
<li><p>在执行非置信代码之前，自动验证数字签名</p>
</li>
<li><p>动态地创建符合用户特定需要的定制化构建类</p>
</li>
<li><p>从特定的场所取得java class，例如数据库中和网络中</p>
</li>
</ul>
<p>事实上当使用Applet的时候，就用到了特定的ClassLoader，因为这时需要从网络上加载java class，并且要检查相关的安全信息，应用服务器也大都使用了自定义的ClassLoader技术</p>
<ul>
<li>这几种类加载器的层次关系如下图所示：</li>
</ul>
<p><br></p>
<p><center><img src="http://o99dg8ap9.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B62.jpg" alt=""></center><br><br></p>
<ul>
<li><p>这种层次关系称为类加载器的<strong>双亲委派模型</strong>。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式</p>
</li>
<li><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类</p>
</li>
<li><p>使用双亲委派模型来组织类加载器之间的关系，<strong>有一个很明显的好处，就是Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系</strong>，这对于保证Java程序的稳定运作很重要。例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类</p>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p> 验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：<strong>文件格式的验证、元数据的验证、字节码验证和符号引用验证</strong></p>
<ul>
<li><p>文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的</p>
</li>
<li><p>元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息</p>
</li>
<li><p>字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为</p>
</li>
<li><p>符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验</p>
</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<hr>
<h4 id="类变量分配内存"><a href="#类变量分配内存" class="headerlink" title="类变量分配内存"></a>类变量分配内存</h4><ul>
<li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中</li>
</ul>
<hr>
<h4 id="数据默认值"><a href="#数据默认值" class="headerlink" title="数据默认值"></a>数据默认值</h4><p>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值</p>
<ul>
<li><p>假设一个类变量的定义为：public static int value = 3；</p>
</li>
<li><p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器’&lt;’clinit&gt;（）方法之中的，<strong>所以把value赋值为3的动作将在初始化阶段才会执行</strong></p>
</li>
<li><p>下表列出了Java中所有基本数据类型以及reference类型的默认零值：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th style="text-align:center">默认零值</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td>long</td>
<td style="text-align:center">0L</td>
</tr>
<tr>
<td>short</td>
<td style="text-align:center">(short)0</td>
</tr>
<tr>
<td>char</td>
<td style="text-align:center">‘\u0000’</td>
</tr>
<tr>
<td>byte</td>
<td style="text-align:center">(byte)0</td>
</tr>
<tr>
<td>boolean</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td>float</td>
<td style="text-align:center">0.0f</td>
</tr>
<tr>
<td>double</td>
<td style="text-align:center">0.0d</td>
</tr>
<tr>
<td>reference</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
<p>这里还需要注意如下几点：</p>
<ul>
<li><p>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过</p>
</li>
<li><p>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值</p>
</li>
<li><p>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</p>
</li>
<li><p>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值</p>
</li>
</ul>
<hr>
<h4 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h4><p>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值</p>
<ul>
<li><p>假设上面的类变量value被定义为： public static final int value = 3；</p>
</li>
<li><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。回忆 <a href="http://www.qiuchengjia.cn/2016/07/23/JVM/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" target="_blank" rel="external">上一篇博文</a> 中对象被动引用的第2个例子，便是这种情况。<strong>我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中</strong></p>
</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在Class类文件结构一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）</p>
</li>
<li><p>对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行</p>
</li>
<li><p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型</p>
</li>
</ul>
<h4 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h4><ul>
<li>判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析</li>
</ul>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><ul>
<li>对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示：</li>
</ul>
<p><br></p>
<p><center><img src="http://o99dg8ap9.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B63.jpg" alt=""></center><br><br></p>
<ul>
<li>从下面一段代码的执行结果中很容易看出来字段解析的搜索顺序：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">11</span>;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"执行了super类静态语句块"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">33</span>;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"执行了父类静态语句块"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"执行了子类静态语句块"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        System.out.println(Child.m);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行结果如下：</li>
</ul>
<blockquote>
<p>执行了super类静态语句块<br>    执行了父类静态语句块<br>    33</p>
</blockquote>
<ul>
<li>如果注释掉Father类中对m定义的那一行，则输出结果如下：</li>
</ul>
<blockquote>
<p>  执行了super类静态语句块<br>    11</p>
</blockquote>
<ul>
<li><p>另外，很明显这就是<a href="http://www.qiuchengjia.cn/2016/07/23/JVM/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" target="_blank" rel="external">上篇博文</a>中的第1个例子的情况，这里我们便可以分析如下：static变量发生在静态解析阶段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由于在子类中没有查找到与m相匹配的字段，那么m便不会与子类关联在一起，因此并不会触发子类的初始化</p>
</li>
<li><p><strong>最后需要注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译。</strong>如果对上面的代码做些修改，将Super改为接口，并将Child类继承Father类且实现Super接口，那么在编译时会报出如下错误：</p>
</li>
</ul>
<blockquote>
<p>StaticTest.java:24: 对 m 的引用不明确，Father 中的 变量 m 和 Super 中的 变量 m<br>都匹配<br>                System.out.println(Child.m);<br>                                        ^<br>1 错误</p>
</blockquote>
<h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><ul>
<li>对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口</li>
</ul>
<h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><ul>
<li>与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程</clinit></li>
</ul>
<h4 id="‘-lt-’clinit-gt-（）方法的执行规则"><a href="#‘-lt-’clinit-gt-（）方法的执行规则" class="headerlink" title="‘&lt;’clinit&gt;（）方法的执行规则"></a>‘&lt;’clinit&gt;（）方法的执行规则</h4><ul>
<li><p>‘&lt;’clinit&gt;（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访。</p>
</li>
<li><p>‘&lt;’clinit&gt;（）方法与实例构造器<init>（）方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的’&lt;’clinit&gt;（）方法执行之前，父类的’&lt;’clinit&gt;（）方法已经执行完毕。因此，在虚拟机中第一个被执行的’&lt;’clinit&gt;（）方法的类肯定是java.lang.Object</init></p>
</li>
<li><p>‘&lt;’clinit&gt;（）方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成’&lt;’clinit&gt;（）方法</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成’&lt;’clinit&gt;（）方法。但是接口鱼类不同的是：执行接口的’&lt;’clinit&gt;（）方法不需要先执行父接口的’&lt;’clinit&gt;（）方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的’&lt;’clinit&gt;（）方法</p>
</li>
<li><p>虚拟机会保证一个类的’&lt;’clinit&gt;（）方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的’&lt;’clinit&gt;（）方法，其他线程都需要阻塞等待，直到活动线程执行’&lt;’clinit&gt;（）方法完毕。如果在一个类的’&lt;’clinit&gt;（）方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的</p>
</li>
</ul>
<p>下面给出一个简单的例子，以便更清晰地说明如上规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        a = <span class="number">2</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        System.out.println(Child.b);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>执行上面的代码，会打印出2，也就是说b的值被赋为了2</p>
</li>
<li><p>我们来看得到该结果的步骤。首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用’&lt;’clinit&gt;（）方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的’&lt;’clinit&gt;（）方法，根据规则2，在此之前，要先执行完其父类Father的’&lt;’clinit&gt;（）方法，又根据规则1，在执行’&lt;’clinit&gt;（）方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，因此当触发执行Father的’&lt;’clinit&gt;（）方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的’&lt;’clinit&gt;（）方法，这样便会将b的赋值为2</p>
</li>
<li><p>如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。很明显是根据规则1，执行Father的’&lt;’clinit&gt;（）方法时，根据顺序先执行了static语句块中的内容，后执行了“public static int a = 1;”语句</p>
</li>
<li><p>另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量），在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于’&lt;’clinit&gt;（）方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始</li>
</ul>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul>
<li><a href="http://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="external">传送门</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[类初始化]]></title>
      <url>http://yoursite.com/2016/07/22/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h3><p>类初始化是类加载过程的最后一个阶段，到初始化阶段，才真正开始执行类中的Java程序代码。<strong>虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：</strong></p>
<ul>
<li><p>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时</p>
</li>
<li><p>使用Java.lang.refect包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化</p>
</li>
<li><p>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化</p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类</p>
<p>虚拟机规定只有这四种情况才会触发类的初始化，称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发其初始化，称为被动引用</p>
</li>
</ul>
<a id="more"></a>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><h4 id="子类引用父类"><a href="#子类引用父类" class="headerlink" title="子类引用父类"></a>子类引用父类</h4><ul>
<li>通过子类引用父类中的静态字段，这时对子类的引用为被动引用，因此不会初始化子类，只会初始化父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">33</span>;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"父类被初始化"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125; </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"子类被初始化"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        System.out.println(Child.m);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行后输出的结果如下：</p>
<blockquote>
<p>父类被初始化<br>  33</p>
</blockquote>
<ul>
<li>对于静态字段，只有直接定义这个字段的类才会被初始化，因此，通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化</li>
</ul>
<h4 id="类的常量池"><a href="#类的常量池" class="headerlink" title="类的常量池"></a>类的常量池</h4><ul>
<li>常量在编译阶段会存入调用它的类的常量池中，本质上没有直接引用到定义该常量的类，因此不会触发定义常量的类的初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"我是常量"</span>;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"初始化Const类"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        System.out.println(Const.NAME);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 执行后输出的结果如下：</p>
<blockquote>
<p>我是常量</p>
</blockquote>
<ul>
<li>虽然程序中引用了const类的常量NAME，但是在编译阶段将此常量的值“我是常量”存储到了调用它的类FinalTest的常量池中，对常量Const.NAME的引用实际上转化为了FinalTest类对自身常量池的引用。也就是说，实际上FinalTest的Class文件之中并没有Const类的符号引用入口，这两个类在编译成Class文件后就不存在任何联系了</li>
</ul>
<h4 id="数组引用类"><a href="#数组引用类" class="headerlink" title="数组引用类"></a>数组引用类</h4><ul>
<li>通过数组定义来引用类，不会触发类的初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"初始化Const类"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        Const[] con = <span class="keyword">new</span> Const[<span class="number">5</span>];  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p> 执行后不输出任何信息，说明Const类并没有被初始化</p>
</blockquote>
<ul>
<li>但这段代码里触发了另一个名为“LLConst”的类的初始化，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发，很明显，这是一个对数组引用类型的初初始化，而该数组中的元素仅仅包含一个对Const类的引用，并没有对其进行初始化。如果我们加入对con数组中各个Const类元素的实例化代码，便会触发Const类的初始化，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"初始化Const类"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        Const[] con = <span class="keyword">new</span> Const[<span class="number">5</span>];  </div><div class="line">        <span class="keyword">for</span>(Const a:con)  </div><div class="line">            a = <span class="keyword">new</span> Const();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这样便会得到如下输出结果：</p>
<blockquote>
<p>初始化Const类</p>
</blockquote>
<ul>
<li>根据四条规则的第一条，这里的new触发了Const类</li>
</ul>
<h3 id="接口和类初始化的不同"><a href="#接口和类初始化的不同" class="headerlink" title="接口和类初始化的不同"></a>接口和类初始化的不同</h3><ul>
<li><p>接口也有初始化过程，上面的代码中我们都是用静态语句块来输出初始化信息的，而在接口中不能使用“static{}”语句块，但编译器仍然会为接口生成<clinit>类构造器，用于初始化接口中定义的成员变量（实际上是static final修饰的全局常量）</clinit></p>
</li>
<li><p>二者在初始化时最主要的区别是：当一个类在初始化时，要求其父类全部已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化该父接口。这点也与类初始化的情况很不同，回过头来看第2个例子就知道，调用类中的static final常量时并不会 触发该类的初始化，但是调用接口中的static final常量时便会触发该接口的初始化</p>
</li>
</ul>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul>
<li><a href="http://blog.csdn.net/ns_code/article/details/17845821" target="_blank" rel="external">传送门</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Class类文件结构]]></title>
      <url>http://yoursite.com/2016/07/17/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h3 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h3><ul>
<li>如图，源码经过编译得到的字节码文件可以由运行Java虚拟机的机器运行，因此可以说字节码是Java语言跨平台的基石，同样也是其他语言跨平台的有效途径</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt=""></center>

<ul>
<li>只要目标语言的编译器按照Java字节码存储规范进行编译，那么得到的class文件都可以被正确执行</li>
</ul>
<a id="more"></a>
<h3 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h3><ul>
<li><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据。根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种伪结构中只有两种数据类型：<strong>无符号数和表</strong></p>
</li>
<li><p>无符号数属于基本数据类型，主要可以用来描述数字、索引符号、数量值或者按照UTF-8编码构成的字符串值，大小使用u1、u2、u4、u8分别表示1字节、2字节、4字节和8字节</p>
</li>
<li><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯以“_info”结尾。那么表是干嘛的呢？<strong>表主要用于描述有层次关系的复合结构的数据，比如方法、字段</strong>。需要注意的是class文件是没有分隔符的，所以每个的二进制数据类型都是严格定义的</p>
</li>
<li><p>整个Class文件本质上就是一张表，它由如下所示的数据项构成</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>magic(魔术)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version(次版本号)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version(主版本号)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count(常量个数)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool(常量池表)</td>
<td style="text-align:center">constant_pool_count - 1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags(类的访问控制权限)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class(类名)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class(父类名)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count(接口个数)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces(接口名)</td>
<td style="text-align:center">interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count(域个数)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields(域的表)</td>
<td style="text-align:center">fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count(方法的个数)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods(方法表)</td>
<td style="text-align:center">methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attribute_count(附加属性的个数)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes(附加属性的表)</td>
<td style="text-align:center">attributes_count</td>
</tr>
</tbody>
</table>
<ul>
<li><p>从表中可以看出，无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的该数据项的形式，称这一系列连续的摸一个类型的数据为某一类型的集合，比如，fields_count个field_info表数据构成了字段表集合。这里需要说明的是：Class文件中的数据项，都是严格按照上表中的顺序和数量被严格限定的，每个字节代表的含义，长度，先后顺序等都不允许改变</p>
</li>
<li><p>在class文件中，主要分为魔数、Class文件的版本号、常量池、访问标志、类索引（还包括父类索引和接口索引集合）、字段表集合、方法表集合、属性表集合。下面就分别对每一种文件进行说明</p>
</li>
</ul>
<h3 id="魔数与Class文件版本号"><a href="#魔数与Class文件版本号" class="headerlink" title="魔数与Class文件版本号"></a>魔数与Class文件版本号</h3><ul>
<li><p>每个class字节码文件头4个字节为魔数，作用是用于确定该文件是否能被虚拟机接受，固定为0xCAFEBABE</p>
</li>
<li><p>第5和第6个字节是次版本号，第7和第8是主版本号。因此，字节码文件的版本号确定了能执行该程序的虚拟机JDK版本。</p>
</li>
<li><p>用Sublime text打开自己的一个class文件，主版本号是50，因此要求JDK至少是1.6以上版本</p>
</li>
</ul>
<blockquote>
<p>cafe babe 0000 0032 00f1 0a00 3d00 7707<br>0078 0800 790a 0002 007a 0700 7b0a 0005<br>0077 0800 7c0a 0005 007d 0800 7e0a 0005<br>007f 0a00 8000 810a 001a 0082 0a00 1a00<br>830a 001a 0084 0700 850a 000f 0077 0800<br>860b 0087 0088 0700 890b 008a 008b 0800<br>8c08 008d 0800 8e07 008f 0800 9007 0091<br>0700 9207 0093 0700 940a 001d 007a 0a00<br>1c00 950a 001b 0096 0a00 1b00 9708 0098<br>0a00 9900 9a08 009b 0800 9c0a 001a 009d</p>
</blockquote>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul>
<li><p>常量池可以简单理解为class文件的资源从库，这种数据类型是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的项目之一</p>
</li>
<li><p>常量池中主要存放两大类常量：字面量和符号引用。字面量比较接近于Java层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用总结起来则包括了下面三类常量：</p>
</li>
<li><p><strong>类和接口的全限定名（即带有包名的Class名，如：org.lxh.test.TestClass）</strong></p>
</li>
<li><p><strong>字段的名称和描述符（private、static等描述符）</strong></p>
</li>
<li><p><strong>方法的名称和描述符（private、static等描述符）</strong></p>
</li>
</ul>
<p>虚拟机在加载Class文件时才会进行动态连接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中</p>
<h4 id="符号引用和直接引用的区别与关联"><a href="#符号引用和直接引用的区别与关联" class="headerlink" title="符号引用和直接引用的区别与关联"></a>符号引用和直接引用的区别与关联</h4><ul>
<li><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中</p>
</li>
<li><p>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。<strong>如果有了直接引用，那说明引用的目标必定已经存在于内存之中了</strong></p>
</li>
</ul>
<p>在常量池中每一项常量都是一个表，在jdk1.7中共有14中常量类型，所以常量池的项目就对应14张表，这14张表的每种类型都不一样。但是有一个共同特点：表开始的第一位都是一个u1类型的标志位，代表这个常量属于哪种类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标记</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整形字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整形字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类&amp;接口符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口方法符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段&amp;方法部分符号引用</td>
</tr>
</tbody>
</table>
<ul>
<li>需要注意的是，在Class文件中，方法、字段都需要引用CONSTANT-Utf8_info类型的常量，所以这种类型的常量的长度有一定的限制，也就是Java中方法、字段的最大长度。在CONSTANT-Utf8_info中，其length的值u2，<strong>说明Java虚拟机只能编译最大大约64KB的变量或者方法名。超过的话将不会进行编译</strong></li>
</ul>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><ul>
<li>常量池之后的数据结构是访问标志(access_flags),这个标志主要用于识别一些类或者接口层次的访问信息，主要包括：这个Class是类还是接口、是否定义public、是否定义abstract类型；如果是类的话是否被声明为final等。具体的标志访问如下：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%844.jpg" alt=""></center>

<h3 id="类索引、父类索引和接口索引集合"><a href="#类索引、父类索引和接口索引集合" class="headerlink" title="类索引、父类索引和接口索引集合"></a>类索引、父类索引和接口索引集合</h3><ul>
<li>这个数据项主要用于确定这个类的继承关系。其中类索引和父类所以都是一个u2类型的数据，而接口索引集合是一组u2类型的数据。在Java中由于不允许多继承，所以父类索引是唯一的，但是一个类可以实现多个接口，所以得到的接口索引是一个集合，表示这个类实现了哪些接口</li>
</ul>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表用于描述接口或者类中声明的变量。字段包括类级变量和实例级变量，但是不包括方法内部声明的局部变量（这些变量是存储在Java虚拟机栈中的局部变量表中的）。自然，描述一个字段的信息包括：字段的作用域（public、protected、private）、实例变量与否（static）、可变性（final）、并发可见性（volatile）、可否被序列化（transient）、字段数据类型（基本数据类型、对象、数组）、字段名称。字段的信息也被存放在一张表中，其字段表包括三种类型：</p>
<ul>
<li><p>u2类型访问标志（access_flags）</p>
</li>
<li><p>u2类型的name_index（字段的简单名称）</p>
</li>
<li><p>u2类型的描述符（descriptor_index）</p>
</li>
</ul>
<p>其访问标志在access_flags中，如下图所示：</p>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%843.jpg" alt=""></center>

<ul>
<li>上面出现了简单名称，上文中出现了全限定名，以及这里出现的描述符，三者有什么区别呢？其中全限定名称比较好理解，就是类的完整路径信息。而简单名称则是指没有类型和参数修饰的方法或者字段名称，比如一个方法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">    System.out.println(a+b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么这个方法的简单名称就是inc。</p>
<ul>
<li>相对于以上两者，描述符相对复杂一些。描述符的主要的作用是描述字段的数据类型、方法的参数列表和返回值。其中我们熟悉的void，在Class文件中用V表示。下面是完整的描述符标志的含义：</li>
</ul>
<center><img src="http://o99dg8ap9.bkt.clouddn.com/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%842.jpg" alt=""></center>

<ul>
<li><p>对于数组类型，每一维度使用一个前置的“[”字符描述，如果是二维数组，那么就有两个“[”符号。比如“java.lang.String[][]”会被记录成“[[Ljava.lang.String;”</p>
</li>
<li><p>对于方法，则是按照县参数列表后返回值的顺序进行描述的。比如方法int inc(int a,int[] b,char[][] c,int d)的描述符是“(I[I[[CI)I”</p>
</li>
</ul>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><ul>
<li><p>JVM中堆方法表的描述与字段表是一致的，包括了：访问标志、名称索引、描述符索引、属性表集合。方法表单额结构与字段表是一致的，区别在于访问标志的不同.在方法中不能了用volatile和transient关键字修饰，所以这两个标志不能用在方法表中。在方法中添加了字段不能使用的访问标志，比如方法可以使用synchronized、native、strictfp、abstract关键字修饰，所以在方法表中就增加了相应的访问标志</p>
</li>
<li><p>要注意的是，如果父类方法没有在子类中重写，那么在方法中不会自动出现来自父类的方法信息。同样的，有可能添加编译器自动增加的方法，比如方法</p>
</li>
</ul>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><ul>
<li>前面的Class文件、字段表和方法表都可以携带自己的属性信息，这个信息用属性表进行描述，用于描述某些场景专有的信息。在属性表中没有类似Class文件的数据项目类型和顺序的严格要求，只要新的属性不与现有的属性名重复，任何人都可以向属性表中写入自己定义的属性信息</li>
</ul>
<h4 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h4><ul>
<li>Java程序方法体中的代码经过javac编译最终编译成的字节码指令就保存在Code属性中。但是并非所有的方法表都必须存在这个属性。Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code）和元数据（Metadata，包括类、字段、方法定义及其其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有其他的数据项目都用于描述元数据</li>
</ul>
<h4 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h4><ul>
<li>这个属性的作用是列举出方法中可能抛出的受查异常（Checked Exception），也就是描述throws 后的列举的异常</li>
</ul>
<h4 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h4><ul>
<li>主要用于描述Java源代码行号与字节码行号之间的对应关系。这个属性也不是必须的。如果没有这个属性，对程序的直接影响就是当抛出异常的时候无法显示对应的行号；并且在调试的时候无法通过设置断点的方法是调试程序</li>
</ul>
<h4 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h4><ul>
<li>用于描述栈帧中局部变量表中的变量与Java源码中定义的变量的之间的关系。也不属于必须的属性。如果没有这个属性，产生的直接影响就是当别人引用这个方法的时候，所有的参数名称都会丢失，IDE将会使用诸如args0、args1之类的参数进行显示。自然，当调试程序的时候，显示的参数名称是不可知的</li>
</ul>
<h4 id="SourceFile属性"><a href="#SourceFile属性" class="headerlink" title="SourceFile属性"></a>SourceFile属性</h4><ul>
<li>用于记录这个Class文件的源码文件名称。如果不使用这个属性，那么当抛出异常的时候，堆栈中将不会显示出错代码所属的文件名</li>
</ul>
<h4 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h4><p>作用是通知虚拟机自动为静态变量赋值。要注意的是，只有被static关键字修饰的额变量才可以使用这个属性（类变量）。对于非类变量，初始化是在方法中进行的；对于类变量可以选择两种方式进行变量的初始化：一是在类构造器方法中使用；二是是ConstantValue属性。目前Sun Hotspot的选择原则是：如果一个变量同时使用static和final关键字修饰，并且这个变量是基本数据类型或者java.lang.String类型的话，就使用ConstantValue属性进行初始化。如果没有被final修饰或者并非是基本数据类型，那么将会选择使用方法进行初始化</p>
<h4 id="InnerClass属性"><a href="#InnerClass属性" class="headerlink" title="InnerClass属性"></a>InnerClass属性</h4><ul>
<li>这个属性主要用于记录内部类与宿主类之间的关联关系</li>
</ul>
<h4 id="Deprecated以及Synthetic属性"><a href="#Deprecated以及Synthetic属性" class="headerlink" title="Deprecated以及Synthetic属性"></a>Deprecated以及Synthetic属性</h4><ul>
<li><p>这两个属性都属于标志类型的布尔属性，只存在有没有的区别。</p>
</li>
<li><p>Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，可以通过注解@deprecated实现</p>
</li>
<li><p>Synthetic属性代表此字段并不是由Java源码产生的，而是通过编译器自行添加的</p>
</li>
</ul>
<h4 id="StackMapTable属性"><a href="#StackMapTable属性" class="headerlink" title="StackMapTable属性"></a>StackMapTable属性</h4><ul>
<li>该属性的目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器</li>
</ul>
<h4 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h4><ul>
<li>这个属性是专门用来记录泛型类型的，因为在Java语言采用的是擦除法实现的泛型，在字节码（Code属性）中，泛型信息编译之后会被擦除。擦除法的优点是能够节省泛型所占的内存空间，缺点是在运行期间无法通过反射得到泛型信息，而Signature属性则弥补了这一缺陷。现在的Java反射API已经能够得到泛型信息，功劳就在于这个属性</li>
</ul>
<h4 id="BootstrapMethods属性"><a href="#BootstrapMethods属性" class="headerlink" title="BootstrapMethods属性"></a>BootstrapMethods属性</h4><ul>
<li>这个属性用于保存invokedynamic指令引用的引导方法限定符。（该指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法）</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java内存区域与内存溢出]]></title>
      <url>http://yoursite.com/2016/07/15/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
      <content type="html"><![CDATA[<h3 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h3><p><center><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.png" alt=""></center><br><a id="more"></a></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li><p>当前线程所执行的字节码的行号指示器</p>
</li>
<li><p>当前线程私有</p>
</li>
<li><p>不会出现OutOfMemoryError情况</p>
</li>
</ul>
<h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h3><ul>
<li><p>线程私有，生命周期与线程相同</p>
</li>
<li><p>java方法执行的内存模型，每个方法执行的同时都会创建一个栈帧，存储局部变量表(基本类型、对象引用)、操作数栈、动态链接、方法出口等信息</p>
</li>
<li><p>在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现</p>
</li>
<li><p>StackOverflowError异常：当线程请求的栈深度大于虚拟机所允许的深度</p>
</li>
<li><p>OutOfMemoryError异常：如果栈的扩展时无法申请到足够的内存</p>
</li>
</ul>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><ul>
<li><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量</p>
</li>
<li><p>存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和returnAddress类型（它指向了一条字节码指令的地址）</p>
</li>
<li><p>局部变量表所需的内存空间在编译期间完成分配，即在Java程序被编译成Class文件时，就确定了所需分配的最大局部变量表的容量</p>
</li>
<li><p>当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小</p>
</li>
</ul>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><ul>
<li><p>操作数栈又称为操作栈 </p>
</li>
<li><p>操作数栈的最大深度在编译的时候确定</p>
</li>
<li><p>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。因此我们也称Java虚拟机是基于栈的，这点不同于Android虚拟机，Android虚拟机是基于寄存器的</p>
</li>
<li><p>基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些；而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差</p>
</li>
</ul>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><ul>
<li>每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接</li>
</ul>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><ul>
<li>当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息</li>
</ul>
<ul>
<li>方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>与虚拟机栈相似，主要为虚拟机使用到的Native方法服务，在HotSpot虚拟机中直接把本地方法栈与虚拟机栈二合一</li>
</ul>
<h3 id="Java堆-Java-Heap"><a href="#Java堆-Java-Heap" class="headerlink" title="Java堆(Java Heap)"></a>Java堆(Java Heap)</h3><ul>
<li><p>Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域</p>
</li>
<li><p>几乎所有的对象实例和数组都在这类分配内存 </p>
</li>
<li><p>Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆” </p>
</li>
<li><p>Java堆只要求在逻辑上是连续的</p>
</li>
<li><p>在虚拟机启动时创建</p>
</li>
<li><p>OutOfMemoryError异常：当在堆中没有内存完成实例分配，且堆也无法再扩展时</p>
</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li><p>线程间共享</p>
</li>
<li><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p>
</li>
<li><p>OutOfMemoryError异常：当方法区无法满足内存的分配需求时</p>
</li>
</ul>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul>
<li><p>方法区的一部分</p>
</li>
<li><p>用于存放编译期生成的各种字面量与符号引用</p>
</li>
<li><p>OutOfMemoryError异常：当常量池无法再申请到内存时</p>
</li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul>
<li><p>NIO可以使用Native函数库直接分配堆外内存，堆中的DirectByteBuffer对象作为这块内存的引用进行操作</p>
</li>
<li><p>大小不受Java堆大小的限制，受本机(服务器)内存限制</p>
</li>
<li><p>OutOfMemoryError异常：系统内存不足时</p>
</li>
</ul>
<h3 id="HotSpot虚拟机"><a href="#HotSpot虚拟机" class="headerlink" title="HotSpot虚拟机"></a>HotSpot虚拟机</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>虚拟机遇到一条new指令时，首先将去检查这个对象的参数是否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，必须先执行类的加载过程。<br>在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存大小再类加载完成后便可确定。内存分配可以采用“指针碰撞”与“空闲列表”的方式</p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>java程序需要通过栈上的reference数据来操作堆上的具体对象。访问方式有使用句柄和直接指针两种。</p>
<ul>
<li>句柄访问 java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</li>
</ul>
<p><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAvern%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt=""></p>
<ul>
<li>直接指针访问 java堆对象的布局中必须考虑如何放置访问类型数据的相关信息，reference中存储的就是对象地址</li>
</ul>
<p><img src="http://o99dg8ap9.bkt.clouddn.com/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAvern%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt=""></p>
<h4 id="两种访问方式的比较"><a href="#两种访问方式的比较" class="headerlink" title="两种访问方式的比较"></a>两种访问方式的比较</h4><ul>
<li><p>使用句柄访问最大的好处是reference中存储的是稳定的句柄地址，在对象被移动（GC时移动对象是很普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改</p>
</li>
<li><p>使用直接指针访问方式的最大好处是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本</p>
</li>
<li><p>HotSpot虚拟机采用指针访问方式进行对象访问，从整个软件开发范围看，各种语言和框架使用句柄来访问的情况也非常常见</p>
</li>
</ul>
<h3 id="内存溢出测试方法"><a href="#内存溢出测试方法" class="headerlink" title="内存溢出测试方法"></a>内存溢出测试方法</h3><table>
<thead>
<tr>
<th>内存区域</th>
<th style="text-align:left">内存溢出的测试方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java堆</td>
<td style="text-align:left">无限循环地new对象出来，在List中保存引用，以不被垃圾收集器回收。另外，该区域也有可能发生内存泄露（Memory Leak），出现问题时，要注意区别</td>
</tr>
<tr>
<td>方法区</td>
<td style="text-align:left">生成大量的动态类，或无线循环调用String的intern()方法产生不同的String对象实例，并在List中保存其引用，以不被垃圾收集器回收。后者测试常量池，前者测试方法区的非常量池部分</td>
</tr>
<tr>
<td>虚拟机栈和本地方法栈</td>
<td style="text-align:left">单线程：递归调用一个简单的方法（如不断累积的方法）会抛出StackOverError <br><br>多线程：无限循环地创建线程，并为每个线程无限循环地增加内存，会抛出OutOfMemoryError</td>
</tr>
</tbody>
</table>
<ul>
<li>这里有一点要重点说明，在多线程情况下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常</li>
</ul>
<h3 id="OutOfMemoryError异常实例"><a href="#OutOfMemoryError异常实例" class="headerlink" title="OutOfMemoryError异常实例"></a>OutOfMemoryError异常实例</h3><ul>
<li><p>内存泄露，对象已经死了，无法通过垃圾收集器进行自动回收，通过找出泄露的代码位置和原因，才好确定解决方案</p>
</li>
<li><p>内存溢出，内存中的对象都还必须存活着，这说明Java堆分配空间不足，检查堆设置大小（-Xmx与-Xms），检查代码是否存在对象生命周期太长、持有状态时间过长的情况</p>
</li>
</ul>
<h4 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h4><ul>
<li><p>Java堆用于存储对象实例，我们只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免GC清除这些对象，就会在对象数量到达最大堆的容量限制后产生内存溢出异常</p>
</li>
<li><p>VM Args: -Xms10m -Xmx10m</p>
</li>
<li><p>-XX:+HeapDumpOnOutOfMemoryError</p>
</li>
<li><p>XX:+HeapDumpOnOutOfMemoryError这个参数可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList; </div><div class="line"><span class="keyword">import</span> java.util.List; </div><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xms10m -Xmx10m -XX:+HeapDumpOnOutOfMemoryError</div><div class="line"> */ </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123; </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123; </div><div class="line">        <span class="keyword">private</span> String name; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OOMObject</span><span class="params">(String name)</span> </span>&#123; </div><div class="line">            <span class="keyword">this</span>.name = name; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </div><div class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;(); </div><div class="line">        <span class="keyword">long</span> i = <span class="number">1</span>; </div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; </div><div class="line">            list.add(<span class="keyword">new</span> OOMObject(<span class="string">"IpConfig..."</span> + i++)); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>抛出的异常：</li>
</ul>
<blockquote>
<p>Dumping heap to java_pid27828.hprof …<br>Heap dump file created [14123367 bytes in 0.187 secs]<br>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space<br>at java.lang.AbstractStringBuilder.&lt;init&gt;(AbstractStringBuilder.java:45)<br>at java.lang.StringBuilder.&lt;init&gt;(StringBuilder.java:92)<br>at com.baoxian.HeapOOM.main(HeapOOM.java:22)</p>
</blockquote>
<p>注：出现Java堆内存溢出时，异常堆栈信息java.lang.OutOfMemoryError后面会紧跟着JavaHeapSpace。</p>
<p>要解决这个异常，一般手段是首先通过内存映像分析工具比如Eclipse Memory Analyzer对dump出来的堆转储快照进行分析，重点是确认内存中对象是否是必要的，也就是要弄清楚到底是出现了内存泄露Memory Leak还是内存溢出Memory Overflow。</p>
<p>如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们。掌握了泄露对象的类型信息，以及GC Roots引用链的信息，就可以比较准确的定位出泄露代码的位置了。</p>
<p>如果不存在泄露，那么就该修改-Xms和-Xms堆参数看能否加大点。</p>
<h4 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h4><ul>
<li>-Xoss参数设置本地方法栈大小，对于HotSpot没用。栈容量只由-Xss参数设定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xss128k</div><div class="line"> * <span class="doctag">@author</span> Administrator</div><div class="line"> *</div><div class="line"> */ </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123; </div><div class="line">        stackLength++; </div><div class="line">        stackLeak(); </div><div class="line">    &#125; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123; </div><div class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF(); </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            oom.stackLeak(); </div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; </div><div class="line">            System.out.println(<span class="string">"stack length: "</span> + oom.stackLength); </div><div class="line">            <span class="keyword">throw</span> e; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>抛出异常：</li>
</ul>
<blockquote>
<p>stack length: 1007<br>Exception in thread “main” java.lang.StackOverflowError<br>at com.baoxian.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)<br>at com.baoxian.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)<br>at com.baoxian.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)<br>at com.baoxian.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)</p>
</blockquote>
<h4 id="运行时常量池溢出"><a href="#运行时常量池溢出" class="headerlink" title="运行时常量池溢出"></a>运行时常量池溢出</h4><ul>
<li>运行时常量池分配在方法区内，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList; </div><div class="line"><span class="keyword">import</span> java.util.List; </div><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M</div><div class="line"> */ </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </div><div class="line">        <span class="comment">// 使用List保持着常量池引用，避免Full GC回收常量池行为 </span></div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;;(); </div><div class="line">        <span class="comment">// 10MB的PermSize在integer范围内足够产生OOM了 </span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </div><div class="line">            list.add(String.valueOf(i++).intern()); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>异常：</li>
</ul>
<blockquote>
<p>Exception in thread “main” java.lang.OutOfMemoryError: PermGen space<br>at java.lang.String.intern(Native Method)<br>at com.baoxian.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:18)</p>
</blockquote>
<ul>
<li>运行时常量池溢出，在java.lang.OutOfMemoryError后面紧跟着是PermGen space</li>
</ul>
<h4 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h4><ul>
<li><p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述符、方法描述等。对于这个区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。比如动态代理会生成动态类</p>
</li>
<li><p>使用CGLib技术直接操作字节码运行，生成大量的动态类。当前很多主流框架如Spring和Hibernate对类进行增强都会使用CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存</p>
</li>
<li><p>异常：</p>
</li>
</ul>
<blockquote>
<p>Exception in thread “main” java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method)</p>
</blockquote>
<ul>
<li><p>同样，跟常量池一样，都是PermGen space字符串出现</p>
</li>
<li><p>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是非常苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用GCLib字节码技术外，常见的还有：大量JSP或动态产生的JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi应用等</p>
</li>
</ul>
<h4 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h4><ul>
<li><p>DirectMemory容量可以通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值-Xmx指定一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M</div><div class="line"> */ </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </div><div class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>]; </div><div class="line">        unsafeField.setAccessible(<span class="keyword">true</span>); </div><div class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>); </div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; </div><div class="line">            unsafe.allocateMemory(_1MB); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在OutOfMemoryError后面不会有任何东西了，这就是DirectMemory内存溢出了</p>
</li>
</ul>
<h3 id="Java中获取JVM内存使用情况"><a href="#Java中获取JVM内存使用情况" class="headerlink" title="Java中获取JVM内存使用情况"></a>Java中获取JVM内存使用情况</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.text.DecimalFormat;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line">* 显示JVM总内存，JVM最大内存和总空闲内存</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayAvailableMemory</span><span class="params">()</span> </span>&#123;</div><div class="line"> </div><div class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(“<span class="number">0.00</span>″) ;</div><div class="line"> </div><div class="line"><span class="comment">//显示JVM总内存</span></div><div class="line"><span class="keyword">long</span> totalMem = Runtime.getRuntime().totalMemory();</div><div class="line"> </div><div class="line">System.out.println(df.format(totalMem <span class="number">1000000F</span>) + ” MB”);</div><div class="line"> </div><div class="line"><span class="comment">//显示JVM尝试使用的最大内存</span></div><div class="line"><span class="keyword">long</span> maxMem = Runtime.getRuntime().maxMemory();</div><div class="line">System.out.println(df.format(maxMem <span class="number">1000000F</span>) + ” MB”);</div><div class="line"> </div><div class="line"><span class="comment">//空闲内存</span></div><div class="line"><span class="keyword">long</span> freeMem = Runtime.getRuntime().freeMemory();</div><div class="line">System.out.println(df.format(freeMem <span class="number">1000000F</span>) + ” MB”);</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line">* Starts the program</div><div class="line">* <span class="doctag">@param</span> args the command line arguments</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">new</span> Main().displayAvailableMemory();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[有趣代码注释]]></title>
      <url>http://yoursite.com/2016/07/12/%E6%9C%89%E8%B6%A3%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A/</url>
      <content type="html"><![CDATA[<h3 id="佛祖保佑"><a href="#佛祖保佑" class="headerlink" title="佛祖保佑"></a>佛祖保佑</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                   _ooOoo_</div><div class="line">                  o8888888o</div><div class="line">                  88" . "88</div><div class="line">                  (| -_- |)</div><div class="line">                  O\  =  /O</div><div class="line">               ____/`---'\____</div><div class="line">             .'  \\|     |//  `.</div><div class="line">            /  \\|||  :  |||//  \</div><div class="line">           /  _||||| -:- |||||-  \</div><div class="line">           |   | \\\  -  /// |   |</div><div class="line">           | \_|  ''\---/''  |   |</div><div class="line">           \  .-\__  `-`  ___/-. /</div><div class="line">         ___`. .'  /--.--\  `. . __</div><div class="line">      ."" '&lt;  `.___\_&lt;|&gt;_/___.'  &gt;'"".</div><div class="line">     | | :  `- \`.;`\ _ /`;.`/ - ` : | |</div><div class="line">     \  \ `-.   \_ __\ /__ _/   .-` /  /</div><div class="line">======`-.____`-.___\_____/___.-`____.-'======</div><div class="line">                   `=---='</div><div class="line">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</div><div class="line">         佛祖保佑       永无BUG</div><div class="line">*/</div><div class="line"><span class="comment">//          佛曰:  </span></div><div class="line"><span class="comment">//                  写字楼里写字间，写字间里程序员；  </span></div><div class="line"><span class="comment">//                  程序人员写程序，又拿程序换酒钱。  </span></div><div class="line"><span class="comment">//                  酒醒只在网上坐，酒醉还来网下眠；  </span></div><div class="line"><span class="comment">//                  酒醉酒醒日复日，网上网下年复年。  </span></div><div class="line"><span class="comment">//                  但愿老死电脑间，不愿鞠躬老板前；  </span></div><div class="line"><span class="comment">//                  奔驰宝马贵者趣，公交自行程序员。  </span></div><div class="line"><span class="comment">//                  别人笑我忒疯癫，我笑自己命太贱；  </span></div><div class="line"><span class="comment">//                  不见满街漂亮妹，哪个归得程序员？</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="神兽草泥马"><a href="#神兽草泥马" class="headerlink" title="神兽草泥马"></a>神兽草泥马</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">*</div><div class="line">*          ┌─┐       ┌─┐</div><div class="line">*       ┌──┘ ┴───────┘ ┴──┐</div><div class="line">*       │                 │</div><div class="line">*       │       ───       │</div><div class="line">*       │  ─┬┘       └┬─  │</div><div class="line">*       │                 │</div><div class="line">*       │       ─┴─       │</div><div class="line">*       │                 │</div><div class="line">*       └───┐         ┌───┘</div><div class="line">*           │         │</div><div class="line">*           │         │</div><div class="line">*           │         │</div><div class="line">*           │         └──────────────┐</div><div class="line">*           │                        │</div><div class="line">*           │                        ├─┐</div><div class="line">*           │                        ┌─┘</div><div class="line">*           │                        │</div><div class="line">*           └─┐  ┐  ┌───────┬──┐  ┌──┘</div><div class="line">*             │ ─┤ ─┤       │ ─┤ ─┤</div><div class="line">*             └──┴──┘       └──┴──┘</div><div class="line">*                 神兽保佑</div><div class="line">*                 代码无BUG!</div><div class="line">*/</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *   ┏┓　　　┏┓</div><div class="line"> * ┏┛┻━━━┛┻┓</div><div class="line"> * ┃　　　　　　　┃</div><div class="line"> * ┃　　　━　　　┃</div><div class="line"> * ┃　┳┛　┗┳　┃</div><div class="line"> * ┃　　　　　　　┃</div><div class="line"> * ┃　　　┻　　　┃</div><div class="line"> * ┃　　　　　　　┃</div><div class="line"> * ┗━┓　　　┏━┛</div><div class="line"> *    ┃　　　┃   </div><div class="line"> *    ┃　　　┃   </div><div class="line"> *    ┃　　　┗━━━┓</div><div class="line"> *    ┃　　　　　　　┣┓</div><div class="line"> *    ┃　　　　　　　┏┛</div><div class="line"> *    ┗┓┓┏━┳┓┏┛</div><div class="line"> *      ┃┫┫　┃┫┫</div><div class="line"> *      ┗┻┛　┗┻┛</div><div class="line"> *        神兽保佑 </div><div class="line"> *        代码无BUG! </div><div class="line"> */</div></pre></td></tr></table></figure>
<h3 id="胜利手势"><a href="#胜利手势" class="headerlink" title="胜利手势"></a>胜利手势</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//                      d*##$.</span></div><div class="line"><span class="comment">// zP"""""$e.           $"    $o</span></div><div class="line"><span class="comment">//4$       '$          $"      $</span></div><div class="line"><span class="comment">//'$        '$        J$       $F</span></div><div class="line"><span class="comment">// 'b        $k       $&gt;       $</span></div><div class="line"><span class="comment">//  $k        $r     J$       d$</span></div><div class="line"><span class="comment">//  '$         $     $"       $~</span></div><div class="line"><span class="comment">//   '$        "$   '$E       $</span></div><div class="line"><span class="comment">//    $         $L   $"      $F ...</span></div><div class="line"><span class="comment">//     $.       4B   $      $$$*"""*b</span></div><div class="line"><span class="comment">//     '$        $.  $$     $$      $F</span></div><div class="line"><span class="comment">//      "$       R$  $F     $"      $</span></div><div class="line"><span class="comment">//       $k      ?$ u*     dF      .$</span></div><div class="line"><span class="comment">//       ^$.      $$"     z$      u$$$$e</span></div><div class="line"><span class="comment">//        #$b             $E.dW@e$"    ?$</span></div><div class="line"><span class="comment">//         #$           .o$$# d$$$$c    ?F</span></div><div class="line"><span class="comment">//          $      .d$$#" . zo$&gt;   #$r .uF</span></div><div class="line"><span class="comment">//          $L .u$*"      $&amp;$$$k   .$$d$$F</span></div><div class="line"><span class="comment">//           $$"            ""^"$$$P"$P9$</span></div><div class="line"><span class="comment">//          JP              .o$$$$u:$P $$</span></div><div class="line"><span class="comment">//          $          ..ue$"      ""  $"</span></div><div class="line"><span class="comment">//         d$          $F              $</span></div><div class="line"><span class="comment">//         $$     ....udE             4B</span></div><div class="line"><span class="comment">//          #$    """"` $r            @$</span></div><div class="line"><span class="comment">//           ^$L        '$            $F</span></div><div class="line"><span class="comment">//             RN        4N           $</span></div><div class="line"><span class="comment">//              *$b                  d$</span></div><div class="line"><span class="comment">//               $$k                 $F</span></div><div class="line"><span class="comment">//               $$b                $F</span></div><div class="line"><span class="comment">//                 $""               $F</span></div><div class="line"><span class="comment">//                 '$                $</span></div><div class="line"><span class="comment">//                  $L               $</span></div><div class="line"><span class="comment">//                  '$               $</span></div><div class="line"><span class="comment">//                   $               $</span></div></pre></td></tr></table></figure>
<h3 id="围棋棋盘"><a href="#围棋棋盘" class="headerlink" title="围棋棋盘"></a>围棋棋盘</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//                             _______________________________________  </span></div><div class="line"><span class="comment">//                            /  ___________________________________  \</span></div><div class="line"><span class="comment">//     _--""""--_            /  /_/_/_/_/_|_|_|_|_|_|_|_|_|_\_\_\_\_\  \</span></div><div class="line"><span class="comment">//    /          \          /  /_/_/_/_J__L_L_L_|_|_|_J_J_J__L_\_\_\_\  \</span></div><div class="line"><span class="comment">//   /\          /\        /  /_/_/_J__L_J__L_L_|_|_|_J_J__L_J__L_\_\_\  \</span></div><div class="line"><span class="comment">//   L ""-____-"" J       /  /_/_J__L_J__L_J_J__L_|_J__L_L_J__L_J__L_\_\  \</span></div><div class="line"><span class="comment">//   \            /      /  /_/__L_/__L_J__L_J__L_|_J__L_J__L_J__\_J__\_\  \</span></div><div class="line"><span class="comment">//    \_        _/      /  /_J__/_J__/__L_J__|__L_|_J__|__L_J__\__L_\__L_\  \</span></div><div class="line"><span class="comment">//  _--"""""--_"       /  /  F /  F J  J  |  F J  |  F J  |  F  F J  \ J  \  \</span></div><div class="line"><span class="comment">// /           \      /  /--/-J--/--L--|--L-J--J--|--L--L-J--|--J--\--L-\--\  \</span></div><div class="line"><span class="comment">///\           /\    /  /__/__L_J__J___L_J__J__|__|__|__L__L_J___L__L_J__\__\  \</span></div><div class="line"><span class="comment">//L ""-_____-"" J   /  /  /  /  F  F  J  J  |  |  |  |  |  F  F  J  J  \  \  \  \</span></div><div class="line"><span class="comment">//\             /  /  /--/--/--/--J---L--|--|--|--o--|--|--|--J---L--\--\--\--\  \</span></div><div class="line"><span class="comment">// \_         _/  /  /__/__J__J___L__J___L__L__L__|__J__J__J___L__J___L__L__\__\  \</span></div><div class="line"><span class="comment">//   "--___--"   /  /  /   F  F  J   F  J  J   F  |  J   F  F  J   F  J  J   \  \  \</span></div><div class="line"><span class="comment">//              /  /--/---/--J---L--J---L--|--J---|---L--|--J---L--J---L--\---\--\  \</span></div><div class="line"><span class="comment">//             /  /__J___/___L__/___L__J___L__J___|___L__J___L__J___\__J___\___L__\  \</span></div><div class="line"><span class="comment">//            /  /   F  J   /  J   J   |  J   J   |   F   F  |   F   F  \   F  J   \  \</span></div><div class="line"><span class="comment">//           /  /---/---L--J---L---L---L--|---|---|---|---|--J---J---J---L--J---\---\  \</span></div><div class="line"><span class="comment">//          /  /___/___/___L__J___J___J___|___|___|___|___|___L___L___L__J___\___\___\  \</span></div><div class="line"><span class="comment">//         /  /   /   /   /   F   F   F   F   F   |   J   J   J   J   J   \   \   \   \  \</span></div><div class="line"><span class="comment">//        /  /___/___J___J___J___J___J____L___L___|___J___J____L___L___L___L___L___\___\  \</span></div><div class="line"><span class="comment">//       /  /   /    F   F   F   |   |   J    F   |   J    F   |   |   J   J   J    \   \  \</span></div><div class="line"><span class="comment">//      /  /___J____/___/___J____L___L___|___J____|____L___|___J___J____L___\___\____L___\  \</span></div><div class="line"><span class="comment">//     /  /    F   /   J    F   J   J    |   J    |    F   |    F   F   J    F   \   J    \  \</span></div><div class="line"><span class="comment">//    /  /____/___J____L___/____L___|____L___|____|____|___J____|___J____\___J____L___\____\  \</span></div><div class="line"><span class="comment">//   /  /    /    F   /   J    J    F   J    F    |    J    F   J    F    F   \   J    \    \  \</span></div><div class="line"><span class="comment">//  /  /____/____/___J____L____|____L___J____L____|____J____L___J____|____J____L___\____\____\  \</span></div><div class="line"><span class="comment">// /                                                                                             \</span></div><div class="line"><span class="comment">///_______________________________________________________________________________________________\</span></div><div class="line"><span class="comment">//|                                                                                               |</span></div><div class="line"><span class="comment">//| hs                                                                                            |</span></div><div class="line"><span class="comment">//|_______________________________________________________________________________________________|</span></div></pre></td></tr></table></figure>
<h3 id="书本"><a href="#书本" class="headerlink" title="书本"></a>书本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//                .-~~~~~~~~~-._       _.-~~~~~~~~~-.</span></div><div class="line"><span class="comment">//            __.'              ~.   .~              `.__</span></div><div class="line"><span class="comment">//          .'//                  \./                  \\`.</span></div><div class="line"><span class="comment">//        .'//                     |                     \\`.</span></div><div class="line"><span class="comment">//      .'// .-~"""""""~~~~-._     |     _,-~~~~"""""""~-. \\`.</span></div><div class="line"><span class="comment">//    .'//.-"                 `-.  |  .-'                 "-.\\`.</span></div><div class="line"><span class="comment">//  .'//______.============-..   \ | /   ..-============.______\\`.</span></div><div class="line"><span class="comment">//.'______________________________\|/______________________________`.</span></div></pre></td></tr></table></figure>
<h3 id="微软金典图标"><a href="#微软金典图标" class="headerlink" title="微软金典图标"></a>微软金典图标</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                       __</div><div class="line">                  ,-~¨^  ^¨-,           _,</div><div class="line">                 /          / ;^-._...,¨/</div><div class="line">                /          / /         /</div><div class="line">               /          / /         /</div><div class="line">              /          / /         /</div><div class="line">             /,.-:''-,_ / /         /</div><div class="line">             _,.-:--._ ^ ^:-._ __../</div><div class="line">           /^         / /¨:.._¨__.;</div><div class="line">          /          / /      ^  /</div><div class="line">         /          / /         /</div><div class="line">        /          / /         /</div><div class="line">       /_,.--:^-._/ /         /</div><div class="line">      ^            ^¨¨-.___.:^  (R) - G33K</div><div class="line">     </div><div class="line">      */</div></pre></td></tr></table></figure>
<h3 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">          ___                _</div><div class="line">         / __|___  ___  __ _| |___</div><div class="line">        | (_ / _ \/ _ \/ _` |   -_)</div><div class="line">         \___\___/\___/\__, |_\___|</div><div class="line">                       |___/</div><div class="line">         </div><div class="line">        */</div></pre></td></tr></table></figure>
<h3 id="奥运五环"><a href="#奥运五环" class="headerlink" title="奥运五环"></a>奥运五环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">             _.-"""""-._         _.-"""""-._         _.-"""""-._</div><div class="line">          ,'           `.     ,'           `.     ,'           `.</div><div class="line">         /               \   /               \   /               \</div><div class="line">        |                 | |                 | |                 |</div><div class="line">       |                   |                   |                   |</div><div class="line">       |                   |                   |                   |</div><div class="line">        |             _.-"|"|"-._         _.-"|"|"-._             |</div><div class="line">         \          ,'   /   \   `.     ,'   /   \   `.          /</div><div class="line">          `.       /   ,'     `.   \   /   ,'     `.   \       ,'</div><div class="line">            `-..__|..-'         `-..|_|..-'         `-..|__..-'</div><div class="line">                 |                   |                   |</div><div class="line">                 |                   |                   |</div><div class="line">                  |                 | |                 |</div><div class="line">                   \               /   \               /</div><div class="line">                    `.           ,'     `.           ,'</div><div class="line">                      `-..___..-'         `-..___..-'</div><div class="line"></div><div class="line">        */</div></pre></td></tr></table></figure>
<h3 id="七龙珠比克"><a href="#七龙珠比克" class="headerlink" title="七龙珠比克"></a>七龙珠比克</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                      _.---..._</div><div class="line">                  ./^         ^-._</div><div class="line">                ./^C===.         ^\.   /\</div><div class="line">               .|'     \\        _ ^|.^.|</div><div class="line">          ___.--'_     ( )  .      ./ /||</div><div class="line">         /.---^T\      ,     |     / /|||</div><div class="line">        C'   ._`|  ._ /  __,-/    / /-,||</div><div class="line">             \ \/    ;  /O  / _    |) )|,</div><div class="line">              i \./^O\./_,-^/^    ,;-^,'</div><div class="line">               \ |`--/ ..-^^      |_-^</div><div class="line">                `|  \^-           /|:</div><div class="line">                 i.  .--         / '|.</div><div class="line">                  i   =='       /'  |\._</div><div class="line">                _./`._        //    |.  ^-ooo.._</div><div class="line">         _.oo../'  |  ^-.__./X/   . `|    |#######b</div><div class="line">        d####     |'      ^^^^   /   |    _\#######</div><div class="line">        #####b ^^^^^^^^--. ...--^--^^^^^^^_.d######</div><div class="line">        ######b._         Y            _.d#########</div><div class="line">        ##########b._     |        _.d#############</div><div class="line"></div><div class="line">                                       "Piccolo" no. 2</div><div class="line">                                          (from Dragonball Z)</div><div class="line">                                               --- Steven J. Simmons</div><div class="line">        */</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                             /^_.-^  _  --^=_</div><div class="line">                          ./'-^__    _&gt;=\^^==^-.</div><div class="line">                          |'/^^_/  /^    \ \.^\\\/\</div><div class="line">                         ,|/| '  /'  _____\ `\|.^.|</div><div class="line">                         |'/   /_--^^ .   ^^-./ /||</div><div class="line">                         |/,--^  ,     |     / /||'</div><div class="line">                       ._|/   \ /  __,-/    / /-,||</div><div class="line">                       \ '/    ;  /O  / _    |) )|,</div><div class="line">                        i \./^O\./_,-^/^    ,;-^,'</div><div class="line">                         \ |`--/ ..-^^      |_-^</div><div class="line">                          `|  \^-_,/^Y\      | ^^\</div><div class="line">                          _i.  \".--V_/     /| \. ^\._____...--.&gt;^^^^^^-------...._</div><div class="line">                         /  i   ^--^^     /'|' |\. |./'        |                  ;</div><div class="line">       ___...----/^^^^---|.  `._\  /^   /' |'_/' \ `|         |'               ,/'</div><div class="line">                |'        \   _|^-.__./'__.^^\     .|        ,|            _.-^</div><div class="line">                `\       ,|`_./^^-----^^._    ` ./ /        /^        _.-^^/</div><div class="line">                         |'  ^                  /-^                ./^    /</div><div class="line">       \                 `\_     __.-&lt;       _,/                 ./'     |'</div><div class="line">        `\.        `i       ^^--/._____...--^            .      ./       |.</div><div class="line">          `|        |                                   /       /        `|</div><div class="line"></div><div class="line"></div><div class="line">                                       "Piccolo"</div><div class="line">                                          (from Dragonball Z)</div><div class="line">                                               --- Steven J. Simmons         </div><div class="line">       */</div></pre></td></tr></table></figure>
<h3 id="七龙珠孙悟空"><a href="#七龙珠孙悟空" class="headerlink" title="七龙珠孙悟空"></a>七龙珠孙悟空</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                           _</div><div class="line">                           \"-._ _.--"~~"--._</div><div class="line">                            \   "            ^.    ___</div><div class="line">                            /                  \.-~_.-~</div><div class="line">                     .-----'     /\/"\ /~-._      /</div><div class="line">                    /  __      _/\-.__\L_.-/\     "-.</div><div class="line">                   /.-"  \    ( ` \_o&gt;"&lt;o_/  \  .--._\</div><div class="line">                  /'      \    \:     "     :/_/     "`</div><div class="line">                          /  /\ "\    ~    /~"</div><div class="line">                          \ I  \/]"-._ _.-"[</div><div class="line">                       ___ \|___/ ./    l   \___   ___</div><div class="line">                  .--v~   "v` ( `-.__   __.-' ) ~v"   ~v--.</div><div class="line">               .-&#123;   |     :   \_    "~"    _/   :     |   &#125;-.</div><div class="line">              /   \  |           ~-.,___,.-~           |  /   \</div><div class="line">             ]     \ |                                 | /     [</div><div class="line">             /\     \|     :                     :     |/     /\</div><div class="line">            /  ^._  _K.___,^                     ^.___,K_  _.^  \</div><div class="line">           /   /  "~/  "\                           /"  \~"  \   \</div><div class="line">          /   /    /     \ _          :          _ /     \    \   \</div><div class="line">        .^--./    /       Y___________l___________Y       \    \.--^.</div><div class="line">        [    \   /        |        [/    ]        |        \   /    ]</div><div class="line">        |     "v"         l________[____/]________j  -Row   &#125;r"     /</div><div class="line">        &#125;------t          /                       \       /`-.     /</div><div class="line">        |      |         Y                         Y     /    "-._/</div><div class="line">        &#125;-----v'         |         :               |     7-.     /</div><div class="line">        |   |_|          |         l               |    / . "-._/</div><div class="line">        l  .[_]          :          \              :  r[]/_.  /</div><div class="line">         \_____]                     "--.             "-.____/</div><div class="line"></div><div class="line">                                            "Dragonball Z"</div><div class="line">                                                        ---Row</div><div class="line">         </div><div class="line">        */</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                               MMMMM</div><div class="line">                                 MMMMMM</div><div class="line">                                   MMMMMMM</div><div class="line">                                    MMMMMMMM     .</div><div class="line">                                     MMMMMMMMM</div><div class="line">                                     HMMMMMMMMMM</div><div class="line">                                      MMMMMMMMMMMM  M</div><div class="line">                                      MMMMMMMMMMMMM  M</div><div class="line">                                       MMMMMMMMMMMMM  M</div><div class="line">                                       MMMMMMMMMMMMM:</div><div class="line">                                       oMMMMMMMMMMMMMM</div><div class="line">             .MMMMMMMMMMMMMMo           MMMMMMMMMMMMMMM M</div><div class="line">       MMMMMMMMMMMMMMMMMMMMMMMMMMM      MMMMMMMMMMMMMMMM</div><div class="line">         MMMMMMMMMMMMMMMMMMMMMMMMMMMM.  oMMMMMMMMMMMMMMM.M</div><div class="line">           MMMMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMMMMMMMMMMMMM</div><div class="line">             MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">               oMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                   MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:                     H</div><div class="line">                    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM                  .         MMM</div><div class="line">                     MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM              M       MMMMMM</div><div class="line">                      .MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM          M   MMMMMMMMMM</div><div class="line">               MM.      MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM       M MMMMMMMMMMMM</div><div class="line">                   MM    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM    .MMMMMMMMMMMMMM</div><div class="line">                     MM  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                       MM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">              .MMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMM.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                 HMMMMMMMMMMMMMMMMMMMMM.MMMMMMMMM.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                    MMMMMMMMMMMMMMM MMM.oMMMMMMM..MMMMMMMMM:MMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                      MMMMMMMMMMMMMM MM..MMMMMMM...MMMMMMM. MMMMMMMMMMMMMMMMMMMMM</div><div class="line">                        MMMMMMMMMMMMMMM ..MMMMMM...MMMMMM ..MMMMMMMMMMMMMMMMMMM</div><div class="line">                         MMMMMMM:M.MMM.M.. MMMMM M..MMMMM...MMMMMMMMMMMMMMMMMM  MMM</div><div class="line">                           MMMM. .M..MM.M...MMMMMM..MMMMM.. MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM .</div><div class="line">                            MMMM..M....M.....:MMM .MMMMMM..MMMMMMM...MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                             MMM.M.. ...M......MM.MMMMM.......MHM.M  .MMMMMMMMMMMMMMMMMMMMMMMMM</div><div class="line">                        MMMMMMMM..MM. . MMM.....MMMMMM.M.....M ..MM..M MMMMMMMMMMMMMMMMMMM</div><div class="line">                           .MMMMMHMM. ..MMMM. MMM............o..... . .MMMMMMMMMMMMMMM</div><div class="line">                              MMM. M... .........................M..:.MMMMMMMMMMMM</div><div class="line">                                oMMM............ .................M.M.MMMMMMMMM</div><div class="line">                                   .....MM........................ . MMMMMM</div><div class="line">                                  M.....M.....................o.MM.MMMMMMMM.</div><div class="line">                                   M........................M.. ...MMMMMMMMMMMMMo</div><div class="line">                                     :....MMM..............MMM..oMMMMMMM</div><div class="line">                                      M...MMM.............MMMMMMM</div><div class="line">                                         .............:MMMMMMMM</div><div class="line">                                         M..... MMM.....M</div><div class="line">                                         M M.............</div><div class="line">                                         ................M</div><div class="line">                                      ooM.................MM  MoMMMMMoooM</div><div class="line">                                 MMoooM......................MoooooooH..oMM</div><div class="line">                             MHooooMoM.....................MMooooooM........M</div><div class="line">                           oooooooMoooM......... o........MoooooooM............</div><div class="line">                           Mooooooooooo.......M.........Moooooooo:..............M</div><div class="line">                          MooMoooooooooM...M........:Mooooooooooo:..............M</div><div class="line">                         M..oooooooooooo .........Mooooooooooooooo..............M</div><div class="line">                        M...Mooo:oooooooo.M....ooooooooooooooooooo..M...........M</div><div class="line">                         ...oooooMoooooooM..Mooooooooooooo:oooooooM.M...........M.</div><div class="line">                        M...ooooooMoo:ooooMoooooooooooooHoooooooooH:M. ...........:</div><div class="line">                        M..MoooooooMoooooooooooooooooo:ooooooMooooMoM..............M</div><div class="line">                        M..ooooooooooMooooooooooooooHoooooooMooHooooM...............M</div><div class="line">                        ...ooooooooooooooooooo:MooooooooooooooMoMoooM................</div><div class="line">                       M...oooooooooooooooooooooooooooooooooooooMooMM................M</div><div class="line">                       ...MooooooooooooooooooooooooooooooooooooooooMo ................</div><div class="line">                       ...MooooooooooooooooooooooooooooooooooooooooM M................M</div><div class="line">                      M...ooooooooooooooooooooooooooooooooooooooooM   ................M</div><div class="line">                      ...MoooooooooooooooooooooooooooooooooooooooMM   .:...............</div><div class="line">                      .....MooooooooooooooooooooooooooooooooooooMoo       .............M</div><div class="line">                      M...... ooooooooooooooooooooooooooooooooooooM       M..............M</div><div class="line">                      M........MooooMMM MM MM  MMMMMMMMMooooooooM         M...............M</div><div class="line">                      .........HM     M:  MM :MMMMMM          M           M...............</div><div class="line">                     M..........M     M   MoM M                           M................M</div><div class="line">                     M.........:M  MoH  M M M MooooHoooMM.   M             M...............M</div><div class="line">                     M..........Moooo MMooM    oooooMooooooooM              M..............H</div><div class="line">                     M.........MooooM  Mooo  : ooooooMooooMoooM              M........ . .o.M</div><div class="line">                     H..  .....ooooo   oooo  M MooooooooooooooM               M... MMMMMMMMMMM</div><div class="line">                     MMMMMMMMMMooooM M oooo  .  ooooooMooooooooM              .MMMMMMMMMMMMMMM</div><div class="line">                     MMMMMMMMMMooooH : ooooH    oooooooooooooooo               MMMMMMMMMMMMMMM</div><div class="line">                     MMMMMMMMMMoooo    ooooM    Moooooooooooooooo              .MMMMMMMMMMMMMMM</div><div class="line">                     MMMMMMMMMMoooo    ooooM    MooooooooooooooooM              MMMMMMMMMMMMMMM</div><div class="line">                     MMMMMMMMMMoooM    ooooM     ooooooooooooooooo               MMMMMMMMMMM:M</div><div class="line">                     MMMMMMMMMMoooM   MooooM     oooooooooooMoooooo               MH...........</div><div class="line">                      . ......Mooo.   MooooM     oooooooooooooooooo              M............M</div><div class="line">                     M.M......oooo    MooooM     Moooooooooooooooooo:           .........M.....</div><div class="line">                     M.M.....Moooo    MooooM      ooooooooooooooooooM            .M............</div><div class="line">                     .......MooooH    MooooM      oooooooooMoooooooooo          M..o...M..o....M</div><div class="line">                     .o....HMooooM    MooooH      MooooooooMooooooooooM          .:M...M.......M</div><div class="line">                    M..M.....MoooM    :oooo:    .MooooooooHooMoooooooooM         M M... ..oM.M</div><div class="line">                     M...M.:.Mooo. MMMMooooo   oooooooooooMoooooooooooooM          ....M. M</div><div class="line">                      M:M..o.Moooooooooooooo MooooooooooooooMooooooooooooM          .Mo</div><div class="line">                             MooooooooooooooMooooooooooooMoMoooooooooooooo</div><div class="line">                             Mooooooooooooooo:ooooooooooooooooooooooooooooo</div><div class="line">                             ooooooooooooooooMooooooooooMoooooooooooooooooo</div><div class="line">                             ooooooooooooooooMoooooooooooMooooooooooooooooHo</div><div class="line">                             ooMooooooooooooooMoooooooooooooooooooooooooooMoM</div><div class="line">                            MooMoooooooooooooo.ooooooooooooooooooooooooooo:oM</div><div class="line">                            MoooooooooooooooooooooooooooooooooooooooooooooooM</div><div class="line">                            MoooMooooooooooooooMooooooooooooooooooooooooooooo.</div><div class="line">                            MoooMooooooooooooooMoooooooooooooooooooooooooMooooM</div><div class="line">                            MooooooooooooooooooMoooooooooooooooooooooooooMoooooM</div><div class="line">                            MooooMoooooooooooooMoooooooooooooooooooooooooMoHooooM</div><div class="line">                            ooooooMooooooooooooooooooooooooooooooooooooooooMoMoooM</div><div class="line">                           MooooooooooooooooooooMooooooooooooooooooooooooooMoooooH:</div><div class="line">                           MoooooooMooooooooooooMoooooooooooooooooooooooooooooHoooM</div><div class="line">                           MooooooooMoooooooooooMoooooooooooooooooooooooooMoooMooooM</div><div class="line">                           Moooooooooooooooooooooooooooooooooooooooooooooo.oooMooooo</div><div class="line">                           MoooooooooooooooooooooooooooooooooooooooooooooMoooooooooM</div><div class="line">                            MooooooooooooooooooooMoooooooooooooooooooooooooooooooooM</div><div class="line">                             MooooooooooooooooooooMHooooooooooooooooooooMoooo:ooooo</div><div class="line">                              MMooooooooooooooooooMoMHoooooooooooooooooooooooMooooo</div><div class="line">                               MMoooooooooooooooMMooo MMooooooooooooooooooooooooooM</div><div class="line">                               MMMoooooooooooooMooooo  oooooooooooooooooooooMooooo</div><div class="line">                               MooMMoooooooooMoooMMoM  ooooHooooooooooooooooMooooM</div><div class="line">                               MooooMooooooMooooMoooM  MoooooMoooooooooooooMooooo</div><div class="line">                               ooooooMMooooooooMooooM  MoooooooooMooooooooooooooM</div><div class="line">                               HooooooMoooooooMooooM    HoooooooHooMooooooooooooo</div><div class="line">                                oooMoooooooooHoooM         MoooooooooMoooooooooM</div><div class="line">                                 HooooooooooooHM             MooooooooMMoooooooM</div><div class="line">                                  MMMMMMMMMMMMMM                Moooooo:MooooHMM</div><div class="line">                                   MMMMMMM: ...                  MMMMMMMMMMMMMM</div><div class="line">                                  M............M                  MMMMMMMMM ....</div><div class="line">                                  M.MM..........                  M.............M</div><div class="line">                               M ..............MM                 M..............</div><div class="line">                            MMMMM............MMMM                 ..MMMMMMMM ....M</div><div class="line">                          MMMMMMMMMMMMMMMMMMMMMMMM               MMMMMMMMMMMMM...M</div><div class="line">                       .MMMMMMMMMMMMMMMMMMMMMMMMMM               MMMMMMMMMMMMMMMMMM</div><div class="line">                       MMMMMMMMMMMMMMMMMMMMMMMMM                MMMMMMMMMMMMMMMMMMM</div><div class="line">                       :MMMMMMMMMMMMMMMMMMH                     MMMMMMMMMMMMMMMMMMM</div><div class="line">                          By EBEN Jérôme                        MMMMMMMMMMMMMMMMMM</div><div class="line">                                                                MMMMMMMMMMMMMMM</div><div class="line">                                                                 HMMMMMM</div><div class="line">        </div><div class="line">       */</div></pre></td></tr></table></figure>
<h3 id="皮卡丘"><a href="#皮卡丘" class="headerlink" title="皮卡丘"></a>皮卡丘</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">       quu..__</div><div class="line">        $$$b  `---.__</div><div class="line">         "$$b        `--.                          ___.---uuudP</div><div class="line">          `$$b           `.__.------.__     __.---'      $$$$"              .</div><div class="line">            "$b          -'            `-.-'            $$$"              .'|</div><div class="line">              ".                                       d$"             _.'  |</div><div class="line">                `.   /                              ..."             .'     |</div><div class="line">                  `./                           ..::-'            _.'       |</div><div class="line">                   /                         .:::-'            .-'         .'</div><div class="line">                  :                          ::''\          _.'            |</div><div class="line">                 .' .-.             .-.           `.      .'               |</div><div class="line">                 : /'$$|           .@"$\           `.   .'              _.-'</div><div class="line">                .'|$u$$|          |$$,$$|           |  &lt;            _.-'</div><div class="line">                | `:$$:'          :$$$$$:           `.  `.       .-'</div><div class="line">                :                  `"--'             |    `-.     \</div><div class="line">               :##.       ==             .###.       `.      `.    `\</div><div class="line">               |##:                      :###:        |        &gt;     &gt;</div><div class="line">               |#'     `..'`..'          `###'        x:      /     /</div><div class="line">                \                                   xXX|     /    ./</div><div class="line">                 \                                xXXX'|    /   ./</div><div class="line">                 /`-.                                  `.  /   /</div><div class="line">                :    `-  ...........,                   | /  .'</div><div class="line">                |         ``:::::::'       .            |&lt;    `.</div><div class="line">                |             ```          |           x| \ `.:``.</div><div class="line">                |                         .'    /'   xXX|  `:`M`M':.</div><div class="line">                |    |                    ;    /:' xXXX'|  -'MMMMM:'</div><div class="line">                `.  .'                   :    /:'       |-'MMMM.-'</div><div class="line">                 |  |                   .'   /'        .'MMM.-'</div><div class="line">                 `'`'                   :  ,'          |MMM&lt;</div><div class="line">                   |                     `'            |tbap\</div><div class="line">                    \                                  :MM.-'</div><div class="line">                     \                 |              .''</div><div class="line">                      \.               `.            /</div><div class="line">                       /     .:::::::.. :           /</div><div class="line">                      |     .:::::::::::`.         /</div><div class="line">                      |   .:::------------\       /</div><div class="line">                     /   .''               &gt;::'  /</div><div class="line">                     `',:                 :    .'</div><div class="line">                                          `:.:'</div><div class="line"></div><div class="line">        </div><div class="line">       */</div></pre></td></tr></table></figure>
<h3 id="电脑图像"><a href="#电脑图像" class="headerlink" title="电脑图像"></a>电脑图像</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                    ,----------------,              ,---------,</div><div class="line">               ,-----------------------,          ,"        ,"|</div><div class="line">             ,"                      ,"|        ,"        ,"  |</div><div class="line">            +-----------------------+  |      ,"        ,"    |</div><div class="line">            |  .-----------------.  |  |     +---------+      |</div><div class="line">            |  |                 |  |  |     | -==----'|      |</div><div class="line">            |  |  I LOVE DOS!    |  |  |     |         |      |</div><div class="line">            |  |  Bad command or |  |  |/----|`---=    |      |</div><div class="line">            |  |  C:\&gt;_          |  |  |   ,/|==== ooo |      ;</div><div class="line">            |  |                 |  |  |  // |(((( [33]|    ,"</div><div class="line">            |  `-----------------'  |," .;'| |((((     |  ,"</div><div class="line">            +-----------------------+  ;;  | |         |,"</div><div class="line">               /_)______________(_/  //'   | +---------+</div><div class="line">          ___________________________/___  `,</div><div class="line">         /  oooooooooooooooo  .o.  oooo /,   \,"-----------</div><div class="line">        / ==ooooooooooooooo==.o.  ooo= //   ,`\--&#123;)B     ,"</div><div class="line">       /_==__==========__==_ooo__ooo=_/'   /___________,"</div><div class="line">        </div><div class="line">       */</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                                   _________</div><div class="line">                                  /         /.</div><div class="line">           .-------------.       /_________/ |</div><div class="line">          /             / |      |         | |</div><div class="line">         /+============+\ |      | |====|  | |</div><div class="line">         ||C:\&gt;        || |      |         | |</div><div class="line">         ||            || |      | |====|  | |</div><div class="line">         ||            || |      |   ___   | |</div><div class="line">         ||            || |      |  |166|  | |</div><div class="line">         ||            ||/@@@    |   ---   | |</div><div class="line">         \+============+/    @   |_________|./.</div><div class="line">                            @          ..  ....'</div><div class="line">         ..................@     __.'.'  ''</div><div class="line">        /oooooooooooooooo//     ///</div><div class="line">       /................//     /_/</div><div class="line">       ------------------</div><div class="line">       */</div></pre></td></tr></table></figure>
<h3 id="龙"><a href="#龙" class="headerlink" title="龙"></a>龙</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">        11111111111111111111111111111111111111001111111111111111111111111</div><div class="line">        11111111111111111111111111111111111100011111111111111111111111111</div><div class="line">        11111111111111111111111111111111100001111111111111111111111111111</div><div class="line">        11111111111111111111111111111110000111111111111111111111111111111</div><div class="line">        11111111111111111111111111111000000111111111111111111111111111111</div><div class="line">        11111111111111111111111111100000011110001100000000000000011111111</div><div class="line">        11111111111111111100000000000000000000000000000000011111111111111</div><div class="line">        11111111111111110111000000000000000000000000000011111111111111111</div><div class="line">        11111111111111111111111000000000000000000000000000000000111111111</div><div class="line">        11111111111111111110000000000000000000000000000000111111111111111</div><div class="line">        11111111111111111100011100000000000000000000000000000111111111111</div><div class="line">        11111111111111100000110000000000011000000000000000000011111111111</div><div class="line">        11111111111111000000000000000100111100000000000001100000111111111</div><div class="line">        11111111110000000000000000001110111110000000000000111000011111111</div><div class="line">        11111111000000000000000000011111111100000000000000011110001111111</div><div class="line">        11111110000000011111111111111111111100000000000000001111100111111</div><div class="line">        11111111000001111111111111111111110000000000000000001111111111111</div><div class="line">        11111111110111111111111111111100000000000000000000000111111111111</div><div class="line">        11111111111111110000000000000000000000000000000000000111111111111</div><div class="line">        11111111111111111100000000000000000000000000001100000111111111111</div><div class="line">        11111111111111000000000000000000000000000000111100000111111111111</div><div class="line">        11111111111000000000000000000000000000000001111110000111111111111</div><div class="line">        11111111100000000000000000000000000000001111111110000111111111111</div><div class="line">        11111110000000000000000000000000000000111111111110000111111111111</div><div class="line">        11111100000000000000000001110000001111111111111110001111111111111</div><div class="line">        11111000000000000000011111111111111111111111111110011111111111111</div><div class="line">        11110000000000000001111111111111111100111111111111111111111111111</div><div class="line">        11100000000000000011111111111111111111100001111111111111111111111</div><div class="line">        11100000000001000111111111111111111111111000001111111111111111111</div><div class="line">        11000000000001100111111111111111111111111110000000111111111111111</div><div class="line">        11000000000000111011111111111100011111000011100000001111111111111</div><div class="line">        11000000000000011111111111111111000111110000000000000011111111111</div><div class="line">        11000000000000000011111111111111000000000000000000000000111111111</div><div class="line">        11001000000000000000001111111110000000000000000000000000001111111</div><div class="line">        11100110000000000001111111110000000000000000111000000000000111111</div><div class="line">        11110110000000000000000000000000000000000111111111110000000011111</div><div class="line">        11111110000000000000000000000000000000001111111111111100000001111</div><div class="line">        11111110000010000000000000000001100000000111011111111110000001111</div><div class="line">        11111111000111110000000000000111110000000000111111111110110000111</div><div class="line">        11111110001111111100010000000001111100000111111111111111110000111</div><div class="line">        11111110001111111111111110000000111111100000000111111111111000111</div><div class="line">        11111111001111111111111111111000000111111111111111111111111100011</div><div class="line">        11111111101111111111111111111110000111111111111111111111111001111</div><div class="line">        11111111111111111111111111111110001111111111111111111111100111111</div><div class="line">        11111111111111111111111111111111001111111111111111111111001111111</div><div class="line">        11111111111111111111111111111111100111111111111111111111111111111</div><div class="line">        11111111111111111111111111111111110111111111111111111111111111111</div><div class="line"></div><div class="line"></div><div class="line">        */</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                                                    __----~~~~~~~~~~~------___</div><div class="line">                                         .  .   ~~//====......          __--~ ~~</div><div class="line">                         -.            \_|//     |||\\  ~~~~~~::::... /~</div><div class="line">                      ___-==_       _-~o~  \/    |||  \\            _/~~-</div><div class="line">              __---~~~.==~||\=_    -_--~/_-~|-   |\\   \\        _/~</div><div class="line">          _-~~     .=~    |  \\-_    '-~7  /-   /  ||    \      /</div><div class="line">        .~       .~       |   \\ -_    /  /-   /   ||      \   /</div><div class="line">       /  ____  /         |     \\ ~-_/  /|- _/   .||       \ /</div><div class="line">       |~~    ~~|--~~~~--_ \     ~==-/   | \~--===~~        .\</div><div class="line">                '         ~-|      /|    |-~\~~       __--~~</div><div class="line">                            |-~~-_/ |    |   ~\_   _-~            /\</div><div class="line">                                 /  \     \__   \/~                \__</div><div class="line">                             _--~ _/ | .-~~____--~-/                  ~~==.</div><div class="line">                            ((-&gt;/~   '.|||' -_|    ~~-/ ,              . _||</div><div class="line">                                       -_     ~\      ~~---l__i__i__i--~~_/</div><div class="line">                                       _-~-__   ~)  \--______________--~~</div><div class="line">                                     //.-~~~-~_--~- |-------~~~~~~~~</div><div class="line">                                            //.-~~~--\</div><div class="line"></div><div class="line">        </div><div class="line">       */</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//                       )      (</span></div><div class="line"><span class="comment">//                  /+++=))    ((=+++\</span></div><div class="line"><span class="comment">//             /++++++++//      \\+++++++++\</span></div><div class="line"><span class="comment">//          /++++++++++//(  /\  )\\++++++++++\</span></div><div class="line"><span class="comment">//        /+++++++++++//  \\^^//  \\+++++++++++\</span></div><div class="line"><span class="comment">//     _/++++++++++++//  &#123;&#123;@::@&#125;&#125;  \\++++++++++++\_</span></div><div class="line"><span class="comment">//    /+++++++++++++((     &#123;\/&#125;     ))+++++++++++++\</span></div><div class="line"><span class="comment">//   /+++++++++++++++\\    &lt;**&gt;    //+++++++++++++++\</span></div><div class="line"><span class="comment">//  /+++++++++++++++++\\  / VV \  //+++++++++++++++++\</span></div><div class="line"><span class="comment">// /+++++++++++++++++++\\/******\//+++++++++++++++++++\</span></div><div class="line"><span class="comment">//|+/|++++++++++/\++++++(***/\***)++++++/\++++++++++|\+\</span></div><div class="line"><span class="comment">//|/ |+/\+/\+/\/  \+/\++\**|**|**/++/\+/  \/\+/\+/\+| \|</span></div><div class="line"><span class="comment">//v  |/  V  V  V   V  \+\|*|**|*|/+/  V   v  V  V  \|  v</span></div><div class="line"><span class="comment">//   v                 /*|*|**|*|*\...              v</span></div><div class="line"><span class="comment">//                    (**|*|**|*|**). .</span></div><div class="line"><span class="comment">//                   __\*|*|**|*|*/__. .</span></div><div class="line"><span class="comment">//                  (vvv(VVV)(VVV)vvv). .</span></div><div class="line"><span class="comment">//                      ............../ /</span></div><div class="line"><span class="comment">//                     / ............../</span></div><div class="line"><span class="comment">//                     ((</span></div></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">                 ___====-_  _-====___</div><div class="line">           _--^^^#####//      \\#####^^^--_</div><div class="line">        _-^##########// (    ) \\##########^-_</div><div class="line">       -############//  |\^^/|  \\############-</div><div class="line">     _/############//   (@::@)   \\############\_</div><div class="line">    /#############((     \\//     ))#############\</div><div class="line">   -###############\\    (oo)    //###############-</div><div class="line">  -#################\\  / VV \  //#################-</div><div class="line"> -###################\\/      \//###################-</div><div class="line">_#/|##########/\######(   /\   )######/\##########|\#_</div><div class="line">|/ |#/\#/\#/\/  \#/\##\  |  |  /##/\#/  \/\#/\#/\#| \|</div><div class="line">`  |/  V  V  `   V  \#\| |  | |/#/  V   '  V  V  \|  '</div><div class="line">   `   `  `      `   / | |  | | \   '      '  '   '</div><div class="line">                    (  | |  | |  )</div><div class="line">                   __\ | |  | | /__</div><div class="line">                  (vvv(VVV)(VVV)vvv)</div><div class="line">                  </div><div class="line">*/</div></pre></td></tr></table></figure>
<p><a href="http://shiyousan.com/post/635479912728885400" target="_blank" rel="external">参考博客</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[markdown使用技巧]]></title>
      <url>http://yoursite.com/2016/06/24/markdown%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h3 id="资料专栏"><a href="#资料专栏" class="headerlink" title="资料专栏"></a>资料专栏</h3><ul>
<li><a href="http://46aae4d1e2371e4aa769798941cef698.devproxy.yunshipei.com/column/details/markdown.html" target="_blank" rel="external">传送门</a></li>
</ul>
<h3 id="设置markdown背景色"><a href="#设置markdown背景色" class="headerlink" title="设置markdown背景色"></a>设置markdown背景色</h3><ul>
<li>借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">#7FFFD4</span>&gt;</span>这里的背景色是：Aquamarine，  十六进制颜色值：#7FFFD4， rgb(127, 255, 212)</div><div class="line">     <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>效果</li>
</ul>
<table><tr><td bgcolor="#00FF00">这里的背景色是：Lime，十六进制颜色值：#00FF00， rgb(0, 255, 0)</td></tr></table>


<a id="more"></a>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[帮程序员和站长减压放松的10个良心网站]]></title>
      <url>http://yoursite.com/2016/06/23/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E5%92%8C%E7%AB%99%E9%95%BF%E5%87%8F%E5%8E%8B%E6%94%BE%E6%9D%BE%E7%9A%8410%E4%B8%AA%E8%89%AF%E5%BF%83%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<h3 id="1-Calm"><a href="#1-Calm" class="headerlink" title="1.Calm"></a>1.<a href="http://www.calm.com/" target="_blank" rel="external">Calm</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%997.jpg" alt=""></center>

<ul>
<li><p>这是同类型中最火的网站了，站如其名，「平和」，通过自然的图像（阳光下的暖流、淙淙的小溪等）与缓缓的音乐，帮你在短时间内放松下来</p>
</li>
<li><p>左侧有时间设定，从2分钟到20分钟，右底部可以改变音频、图像，调节音量等。还有IOS客户端下载呦</p>
</li>
</ul>
<h3 id="2-Do-Nothing-For-2-Minutes"><a href="#2-Do-Nothing-For-2-Minutes" class="headerlink" title="2.Do Nothing For 2 Minutes"></a>2.<a href="http://www.donothingfor2minutes.com/" target="_blank" rel="external">Do Nothing For 2 Minutes</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%999.jpg" alt=""></center>

<ul>
<li><p>木头人，两分钟，这是一个简单到极致的网站，当你打开的时候，自动开始计时，这时间你不能触碰键盘和鼠标，否则2分钟会重置</p>
</li>
<li><p>你需要做的，就是放下手头的工作，静静地享受潮声，这也很棒，不是吗？两分钟足够你冷静下来，休息一下了</p>
</li>
</ul>
<a id="more"></a>
<h3 id="3-Get-Relaxed"><a href="#3-Get-Relaxed" class="headerlink" title="3.Get Relaxed"></a>3.<a href="http://www.getrelaxed.com/" target="_blank" rel="external">Get Relaxed</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%992.jpg" alt=""></center>

<ul>
<li><p>如果两分钟不足以让你彻底放松，试试这个。如下图，打开网站后，头枕着双手往后仰，欣赏自然风光，聆听网站为你精心挑选的音乐</p>
</li>
<li><p>图像3秒一换，有15种，每种持续大概2 – 4分钟，现在，开始吧！</p>
</li>
<li><p>提醒：网站有简陋广告，稍微影响体验</p>
</li>
</ul>
<h3 id="4-LoungeV-Studio"><a href="#4-LoungeV-Studio" class="headerlink" title="4.LoungeV Studio"></a>4.<a href="http://www.loungev.com/" target="_blank" rel="external">LoungeV Studio</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%996.jpg" alt=""></center>

<ul>
<li>前三个都是图像，现在来个新鲜的。这个网站提供高清的自然风光视频 + 音乐。有沙滩、瀑布、水下景色等等，网站背景是一个温馨的客厅，右侧有视频可选，对喜欢看视频的同学来说，还是蛮不错的</li>
</ul>
<h3 id="5-A-Soft-Murmur"><a href="#5-A-Soft-Murmur" class="headerlink" title="5.A Soft Murmur"></a>5.<a href="http://asoftmurmur.com/" target="_blank" rel="external">A Soft Murmur</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%991.jpg" alt=""></center>

<ul>
<li><p>这个网站太棒了！博主玩了好久都舍不得停下来。网站让你自由创造美妙的声音。你可以通过混合不同的声音（雨声、火柴燃烧的声音、打雷声、海潮声…..不一而足。但是，总有一款令你爱不释手！）当然，声音的大小也可以自己调节</p>
</li>
<li><p>如果你对混合的声音非常满意，也可以分享到脸书、谷歌等….</p>
</li>
</ul>
<h3 id="6-Nature-Sounds-For-Me"><a href="#6-Nature-Sounds-For-Me" class="headerlink" title="6.Nature Sounds For Me"></a>6.<a href="http://naturesoundsfor.me/" target="_blank" rel="external">Nature Sounds For Me</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%998.jpg" alt=""></center>

<ul>
<li><p>这个比上面那个界面稍逊，但是玩起来更嗨！它提供的声音除了以上的自然类声音，还有很多你想不到的：绵羊咩咩、骏马跺脚喷气、不同的鸟叫声，甚至是心脏跳动、厨房叮当的声音，不仅令人身临其境，而且搭配起来简直不能更欢乐！</p>
</li>
<li><p>当然，它还有IOS客户端。</p>
</li>
</ul>
<h3 id="7-Noisli"><a href="#7-Noisli" class="headerlink" title="7.Noisli"></a>7.<a href="http://www.noisli.com/" target="_blank" rel="external">Noisli</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%9910.jpg" alt=""></center>


<ul>
<li><p>这个网站根据你的情绪变化，选择不同的音乐和背景颜色。颜色大多朴素平和，背景声音也有对应的图标可以选择。还有一点贴心的设计是，网站右侧有便签本，你可以一边享受静谧时光一边随手记点事。</p>
</li>
<li><p>为了造福大众，网站还提供IOS 版。</p>
</li>
</ul>
<h3 id="8-Soundrown"><a href="#8-Soundrown" class="headerlink" title="8.Soundrown"></a>8.<a href="http://soundrown.com/" target="_blank" rel="external">Soundrown</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%995.jpg" alt=""></center>

<ul>
<li>网站一进去，有3个关键词：放松、专注、逃离。的确，它成功做到了这一点。它有10种不同的声音帮助你放松心情，也可以混合使用。不同的声音对应不同的背景，网站非常有设计感，相信你会重新回来体验一次</li>
</ul>
<h3 id="9-The-Thoughts-Room"><a href="#9-The-Thoughts-Room" class="headerlink" title="9.The Thoughts Room"></a>9.<a href="http://thequietplaceproject.com/" target="_blank" rel="external">The Thoughts Room</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%993.jpg" alt=""></center>

<ul>
<li>一句话简洁：世界的秘密——树洞类网站。你可以在这里向全世界倾诉你的任何想法，网站支持37种语言，不过看了一下，没有中国…</li>
</ul>
<h3 id="10-Raining-Fm"><a href="#10-Raining-Fm" class="headerlink" title="10.Raining.Fm"></a>10.<a href="http://raining.fm/" target="_blank" rel="external">Raining.Fm</a></h3><center><img src="http://7xstki.com1.z0.glb.clouddn.com/%E5%B8%AE%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%BE%E6%9D%BE%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BD%91%E7%AB%994.jpg" alt=""></center>

<ul>
<li>有时候，我们需要的仅仅是一点点雨声来帮助我们平静。网站专门提供雨声，因为单一，所以也更加专业。网站有3种不同的雨声类型，右侧有定时器可以在你放松时提醒你，简单也好用的一个网站，赞一个</li>
</ul>
<p>参考博客：<a href="https://www.licoy.cn/624.html" target="_blank" rel="external">传送门</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[优秀网站和博客]]></title>
      <url>http://yoursite.com/2016/06/23/%E4%BC%98%E7%A7%80%E7%BD%91%E7%AB%99%E5%92%8C%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><ul>
<li><p><a href="http://stormzhang.com/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="external">Android学习之路</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/af2de05aadff#rd" target="_blank" rel="external">国内外开发者的信息</a> 这里面收集了很多国内外开发者的信息, 大家可以去看看</p>
</li>
<li><p><a href="http://www.lrdup.net/" target="_blank" rel="external">键盘上的舞者</a> 东哥博客，主要是ios，其他编程啊之类的东西都有，很不错的一个站点，极力推荐</p>
</li>
<li><p><a href="http://blog.csdn.net/whjkm" target="_blank" rel="external">Just do it!</a> 杰哥博客，极力推荐</p>
</li>
</ul>
<ul>
<li><p><a href="https://www.licoy.cn/resource-sharing/fun-station" target="_blank" rel="external">憧憬点滴记忆</a>  比较综合的一个博客，技术文章，资源，项目，音乐，WEB等等都有</p>
</li>
<li><p><a href="http://tutuge.me/" target="_blank" rel="external">土土哥的技术Blog</a> 阿里的大神，iOS，Android等</p>
</li>
<li><p><a href="http://openhome.cc/Gossip/index.html" target="_blank" rel="external">台湾博主</a> 台湾的一个博主，有很多资料，主要是有Java资料，不过是繁体字</p>
</li>
<li><p><a href="http://0opslab.com/" target="_blank" rel="external">方丈</a> Java,JS,linux,python等等</p>
</li>
<li><p><a href="http://www.hollischuang.com/" target="_blank" rel="external">hollis blog</a> 有Java，框架，操作系统，以及其他综合类的很多文章，非常不错</p>
</li>
<li><p><a href="http://www.hankcs.com/program/java/" target="_blank" rel="external">码农场</a> C++,JAVA,机器算法，算法，软件等</p>
</li>
<li><p><a href="http://blog.csdn.net/lmj623565791" target="_blank" rel="external">Hongyang</a> Android,大神级别的博客啊！每一篇的文章的质量都很高，简直可以当电子书来看了</p>
</li>
<li><p><a href="http://blog.csdn.net/bboyfeiyu/article/list/2" target="_blank" rel="external">Mr.Simple的专栏</a> Android,写过《Android开发进阶 从小工到专家》《Android源码设计模式解析与实战》</p>
</li>
<li><p><a href="http://blog.csdn.net/singwhatiwanna" target="_blank" rel="external">任玉刚</a> Android开发艺术探索这本书的作者</p>
</li>
<li><p><a href="http://blog.csdn.net/wwj_748" target="_blank" rel="external">巫山老妖</a> Android</p>
</li>
<li><p><a href="http://blog.csdn.net/aigestudio" target="_blank" rel="external">AigeStudio</a> Android</p>
</li>
<li><p><a href="http://blog.csdn.net/eclipsexys" target="_blank" rel="external">eclipse_xu</a> 《Android群英传》的作者</p>
</li>
<li><p><a href="http://blog.csdn.net/sinyu890807/" target="_blank" rel="external">郭霖的专栏</a> 《第一行代码的作者》</p>
</li>
<li><p><a href="http://blog.csdn.net/zhaokaiqiang1992" target="_blank" rel="external">赵凯强CSDN</a> <a href="http://kaizige.vip/" target="_blank" rel="external">赵凯强Hexo</a></p>
</li>
<li><p><a href="http://blog.csdn.net/xiangzhihong8" target="_blank" rel="external">xiangzhihong8的专栏</a></p>
</li>
<li><p><a href="http://blog.csdn.net/lzyzsd?viewmode=list" target="_blank" rel="external">大头鬼Bruce</a> 我是看他的博客写RxJava的</p>
</li>
<li><p><a href="http://blog.csdn.net/nugongahou110" target="_blank" rel="external">阿拉灯神灯的专栏</a> 学习Android自定义控件的好地方</p>
</li>
<li><p><a href="http://blog.csdn.net/qq_23547831?viewmode=contents" target="_blank" rel="external">一片枫叶的专栏</a> Android产品研发系列</p>
</li>
<li><p><a href="http://wuxiaolong.me/archives/" target="_blank" rel="external">吴小龙同學</a> Android</p>
</li>
<li><p><a href="http://android-developers.blogspot.com/" target="_blank" rel="external">Android Developers Blog</a> Android官网博客, 在上面可以关注Android最新的进展与最权威的博客(需翻墙)</p>
</li>
<li><p><a href="http://hukai.me/" target="_blank" rel="external">胡凯</a> 目前就职于腾讯上海从事Android开发的工作, 发起 Google Android 官方培训课程中文版翻译, 这课程是学习Android应用开发的绝佳资料</p>
</li>
<li><p><a href="http://www.trinea.cn/" target="_blank" rel="external">Trinea</a>  目前在滴滴负责 Android 客户端技术, 他是开源库项目收集达人, 你想要的开源库上面都有, 并且发起 Android 开源项目源码解析, 在使用开源库的同时也可以知道其中原理, 大家可以去关注一下, <a href="http://p.codekk.com/" target="_blank" rel="external">地址</a></p>
</li>
<li><p><a href="http://blog.daimajia.com/" target="_blank" rel="external">代码家</a> 90后Android大神, 称作库达人, 博主收集了很多Android开源库, 博主自己也做了很多开源库, 非常值得学习</p>
</li>
<li><p><a href="http://stormzhang.com/" target="_blank" rel="external">stormzhang</a> 博主是上海薄荷科技开发主管, 他的博客分享了他从编程白痴到自学 Android 一路走过的经验, 写了一篇 <a href="http://stormzhang.com/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="external">Android学习之路</a> 帮助了无数人, 里面还有很多好的文章非常适合新手入门, 并且是微信公众号「AndroidDeveloper」的运营者</p>
</li>
<li><p><a href="http://www.lightskystreet.com/" target="_blank" rel="external">light_sky</a> Android开发工程师, 目前在北京工作. Google big fan, 热爱开源, 热爱分享, 活跃于GitHub、G+、Twitter, 捕捉Android最新资讯和技术, ViewPagerIndicator 开源项目分析者</p>
</li>
<li><p><a href="http://blog.csdn.net/lmj623565791/" target="_blank" rel="external">张鸿洋</a> Android,张鴻洋是 CSDN 博客专家, 博主在 CSDN 所发布的每一篇文章都是干货, 都很值得大家去学习</p>
</li>
<li><p><a href="http://blog.csdn.net/xyz_lmn" target="_blank" rel="external">张兴业</a> Android,张兴业同样也是 CSDN 博客专家, 博主专注移动互联网开发，关注移动支付业务</p>
</li>
<li><p><a href="http://blog.csdn.net/lzyzsd/" target="_blank" rel="external">hi大头鬼hi</a> hi大头鬼hi 是阿里巴巴集团的一名 Android 工程师, 擅长 Android, RxJava, RxAndroid, ReactNative, Node.js, 大前端, 可谓是全栈工程师, 如果你对 RxJava 技术感兴趣, 不妨到他的博客看看, 他写了一系列有关 RxJava 的介绍</p>
</li>
</ul>
<h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><ul>
<li><p><a href="http://www.v2ex.com/?tab=tech" target="_blank" rel="external">v2ex</a> 国内的IT论坛</p>
</li>
<li><p><a href="http://stackoverflow.com/" target="_blank" rel="external">stackoverflow</a> 全球最大的IT论坛</p>
</li>
<li><p><a href="https://segmentfault.com/t/android" target="_blank" rel="external">SegmentFault</a> SegmentFault 是一个专注于解决编程问题, 提高开发技能的社区</p>
</li>
<li><p><a href="http://www.eoeandroid.com/forum.php" target="_blank" rel="external">eoe 移动开发者社区</a> 让移动开发更简单, 做最棒的开发者社区</p>
</li>
<li><p><a href="http://www.apkbus.com/" target="_blank" rel="external">APKBUS 安卓巴士</a> APKBUS 安卓巴士是一家服务于中国移动开发者学习与成长需要的综合社区服务平台</p>
</li>
<li><p><a href="http://chinagdg.org/" target="_blank" rel="external">谷歌开发者社区(GDG)</a> GDG 是 Google Developer Groups 的缩写, 中文名称是谷歌开发者社区</p>
</li>
<li><p><a href="http://gold.xitu.io/welcome" target="_blank" rel="external">掘金-稀土</a>  一个高质量的技术社区</p>
</li>
</ul>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><h3 id="技术网站"><a href="#技术网站" class="headerlink" title="技术网站"></a>技术网站</h3><ul>
<li><p><a href="https://www.livecoding.tv/" target="_blank" rel="external">livecoding</a> 代码直播平台</p>
</li>
<li><p><a href="https://handmadehero.org" target="_blank" rel="external">handMadeHero</a> 游戏开发视频网站</p>
</li>
<li><p><a href="https://next.36kr.com/posts/collections/61" target="_blank" rel="external">NEXT</a> H5界面制作工具集合</p>
</li>
</ul>
<h3 id="技术杂志周刊"><a href="#技术杂志周刊" class="headerlink" title="技术杂志周刊"></a>技术杂志周刊</h3><ul>
<li><p><a href="http://gank.io/" target="_blank" rel="external">干货集中营</a> 每个工作日推送最近比较火的技术和好看的妹纸</p>
</li>
<li><p><a href="http://www.androidweekly.cn/" target="_blank" rel="external">Android开发技术周报</a> 每周看一看有什么新技术和好东西出现</p>
</li>
</ul>
<h3 id="工具网站"><a href="#工具网站" class="headerlink" title="工具网站"></a>工具网站</h3><ul>
<li><p><a href="http://tool.oschina.net/" target="_blank" rel="external">在线工具</a> 常用的编程在线工具，录入正则表达式，API，RGB对照表之类的</p>
</li>
<li><p><a href="http://www.easyicon.net/" target="_blank" rel="external">easyicon</a> icon图标搜索引擎，非常不错的东西</p>
</li>
</ul>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul>
<li><p><a href="http://tool.oschina.net/apidocs/api" target="_blank" rel="external">常用 API</a> 常用API文档索引合集</p>
</li>
<li><p><a href="http://www.runoob.com" target="_blank" rel="external">runoob</a> 编程语言参考手册，有语法，使用规范之类的，包含很多语言</p>
</li>
<li><p><a href="https://github.com/JustinSDK/JavaSE6Tutorial" target="_blank" rel="external">Java SE 6 技术手册</a></p>
</li>
</ul>
<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><ul>
<li><p><a href="http://www.jianshu.com/p/af2de05aadff#rd" target="_blank" rel="external">Android 学习资料收集</a></p>
</li>
<li><p><a href="https://developer.android.com/training/index.html" target="_blank" rel="external">Android官方培训课程</a> 官方出品，必属精品。（需科学上网）</p>
</li>
<li><p><a href="http://www.nowcoder.com/" target="_blank" rel="external">牛客网</a> 面试题网站</p>
</li>
</ul>
<h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><ul>
<li><p><a href="https://github.com/googlesamples/android-UniversalMusicPlayer" target="_blank" rel="external">Google play music</a> 一个跨多个平台音乐播放器</p>
</li>
<li><p><a href="http://www.android-gems.com/category" target="_blank" rel="external">Android Gems</a>  将GitHub上优秀的Android开源项目做好各种分类，再也不需要在GitHub上瞎找了</p>
</li>
<li><p><a href="https://github.com/MiCode/Notes" target="_blank" rel="external">MIUI 便签</a> MiCode 便签是小米便签的社区开源版, 由 MIUI 团队（ww.miui.com）发起并贡献第一批代码, 遵循 NOTICE 文件所描述的开源协议</p>
</li>
<li><p><a href="https://github.com/eoecn/android-app" target="_blank" rel="external">eoe 客户端</a>     eoe 社区Android客户端</p>
</li>
</ul>
<h3 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h3><ul>
<li><p><a href="http://alamkanak.github.io/android-libraries-and-resources/" target="_blank" rel="external">Android Libraries and Resources</a></p>
</li>
<li><p><a href="http://android-arsenal.com/" target="_blank" rel="external">Android Arsenal</a> (一个专门收集 android 开源库的网站, 网站经常更新)</p>
</li>
<li><p><a href="http://www.jcodecraeer.com/plus/list.php?tid=31" target="_blank" rel="external">泡在网上的日子</a></p>
</li>
<li><p><a href="https://github.com/Trinea/android-open-project" target="_blank" rel="external">Android 开源项目汇总</a> (Trinea 大神收集的)</p>
</li>
<li><p><a href="http://codekk.com/open-source-project-analysis" target="_blank" rel="external">Android 开源项目源码分析</a> (在懂得使用这些开源项目同时, 也应该了解当中的原理)</p>
</li>
</ul>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><ul>
<li><p><a href="http://www.zhihu.com/question/19775981" target="_blank" rel="external">有哪些 Android 大牛的 blog 值得推荐?</a></p>
</li>
<li><p><a href="http://www.zhihu.com/question/23804819" target="_blank" rel="external">GitHub 上都有哪些值得关注学习的 Android项目?</a></p>
</li>
</ul>
<h3 id="素材和设计"><a href="#素材和设计" class="headerlink" title="素材和设计"></a>素材和设计</h3><ul>
<li><p><a href="http://tool.c7sky.com/webcolor/" target="_blank" rel="external">常用色彩搭配表</a></p>
</li>
<li><p><a href="http://www.colorhunt.co/" target="_blank" rel="external">ColorHunt-色彩搭配</a></p>
</li>
<li><p><a href="http://www.materialpalette.com/" target="_blank" rel="external">在线 Material Design 界面调色板</a></p>
</li>
<li><p><a href="http://www.materialup.com/" target="_blank" rel="external">Material Design设计模板与素材</a></p>
</li>
<li><p><a href="https://icons8.com/" target="_blank" rel="external">App Icon 图标</a></p>
</li>
<li><p><a href="https://iconstore.co/" target="_blank" rel="external">Icon Store</a></p>
</li>
</ul>
<h3 id="影视网站"><a href="#影视网站" class="headerlink" title="影视网站"></a>影视网站</h3><ul>
<li><p><a href="http://www.zhaifu.cc/bl/dianying/" target="_blank" rel="external">腐宅资源站</a> 各种电影电视剧动画资源</p>
</li>
<li><p><a href="http://www.565k.com/" target="_blank" rel="external">565k</a> 各种电影</p>
</li>
</ul>
<h3 id="音乐网站"><a href="#音乐网站" class="headerlink" title="音乐网站"></a>音乐网站</h3><ul>
<li><p><a href="http://www.mtyyw.com" target="_blank" rel="external">麦田音乐网</a> 主要是轻音乐，民谣，电台，歌单，摇滚，原声，影像，还有有文艺范的画，故事等等……</p>
</li>
<li><p><a href="https://music.douban.com/" target="_blank" rel="external">豆瓣音乐</a> 豆瓣，情怀，不解释</p>
</li>
<li><p><a href="http://www.top100.cn/" target="_blank" rel="external">巨鲸音乐</a> 看起来挺简洁，符合我的风格，先试试</p>
</li>
<li><p><a href="https://yahoo.streetvoice.com/" target="_blank" rel="external">奇摩音乐</a> 看起来还不错的样子~</p>
</li>
<li><p><a href="http://music.weibo.com/" target="_blank" rel="external">微博音乐</a> 草根比较多，应该还可以~</p>
</li>
</ul>
<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul>
<li><p><a href="https://book.douban.com/subject/26599539/" target="_blank" rel="external">Android群英传</a> 这是一本进阶的书 <a href="http://pan.baidu.com/s/1c2gGl6C" target="_blank" rel="external">传送门</a></p>
</li>
<li><p><a href="https://book.douban.com/subject/26599538/" target="_blank" rel="external">Android开发艺术探索</a> 网上的好评如潮，是一本进阶的好书</p>
</li>
<li><p><a href="https://book.douban.com/subject/26644935/" target="_blank" rel="external">Android源码设计模式解析与实战</a></p>
</li>
<li><p><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="external">Effective Java</a></p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><a href="https://bandwagonhost.com/index.php" target="_blank" rel="external">搬瓦工</a> 美国的VPS网站，最低大概120人民币一年</li>
</ul>
<a id="more"></a>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[中间件]]></title>
      <url>http://yoursite.com/2016/06/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>读写分离解决的是读压力大的问题，对于数据量大或更新量大的情况并不适用。数据水平拆分与数据垂直拆分的区别是：垂直拆分是把不同的表拆分到不同的数据库中，而水平拆分的是把同一个表拆分到不同的数据库中<br>水平拆分给业务应用带来的影响：</p>
<ol>
<li>访问用户信息的应用程序需要解决SQL路由的问题</li>
<li>主键的处理也不同，自增字段不能简单的使用了，并且在不同的数据库中也不能直接使用一些数据库的限制来保证主键不重复了</li>
</ol>
<p>消息中间件(异步和解耦)<br>Message-oriented middleware(MOM) is software infrastructure focused on sending and receiving message between distributed systems</p>
<p>三个领域的中间件</p>
<ol>
<li>远程过程调用和对象访问中间件：主要解决分布式环境下应用的互相访问问题。这也是支撑我们介绍应用服务化的基础</li>
<li>消息中间件：主要解决应用之间的消息传递、解耦、异步的问题</li>
<li>数据访问中间件：主要解决应用访问数据库的共性问题的组件。</li>
</ol>
<p>线程池的作用</p>
<ol>
<li><p>使用线程池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class PoolTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int count=20000;</div><div class="line">		long startTime = System.currentTimeMillis();</div><div class="line">		final LinkedList&lt;Integer&gt; lst = new LinkedList&lt;Integer&gt;();</div><div class="line">		ThreadPoolExecutor tp = new ThreadPoolExecutor(1, 1, 60, TimeUnit.SECONDS,</div><div class="line">				new LinkedBlockingDeque&lt;Runnable&gt;(count));</div><div class="line">		final Random random = new Random();</div><div class="line">		for(int i=0;i&lt;count;i++)&#123;</div><div class="line">			tp.execute(new Runnable() &#123;</div><div class="line"></div><div class="line">				@Override</div><div class="line">				public void run() &#123;</div><div class="line">					lst.add(random.nextInt());</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">		tp.shutdown();</div><div class="line">		try &#123;</div><div class="line">			tp.awaitTermination(1, TimeUnit.DAYS);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">		&#125;</div><div class="line">		System.out.println(System.currentTimeMillis() - startTime);</div><div class="line">		System.out.println(lst.size());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">用时 117</div></pre></td></tr></table></figure>
</li>
<li><p>不使用线程池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class GeneralTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int count=20000;</div><div class="line">		long startTime = System.currentTimeMillis();</div><div class="line">		final LinkedList&lt;Integer&gt; lst = new LinkedList&lt;Integer&gt;();</div><div class="line">		final Random random = new Random();</div><div class="line">		for(int i=0;i&lt;count;i++)&#123;</div><div class="line">			Thread thread = new Thread()&#123;</div><div class="line">				@Override</div><div class="line">				public void run() &#123;</div><div class="line">					lst.add(random.nextInt());</div><div class="line">				&#125;</div><div class="line">			&#125;;</div><div class="line">			thread.start();</div><div class="line">			try &#123;</div><div class="line">				thread.join();</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(System.currentTimeMillis() - startTime);</div><div class="line">		System.out.println(lst.size());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">用时 2000毫秒</div></pre></td></tr></table></figure>
</li>
</ol>
<p>AtomicInteger的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class AtomTest&#123;</div><div class="line">	private AtomicInteger counter = new AtomicInteger(0);</div><div class="line">	public void increment()&#123;</div><div class="line">		counter.incrementAndGet();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int getCount()&#123;</div><div class="line">		return counter.get();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		final AtomTest at = new AtomTest();</div><div class="line">		for(int i=0;i&lt;100;i++)&#123;</div><div class="line">			Thread thread =new Thread()&#123;</div><div class="line">				@Override</div><div class="line">				public void run() &#123;</div><div class="line">					at.increment();</div><div class="line">				&#125;;</div><div class="line">			&#125;;</div><div class="line"></div><div class="line">			thread.start();</div><div class="line">			try &#123;</div><div class="line">				// 即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止</div><div class="line">				thread.join();</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		System.out.println(at.getCount());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意： 对wait、notify和notifyAll的调用都必须是在对象的synchronized块中<br>在时间中，对wait的使用一般是嵌在一个循环中，并且会判断相关的数据状态是否达到预期，如果没有则会继续等待，这么做也是为了防止虚假唤醒</p>
<p>调用函数后马上返回，然后继续向下执行。两种方式实现；一个是用Future，另一个使用回调。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private Future&lt;HashMap&gt; getDataFromRemote2()&#123;</div><div class="line">	reutrn threadPool.submit(new Callable&lt;HashMap&gt;()&#123;</div><div class="line">		public HashMap call() throw Exception&#123;</div><div class="line">			return getDataFromRemote();</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class AtomTest&#123;</div><div class="line">	private AtomicInteger counter = new AtomicInteger(0);</div><div class="line">	public void increment()&#123;</div><div class="line">		counter.incrementAndGet();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int getCount()&#123;</div><div class="line">		return counter.get();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		final AtomTest at = new AtomTest();</div><div class="line">		for(int i=0;i&lt;100;i++)&#123;</div><div class="line">			Thread thread =new Thread()&#123;</div><div class="line">				@Override</div><div class="line">				public void run() &#123;</div><div class="line">					at.increment();</div><div class="line">				&#125;;</div><div class="line">			&#125;;</div><div class="line"></div><div class="line">			thread.start();</div><div class="line">			try &#123;</div><div class="line">				// 即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止</div><div class="line">				thread.join();</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(at.getCount());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>动态代理</p>
<p>与动态代理一样，反射也是中间件实现的重要基础。反射是Java提供的非常方便又强大的功能。Java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意个方法和属性。Java反射机制主要提供一下功能：在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和成员方法；在运行时调用任意一个对象的方法；生成动态代理。</p>
<p>String className = clazz.getName()              // 获取类的名称<br>Method[] methods = clazz.getDeclaredMethods()   //获取类中定义的方法<br>Field[] fields = clazz.getDeclaredFields();     // 获取类中定义的方法<br>Class.forName(“className”).newInstance();<br>注意通过newInstance调用来构造对象时，要求被构造的对象的类一定要有一个 <strong> 无参数的构造方法 </strong> ，否则异常</p>
<p>服务框架要解决的问题 ： 接口调用、寻址路由、编码、通信<br>一般规则服务器的方式更多的运用在有状态的场景。像数据这种状态要求很高的场景，或者缓存这种尽量要有状态的场景，都会用到规则服务器的方式来解决寻址问题，在无状态的服务场景中，则不太用规则服务器的方式来处理。</p>
<p>序列化就是把内存对象变为二进制数据的过程，而反序列化就是把二进制数据变为内存中可用对象的过程。</p>
<p>四种常见的异步远程通信方式：Oneway是一个单向的通知，Callback则是回调，是一种被动的方式，Callback的执行不是在原请求线程中；而Future是一种能够主动控制超时、获取结果的方式i，并且它的执行仍然在原请求线程中；可靠异步方式能保证异步请求在远程被执行。</p>
<p>垂直拆分带来影响</p>
<ol>
<li>单机的ACID保证被打破了，要么放弃原来的单机事务，修改实现，要么引入分布式事务</li>
<li>join操作不能使用</li>
<li>靠外键去进行约束的场景受影响<br>水平拆分带来影响</li>
<li>同上1,2,3</li>
<li>依赖单库的自增序列生成唯一ID受影响</li>
<li>针对单个逻辑意义的表的查询要跨库</li>
</ol>
<p>分布式事务<br>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点上。<br>在分布式系统中，我们一般还是选择加强可用性和分区容忍性而牺牲一致性，保证数据最终一致性</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安装小结]]></title>
      <url>http://yoursite.com/2016/06/09/%E5%AE%89%E8%A3%85%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="Ubuntu-中apt-get用法："><a href="#Ubuntu-中apt-get用法：" class="headerlink" title="Ubuntu 中apt-get用法："></a>Ubuntu 中apt-get用法：</h3><p>查找软件<br>命令： apt-cache search keyword</p>
<p>查询软件状态<br>命令： apt-cache policy softname</p>
<p>安装软件<br>命令： apt-get install softname1 softname2 softname3……</p>
<p>卸载软件<br>命令： apt-get remove softname1 softname2 softname3……</p>
<p>卸载并清除配置<br>命令： apt-get remove –purge softname1</p>
<p>更新软件信息数据库<br>命令： apt-get update</p>
<p>进行系统升级<br>命令： apt-get upgrade</p>
<p>搜索软件包<br>命令： apt-cache search softname1 softname2 softname3……</p>
<p>Deb软件包相关安装与卸载<br>安装deb软件包<br>命令： dpkg -i xxx.deb</p>
<h3 id="TimeNet4-的安装"><a href="#TimeNet4-的安装" class="headerlink" title="TimeNet4 的安装"></a>TimeNet4 的安装</h3><p>apt-get install openjdk-7-jre<br>apt-get install build-essential<br>apt-get install unixodbc-dev<br>apt-get install liblpsolve55-dev</p>
<p>run /TimeNET/bin/startGUI</p>
<h3 id="Qt5-3安装"><a href="#Qt5-3安装" class="headerlink" title="Qt5.3安装"></a>Qt5.3安装</h3><p><a href="https://download.qt.io/archive/qt/5.3/5.3.0/" target="_blank" rel="external">下载</a> qt-opensource-linux-x64-5.3.0.run<br>安装依赖 sudo apt-get install build-essential libgl1-mesa-dev<br>赋予权限 chmod +x qt-opensource-linux-x64-5.3.0.run<br>执行 ./qt-opensource-linux-x64-5.3.0.run</p>
<h3 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h3><p>解压之后<br>sudo gedit /etc/environment<br>添加如下<br>PATH=”/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/tecn/jdk1.7.0_55/bin”<br>CLASSPATH=”/home/tecn/jdk1.7.0_55/lib:.”       注意后面有个点<br>JAVA_HOME=”/home/tecn/jdk1.7.0_55/“<br>注销或重启使环境变量生效  执行java -version</p>
<p>已经装有openjdk启用官方jdk的方法：<br>依次终端执行：<br>sudo update-alternatives –install /usr/bin/java java /home/tecn/jdk1.7.0_55/bin/java 445<br>sudo update-alternatives –install /usr/bin/javac javac /home/tecn/jdk1.7.0_55/bin/javac 445<br>sudo update-alternatives –config java<br>将会提示，要维持当前值[*]请按回车键，或者输入选择的编号：<br>输入优先级为 445 的那项的编号，回车即可。</p>
<h3 id="centso安装pip-下载源码安装"><a href="#centso安装pip-下载源码安装" class="headerlink" title="centso安装pip 下载源码安装"></a>centso安装pip 下载源码安装</h3><p>wget –no-check-certificate <a href="https://github.com/pypa/pip/archive/1.5.5.tar.gz" target="_blank" rel="external">https://github.com/pypa/pip/archive/1.5.5.tar.gz</a><br>tar zvxf 1.5.5.tar.gz    #解压文件<br>cd pip-1.5.5/<br>python setup.py install</p>
<p>你可以检查日志或者控制 Shadowsocks 的运行：<br>supervisorctl tail -f shadowsocks stderr<br>supervisorctl restart shadowsocks</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[myBatis学习笔记]]></title>
      <url>http://yoursite.com/2016/06/09/myBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="mybatis-接触"><a href="#mybatis-接触" class="headerlink" title="mybatis 接触"></a>mybatis 接触</h3><p>configure.xml</p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!DOCTYPE configuration PUBLIC “-//mybatis.org//DTD Config 3.0//EN”<br>“<a href="http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;" target="_blank" rel="external">http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</a></p>
<configuration><br>    <typealiases><br>        <typealias alias="User" type="com.yihaomen.mybatis.model.User"><br>    </typealias></typealiases><br><br>    <environments default="development"><br>        <environment id="development"><br>        <transactionmanager type="JDBC"><br>            <datasource type="POOLED"><br>            <property name="driver" value="com.mysql.jdbc.Driver"><br>            <property name="url" value="jdbc:mysql://127.0.0.1:3306/test"><br>            <property name="username" value="root"><br>            <property name="password" value="root"><br>            </property></property></property></property></datasource><br>        </transactionmanager></environment><br>    </environments><br><br>    <mappers><br>        <mapper resource="com/yihaomen/mybatis/model/User.xml"><br>    </mapper></mappers><br></configuration>

<p>user.xml</p>
<mapper namespace="com.yihaomen.mybatis.models.UserMapper"><br>    <select id="selectUserByID" parametertype="int" resulttype="User"><br>        select * from <code>user</code> where id = #{id}<br>    </select><br></mapper>


<p>public class Test {<br>    private static SqlSessionFactory sqlSessionFactory;<br>    private static Reader reader;</p>
<pre><code>static {
    try {
        reader = Resources.getResourceAsReader(&quot;Configuration.xml&quot;);
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

public static void main(String[] args) {
    SqlSession session = sqlSessionFactory.openSession();
    try {
        User user = (User) session.selectOne(
                &quot;com.yihaomen.mybatis.models.UserMapper.selectUserByID&quot;, 1);
        System.out.println(user.getUserAddress());
        System.out.println(user.getUserName());
    } finally {
        session.close();
    }
}
</code></pre><p>}</p>
<h3 id="使用接口实现"><a href="#使用接口实现" class="headerlink" title="使用接口实现"></a>使用接口实现</h3><p>user.xml ,改变namespace的值，指向接口</p>
<mapper namespace="com.yihaomen.mybatis.inter.IUserOperation"><br>    <select id="selectUserByID" parametertype="int" resulttype="User"><br>        select * from <code>user</code> where id = #{id}<br>    </select><br></mapper>

<p>public static void main(String[] args) {<br>        SqlSession session = sqlSessionFactory.openSession();<br>        try {<br>            IUserOperation userOperation = session.getMapper(IUserOperation.class);<br>            User user = userOperation.selectUserByID(1);<br>            System.out.println(user.getUserAddress());<br>            System.out.println(user.getUserName());<br>        } finally {<br>            session.close();<br>        }<br>    }</p>
<h3 id="mybatis实现数据的增删改查"><a href="#mybatis实现数据的增删改查" class="headerlink" title="mybatis实现数据的增删改查"></a>mybatis实现数据的增删改查</h3><p>一、 查找<br>User.xml 配置</p>
<mapper namespace="com.yihaomen.mybatis.inter.IUserOperation"><br>    <select id="selectUserByID" parametertype="int" resulttype="User"><br>        select <em> from <code>user</code> where id = #{id}<br>    </em></select><br>    <resultmap type="User" id="resultListUser"><br>        <id column="id" property="id"><br>        <result column="userName" property="userName"><br>        <result column="userAge" property="userAge"><br>        <result column="userAddress" property="userAddress"><br>    </result></result></result></id></resultmap><br>    <select id="selectUsers" parametertype="string" resultmap="resultListUser"><br>        select  from user where userName like #{userName}<br>    </select><br></mapper>

<p>接口增加方法<br>public interface IUserOperation {<br>    public User selectUserByID(int id);<br>    public List<user> selectUsers(String userName);<br>}</user></p>
<p>测试类<br>    public static void main(String[] args) {<br>        Test testUser = new Test();<br>        testUser.getUserList(“%”);<br>    }</p>
<pre><code>public void getUserList(String userName){
    SqlSession session = sqlSessionFactory.openSession();
    try {
        IUserOperation userOperation = session
                .getMapper(IUserOperation.class);
        List&lt;User&gt; users = userOperation.selectUsers(userName);
        for (User user : users) {
            System.out.println(user.getId() + &quot;:&quot; + user.getUserName()
                    + &quot;:&quot; + user.getUserAddress());
        }
    } finally {
        session.close();
    }
}
</code></pre><p>二、 增加<br>user.xml</p>
<insert id="addUser" parametertype="User" usegeneratedkeys="true" keyproperty="id"><br>        insert into user(userName,userAge,userAddress)<br>             values(#{userName},#{userAge},#{userAddress})<br></insert>

<p>public interface IUserOperation {<br>    public User selectUserByID(int id);<br>    public List<user> selectUsers(String userName);<br>    public void addUser(User user);<br>}</user></p>
<p>public static void main(String[] args) {<br>        User user = new User();<br>        user.setUserAddress(“人民广场”);<br>        user.setUserName(“飞鸟”);<br>        user.setUserAge(20);<br>        SqlSession session = sqlSessionFactory.openSession();<br>        try {<br>            IUserOperation userOperation = session.getMapper(IUserOperation.class);<br>            userOperation.addUser(user);<br>            session.commit();<br>            System.out.println(“id : “+user.getId());<br>        } catch (Exception e) {<br>            // TODO: handle exception<br>        }finally{<br>            session.close();<br>        }<br>    }</p>
<p>三、更新数据</p>
<update id="updateUser" parametertype="User"><br>        update user set userName=#{userName},userAge=#{userAge},userAddress=#{userAddress} where id=#{id}<br></update>

<p>public interface IUserOperation {<br>    public User selectUserByID(int id);<br>    public List<user> selectUsers(String userName);<br>    public void addUser(User user);<br>    public void updateUser(User user);<br>}</user></p>
<p>public static void main(String[] args) {<br>        SqlSession session = sqlSessionFactory.openSession();<br>        try {<br>            IUserOperation userOperation = session.getMapper(IUserOperation.class);<br>            User user = userOperation.selectUserByID(4);<br>            user.setUserAddress(“hell”);<br>            userOperation.updateUser(user);<br>            session.commit();<br>        } catch (Exception e) {<br>            // TODO: handle exception<br>        }finally{<br>            session.close();<br>        }<br>    }</p>
<p>四、删除数据<br> <delete id="deleteUser" parametertype="int"><br>        delete from user where id=#{id}<br> </delete></p>
<p> public interface IUserOperation {<br>    public User selectUserByID(int id);<br>    public List<user> selectUsers(String userName);<br>    public void addUser(User user);<br>    public void updateUser(User user);<br>    public void deleteUser(int id);<br>}</user></p>
<p>public static void main(String[] args) {<br>        SqlSession session = sqlSessionFactory.openSession();<br>        try {<br>            IUserOperation userOperation = session.getMapper(IUserOperation.class);<br>            userOperation.deleteUser(4);<br>            session.commit();<br>        } catch (Exception e) {<br>            // TODO: handle exception<br>        }finally{<br>            session.close();<br>        }<br>    }<br>五、表关联<br>    别名：<br>    <typealiases><br>        <typealias alias="Article" type="com.yihaomen.mybatis.model.Article"><br>    </typealias></typealiases></p>
<pre><code>&lt;resultMap id=&quot;resultUserArticleList&quot; type=&quot;com.yihaomen.mybatis.model.Article&quot;&gt;  // 写全类名，否则提示找不到类
    &lt;id property=&quot;id&quot; column=&quot;aid&quot;/&gt;
    &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;
    &lt;result property=&quot;content&quot; column=&quot;content&quot;/&gt;

    &lt;association property=&quot;user&quot; javaType=&quot;User&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
        &lt;result property=&quot;userName&quot; column=&quot;userName&quot;/&gt;
        &lt;result property=&quot;userAddress&quot; column=&quot;userAddress&quot;/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;getUserArticles&quot; parameterType=&quot;int&quot; resultMap=&quot;resultUserArticleList&quot;&gt;
   select user.id,user.userName,user.userAddress,article.id aid,article.title,article.content from user,article
          where user.id=article.userid and user.id=#{id}
&lt;/select&gt;
</code></pre><p>public class Article {<br>    private int id;<br>    private User user;<br>    private String title;<br>    private String content;<br>}</p>
<p>public interface IUserOperation {<br>    public User selectUserByID(int id);<br>    public List<user> selectUsers(String userName);<br>    public void addUser(User user);<br>    public void updateUser(User user);<br>    public void deleteUser(int id);<br>    public List<article> getUserArticles(int id);<br>}</article></user></p>
<p>public void getUserArticles(int userid){<br>        SqlSession session = sqlSessionFactory.openSession();<br>        try {<br>            IUserOperation userOperation = session.getMapper(IUserOperation.class);<br>            List<article> articles = userOperation.getUserArticles(userid);<br>            for (Article article : articles) {<br>                System.out.println(article.getTitle()+”:”+article.getContent()+”:”+article.getUser().getUserName()+”:”<br>                        +article.getUser().getUserAddress());<br>            }<br>        } catch (Exception e) {<br>        } finally{<br>            session.close();<br>        }<br>    }</article></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常见的网络攻击原理分析]]></title>
      <url>http://yoursite.com/2016/06/09/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>常见网络攻击手段原理分析</p>
<h3 id="TCP-SYN拒绝服务攻击"><a href="#TCP-SYN拒绝服务攻击" class="headerlink" title="TCP SYN拒绝服务攻击"></a>TCP SYN拒绝服务攻击</h3><p>一般情况下，一个TCP连接的建立需要经过三次握手的过程，即：<br>1、 建立发起者向目标计算机发送一个TCP SYN报文；<br>2、 目标计算机收到这个SYN报文后，在内存中创建TCP连接控制块（TCB），然后向发起者回送一个TCP ACK报文，等待发起者的回应；<br>3、 发起者收到TCP ACK报文后，再回应一个ACK报文，这样TCP连接就建立起来了。<br>利用这个过程，一些恶意的攻击者可以进行所谓的TCP SYN拒绝服务攻击：<br>1、 攻击者向目标计算机发送一个TCP SYN报文；<br>2、 目标计算机收到这个报文后，建立TCP连接控制结构（TCB），并回应一个ACK，等待发起者的回应；<br>3、 而发起者则不向目标计算机回应ACK报文，这样导致目标计算机一致处于等待状态。<br>可以看出，目标计算机如果接收到大量的TCP SYN报文，而没有收到发起者的第三次ACK回应，会一直等待，处于这样尴尬状态的半连接如果很多，则会把目标计算机的资源（TCB控制结构，TCB，一般情况下是有限的）耗尽，而不能响应正常的TCP连接请求。</p>
<h3 id="ICMP洪水"><a href="#ICMP洪水" class="headerlink" title="ICMP洪水"></a>ICMP洪水</h3><p>正常情况下，为了对网络进行诊断，一些诊断程序，比如PING等，会发出ICMP响应请求报文（ICMP ECHO），接收计算机接收到ICMP ECHO后，会回应一个ICMP ECHO Reply报文。而这个过程是需要CPU处理的，有的情况下还可能消耗掉大量的资源，比如处理分片的时候。这样如果攻击者向目标计算机发送大量的ICMP ECHO报文（产生ICMP洪水），则目标计算机会忙于处理这些ECHO报文，而无法继续处理其它的网络数据报文，这也是一种拒绝服务攻击（DOS）。</p>
<h3 id="UDP洪水"><a href="#UDP洪水" class="headerlink" title="UDP洪水"></a>UDP洪水</h3><p>原理与ICMP洪水类似，攻击者通过发送大量的UDP报文给目标计算机，导致目标计算机忙于处理这些UDP报文而无法继续处理正常的报文。</p>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>根据TCP协议规范，当一台计算机收到一个TCP连接建立请求报文（TCP SYN）的时候，做这样的处理：<br>1、 如果请求的TCP端口是开放的，则回应一个TCP ACK报文，并建立TCP连接控制结构（TCB）；<br>2、 如果请求的TCP端口没有开放，则回应一个TCP RST（TCP头部中的RST标志设为1）报文，告诉发起计算机，该端口没有开放。</p>
<p>相应地，如果IP协议栈收到一个UDP报文，做如下处理：<br>1、 如果该报文的目标端口开放，则把该UDP报文送上层协议（UDP）处理，不回应任何报文（上层协议根据处理结果而回应的报文例外）；<br>2、 如果该报文的目标端口没有开放，则向发起者回应一个ICMP不可达报文，告诉发起者计算机该UDP报文的端口不可达。</p>
<p>利用这个原理，攻击者计算机便可以通过发送合适的报文，判断目标计算机哪些TCP或UDP端口是开放的，过程如下：<br>1、 发出端口号从0开始依次递增的TCP SYN或UDP报文（端口号是一个16比特的数字，这样最大为65535，数量很有限）；<br>2、 如果收到了针对这个TCP报文的RST报文，或针对这个UDP报文的ICMP不可达报文，则说明这个端口没有开放；<br>3、 相反，如果收到了针对这个TCP SYN报文的ACK报文，或者没有接收到任何针对该UDP报文的ICMP报文，则说明该TCP端口是开放的，UDP端口可能开放（因为有的实现中可能不回应ICMP不可达报文，即使该UDP端口没有开放）。</p>
<p>这样继续下去，便可以很容易的判断出目标计算机开放了哪些TCP或UDP端口，然后针对端口的具体数字，进行下一步攻击，这就是所谓的端口扫描攻击。</p>
<h3 id="分片IP报文攻击"><a href="#分片IP报文攻击" class="headerlink" title="分片IP报文攻击"></a>分片IP报文攻击</h3><p>为了传送一个大的IP报文，IP协议栈需要根据链路接口的MTU对该IP报文进行分片，通过填充适当的IP头中的分片指示字段，接收计算机可以很容易的把这些IP分片报文组装起来。<br>目标计算机在处理这些分片报文的时候，会把先到的分片报文缓存起来，然后一直等待后续的分片报文，这个过程会消耗掉一部分内存，以及一些IP协议栈的数据结构。如果攻击者给目标计算机只发送一片分片报文，而不发送所有的分片报文，这样攻击者计算机便会一直等待（直到一个内部计时器到时），如果攻击者发送了大量的分片报文，就会消耗掉目标计算机的资源，而导致不能相应正常的IP报文，这也是一种DOS攻击。</p>
<h3 id="SYN比特和FIN比特同时设置"><a href="#SYN比特和FIN比特同时设置" class="headerlink" title="SYN比特和FIN比特同时设置"></a>SYN比特和FIN比特同时设置</h3><p>在TCP报文的报头中，有几个标志字段：<br>1、 SYN：连接建立标志，TCP SYN报文就是把这个标志设置为1，来请求建立连接；<br>2、 ACK：回应标志，在一个TCP连接中，除了第一个报文（TCP SYN）外，所有报文都设置该字段，作为对上一个报文的相应；<br>3、 FIN：结束标志，当一台计算机接收到一个设置了FIN标志的TCP报文后，会拆除这个TCP连接；<br>4、 RST：复位标志，当IP协议栈接收到一个目标端口不存在的TCP报文的时候，会回应一个RST标志设置的报文；<br>5、 PSH：通知协议栈尽快把TCP数据提交给上层程序处理。</p>
<p>正常情况下，SYN标志（连接请求标志）和FIN标志（连接拆除标志）是不能同时出现在一个TCP报文中的。而且RFC也没有规定IP协议栈如何处理这样的畸形报文，因此，各个操作系统的协议栈在收到这样的报文后的处理方式也不同，攻击者就可以利用这个特征，通过发送SYN和FIN同时设置的报文，来判断操作系统的类型，然后针对该操作系统，进行进一步的攻击。</p>
<h3 id="没有设置任何标志的TCP报文攻击"><a href="#没有设置任何标志的TCP报文攻击" class="headerlink" title="没有设置任何标志的TCP报文攻击"></a>没有设置任何标志的TCP报文攻击</h3><p>正常情况下，任何TCP报文都会设置SYN，FIN，ACK，RST，PSH五个标志中的至少一个标志，第一个TCP报文（TCP连接请求报文）设置SYN标志，后续报文都设置ACK标志。有的协议栈基于这样的假设，没有针对不设置任何标志的TCP报文的处理过程，因此，这样的协议栈如果收到了这样的报文，可能会崩溃。攻击者利用了这个特点，对目标计算机进行攻击。</p>
<h3 id="设置了FIN标志却没有设置ACK标志的TCP报文攻击"><a href="#设置了FIN标志却没有设置ACK标志的TCP报文攻击" class="headerlink" title="设置了FIN标志却没有设置ACK标志的TCP报文攻击"></a>设置了FIN标志却没有设置ACK标志的TCP报文攻击</h3><p>正常情况下，ACK标志在除了第一个报文（SYN报文）外，所有的报文都设置，包括TCP连接拆除报文（FIN标志设置的报文）。但有的攻击者却可能向目标计算机发送设置了FIN标志却没有设置ACK标志的TCP报文，这样可能导致目标计算机崩溃。</p>
<h3 id="死亡之PING"><a href="#死亡之PING" class="headerlink" title="死亡之PING"></a>死亡之PING</h3><p>TCP/IP规范要求IP报文的长度在一定范围内（比如，0－64K），但有的攻击计算机可能向目标计算机发出大于64K长度的PING报文，导致目标计算机IP协议栈崩溃。</p>
<h3 id="地址猜测攻击"><a href="#地址猜测攻击" class="headerlink" title="地址猜测攻击"></a>地址猜测攻击</h3><p>跟端口扫描攻击类似，攻击者通过发送目标地址变化的大量的ICMP ECHO报文，来判断目标计算机是否存在。如果收到了对应的ECMP ECHO REPLY报文，则说明目标计算机是存在的，便可以针对该计算机进行下一步的攻击。<br>[page]</p>
<h3 id="泪滴攻击"><a href="#泪滴攻击" class="headerlink" title="泪滴攻击"></a>泪滴攻击</h3><p>对于一些大的IP包，需要对其进行分片传送，这是为了迎合链路层的MTU（最大传输单元）的要求。比如，一个4500字节的IP包，在MTU为1500的链路上传输的时候，就需要分成三个IP包。<br>在IP报头中有一个偏移字段和一个分片标志（MF），如果MF标志设置为1，则表面这个IP包是一个大IP包的片断，其中偏移字段指出了这个片断在整个IP包中的位置。例如，对一个4500字节的IP包进行分片（MTU为1500），则三个片断中偏移字段的值依次为：0，1500，3000。这样接收端就可以根据这些信息成功的组装该IP包。<br>如果一个攻击者打破这种正常情况，把偏移字段设置成不正确的值，即可能出现重合或断开的情况，就可能导致目标操作系统崩溃。比如，把上述偏移设置为0，1300，3000。这就是所谓的泪滴攻击。</p>
<h3 id="带源路由选项的IP报文"><a href="#带源路由选项的IP报文" class="headerlink" title="带源路由选项的IP报文"></a>带源路由选项的IP报文</h3><p>为了实现一些附加功能，IP协议规范在IP报头中增加了选项字段，这个字段可以有选择的携带一些数据，以指明中间设备（路由器）或最终目标计算机对这些IP报文进行额外的处理。<br>源路由选项便是其中一个，从名字中就可以看出，源路由选项的目的，是指导中间设备（路由器）如何转发该数据报文的，即明确指明了报文的传输路径。比如，让一个IP报文明确的经过三台路由器R1，R2，R3，则可以在源路由选项中明确指明这三个路由器的接口地址，这样不论三台路由器上的路由表如何，这个IP报文就会依次经过R1，R2，R3。而且这些带源路由选项的IP报文在传输的过程中，其源地址不断改变，目标地址也不断改变，因此，通过合适的设置源路由选项，攻击者便可以伪造一些合法的IP地址，而蒙混进入网络。</p>
<h3 id="带记录路由选项的IP报文"><a href="#带记录路由选项的IP报文" class="headerlink" title="带记录路由选项的IP报文"></a>带记录路由选项的IP报文</h3><p>记录路由选项也是一个IP选项，携带了该选项的IP报文，每经过一台路由器，该路由器便把自己的接口地址填在选项字段里面。这样这些报文在到达目的地的时候，选项数据里面便记录了该报文经过的整个路径。<br>通过这样的报文可以很容易的判断该报文经过的路径，从而使攻击者可以很容易的寻找其中的攻击弱点。</p>
<h3 id="未知协议字段的IP报文"><a href="#未知协议字段的IP报文" class="headerlink" title="未知协议字段的IP报文"></a>未知协议字段的IP报文</h3><p>在IP报文头中，有一个协议字段，这个字段指明了该IP报文承载了何种协议 ，比如，如果该字段值为1，则表明该IP报文承载了ICMP报文，如果为6，则是TCP，等等。目前情况下，已经分配的该字段的值都是小于100的，因此，一个带大于100的协议字段的IP报文，可能就是不合法的，这样的报文可能对一些计算机操作系统的协议栈进行破坏。</p>
<h3 id="IP地址欺骗"><a href="#IP地址欺骗" class="headerlink" title="IP地址欺骗"></a>IP地址欺骗</h3><p>一般情况下，路由器在转发报文的时候，只根据报文的目的地址查路由表，而不管报文的源地址是什么，因此，这样就 可能面临一种危险：如果一个攻击者向一台目标计算机发出一个报文，而把报文的源地址填写为第三方的一个IP地址，这样这个报文在到达目标计算机后，目标计算机便可能向毫无知觉的第三方计算机回应。这便是所谓的IP地址欺骗攻击。<br>比较著名的SQL Server蠕虫病毒，就是采用了这种原理。该病毒（可以理解为一个攻击者）向一台运行SQL Server解析服务的服务器发送一个解析服务的UDP报文，该报文的源地址填写为另外一台运行SQL Server解析程序（SQL Server 2000以后版本）的服务器，这样由于SQL Server 解析服务的一个漏洞，就可能使得该UDP报文在这两台服务器之间往复，最终导致服务器或网络瘫痪。</p>
<h3 id="WinNuke攻击"><a href="#WinNuke攻击" class="headerlink" title="WinNuke攻击"></a>WinNuke攻击</h3><p>NetBIOS作为一种基本的网络资源访问接口，广泛的应用于文件共享，打印共享，进程间通信（IPC），以及不同操作系统之间的数据交换。一般情况下，NetBIOS是运行在LLC2链路协议之上的，是一种基于组播的网络访问接口。为了在TCP/IP协议栈上实现NetBIOS，RFC规定了一系列交互标准，以及几个常用的TCP/UDP端口：<br>139：NetBIOS会话服务的TCP端口；<br>137：NetBIOS名字服务的UDP端口；<br>136：NetBIOS数据报服务的UDP端口。<br>WINDOWS操作系统的早期版本（WIN95/98/NT）的网络服务（文件共享等）都是建立在NetBIOS之上的，因此，这些操作系统都开放了139端口（最新版本的WINDOWS 2000/XP/2003等，为了兼容，也实现了NetBIOS over TCP/IP功能，开放了139端口）。<br>WinNuke攻击就是利用了WINDOWS操作系统的一个漏洞，向这个139端口发送一些携带TCP带外（OOB）数据报文，但这些攻击报文与正常携带OOB数据报文不同的是，其指针字段与数据的实际位置不符，即存在重合，这样WINDOWS操作系统在处理这些数据的时候，就会崩溃。</p>
<h3 id="Land攻击"><a href="#Land攻击" class="headerlink" title="Land攻击"></a>Land攻击</h3><p>LAND攻击利用了TCP连接建立的三次握手过程，通过向一个目标计算机发送一个TCP SYN报文（连接建立请求报文）而完成对目标计算机的攻击。与正常的TCP SYN报文不同的是，LAND攻击报文的源IP地址和目的IP地址是相同的，都是目标计算机的IP地址。这样目标计算机接收到这个SYN报文后，就会向该报文的源地址发送一个ACK报文，并建立一个TCP连接控制结构（TCB），而该报文的源地址就是自己，因此，这个ACK报文就发给了自己。这样如果攻击者发送了足够多的SYN报文，则目标计算机的TCB可能会耗尽，最终不能正常服务。这也是一种DOS攻击。</p>
<h3 id="Script-ActiveX攻击"><a href="#Script-ActiveX攻击" class="headerlink" title="Script/ActiveX攻击"></a>Script/ActiveX攻击</h3><p>Script是一种可执行的脚本，它一般由一些脚本语言写成，比如常见的JAVA SCRIPT，VB SCRIPT等。这些脚本在执行的时候，需要一个专门的解释器来翻译，翻译成计算机指令后，在本地计算机上运行。这种脚本的好处是，可以通过少量的程序写作，而完成大量的功能。<br>这种SCRIPT的一个重要应用就是嵌入在WEB页面里面，执行一些静态WEB页面标记语言（HTML）无法完成的功能，比如本地计算，数据库查询和修改，以及系统信息的提取等。这些脚本在带来方便和强大功能的同时，也为攻击者提供了方便的攻击途径。如果攻击者写一些对系统有破坏的SCRIPT，然后嵌入在WEB页面中，一旦这些页面被下载到本地，计算机便以当前用户的权限执行这些脚本，这样，当前用户所具有的任何权限，SCRIPT都可以使用，可以想象这些恶意的SCRIPT的破坏程度有多强。这就是所谓的SCRIPT攻击。<br>ActiveX是一种控件对象，它是建立在MICROSOFT的组件对象模型（COM）之上的，而COM则几乎是Windows操作系统的基础结构。可以简单的理解，这些控件对象是由方法和属性构成的，方法即一些操作，而属性则是一些特定的数据。这种控件对象可以被应用程序加载，然后访问其中的方法或属性，以完成一些特定的功能。可以说，COM提供了一种二进制的兼容模型（所谓二进制兼容，指的是程序模块与调用的编译环境，甚至操作系统没有关系）。但需要注意的是，这种对象控件不能自己执行，因为它没有自己的进程空间，而只能由其它进程加载，并调用其中的方法和属性，这时候，这些控件便在加载进程的进程空间运行，类似与操作系统的可加载模块，比如DLL库。<br>ActiveX控件可以嵌入在WEB页面里面，当浏览器下载这些页面到本地后，相应地也下载了嵌入在其中的ActiveX控件，这样这些控件便可以在本地浏览器进程空间中运行（ActiveX空间没有自己的进程空间，只能由其它进程加载并调用），因此，当前用户的权限有多大，ActiveX的破坏性便有多大。如果一个恶意的攻击者编写一个含有恶意代码的ActiveX控件，然后嵌入在WEB页面中，被一个浏览用户下载后执行，其破坏作用是非常大的。这便是所谓的ActiveX攻击。</p>
<h3 id="Smurf攻击"><a href="#Smurf攻击" class="headerlink" title="Smurf攻击"></a>Smurf攻击</h3><p>ICMP ECHO请求包用来对网络进行诊断，当一台计算机接收到这样一个报文后，会向报文的源地址回应一个ICMP ECHO REPLY。一般情况下，计算机是不检查该ECHO请求的源地址的，因此，如果一个恶意的攻击者把ECHO的源地址设置为一个广播地址，这样计算机在恢复REPLY的时候，就会以广播地址为目的地址，这样本地网络上所有的计算机都必须处理这些广播报文。如果攻击者发送的ECHO 请求报文足够多，产生的REPLY广播报文就可能把整个网络淹没。这就是所谓的smurf攻击。<br>除了把ECHO报文的源地址设置为广播地址外，攻击者还可能把源地址设置为一个子网广播地址，这样，该子网所在的计算机就可能受影响。</p>
<h3 id="虚拟终端（VTY）耗尽攻击"><a href="#虚拟终端（VTY）耗尽攻击" class="headerlink" title="虚拟终端（VTY）耗尽攻击"></a>虚拟终端（VTY）耗尽攻击</h3><p>这是一种针对网络设备的攻击，比如路由器，交换机等。这些网络设备为了便于远程管理，一般设置了一些TELNET用户界面，即用户可以通过TELNET到该设备上，对这些设备进行管理。<br>一般情况下，这些设备的TELNET用户界面个数是有限制的，比如，5个或10个等。这样，如果一个攻击者同时同一台网络设备建立了5个或10个TELNET连接，这些设备的远程管理界面便被占尽，这样合法用户如果再对这些设备进行远程管理，则会因为TELNET连接资源被占用而失败。</p>
<h3 id="路由协议攻击"><a href="#路由协议攻击" class="headerlink" title="路由协议攻击"></a>路由协议攻击</h3><p>网络设备之间为了交换路由信息，常常运行一些动态的路由协议，这些路由协议可以完成诸如路由表的建立，路由信息的分发等功能。常见的路由协议有RIP，OSPF，IS-IS，BGP等。这些路由协议在方便路由信息管理和传递的同时，也存在一些缺陷，如果攻击者利用了路由协议的这些权限，对网络进行攻击，可能造成网络设备路由表紊乱（这足可以导致网络中断），网络设备资源大量消耗，甚至导致网络设备瘫痪。<br>下面列举一些常见路由协议的攻击方式及原理：</p>
<ul>
<li><p>针对RIP协议的攻击<br>RIP，即路由信息协议，是通过周期性（一般情况下为30S）的路由更新报文来维护路由表的，一台运行RIP路由协议的路由器，如果从一个接口上接收到了一个路由更新报文，它就会分析其中包含的路由信息，并与自己的路由表作出比较，如果该路由器认为这些路由信息比自己所掌握的要有效，它便把这些路由信息引入自己的路由表中。<br>这样如果一个攻击者向一台运行RIP协议的路由器发送了人为构造的带破坏性的路由更新报文，就很容易的把路由器的路由表搞紊乱，从而导致网络中断。<br>如果运行RIP路由协议的路由器启用了路由更新信息的HMAC验证，则可从很大程度上避免这种攻击。</p>
</li>
<li><p>针对OSPF路由协议的攻击<br>OSPF，即开放最短路径优先，是一种应用广泛的链路状态路由协议。该路由协议基于链路状态算法，具有收敛速度快，平稳，杜绝环路等优点，十分适合大型的计算机网络使用。OSPF路由协议通过建立邻接关系，来交换路由器的本地链路信息，然后形成一个整网的链路状态数据库，针对该数据库，路由器就可以很容易的计算出路由表。<br>可以看出，如果一个攻击者冒充一台合法路由器与网络中的一台路由器建立邻接关系，并向攻击路由器输入大量的链路状态广播（LSA，组成链路状态数据库的数据单元），就会引导路由器形成错误的网络拓扑结构，从而导致整个网络的路由表紊乱，导致整个网络瘫痪。<br>当前版本的WINDOWS 操作系统（WIN 2K/XP等）都实现了OSPF路由协议功能，因此一个攻击者可以很容易的利用这些操作系统自带的路由功能模块进行攻击。<br>跟RIP类似，如果OSPF启用了报文验证功能（HMAC验证），则可以从很大程度上避免这种攻击。</p>
</li>
<li>针对IS-IS路由协议的攻击<br>IS-IS路由协议，即中间系统到中间系统，是ISO提出来对ISO的CLNS网络服务进行路由的一种协议，这种协议也是基于链路状态的，原理与OSPF类似。IS-IS路由协议经过 扩展，可以运行在IP网络中，对IP报文进行选路。这种路由协议也是通过建立邻居关系，收集路由器本地链路状态的手段来完成链路状态数据库同步的。该协议的邻居关系建立比OSPF简单，而且也省略了OSPF特有的一些特性，使该协议简单明了，伸缩性更强。<br>对该协议的攻击与OSPF类似，通过一种模拟软件与运行该协议的路由器建立邻居关系，然后传颂给攻击路由器大量的链路状态数据单元（LSP），可以导致整个网络路由器的链路状态数据库不一致（因为整个网络中所有路由器的链路状态数据库都需要同步到相同的状态），从而导致路由表与实际情况不符，致使网络中断。<br>与OSPF类似，如果运行该路由协议的路由器启用了IS-IS协议单元（PDU）HMAC验证功能，则可以从很大程度上避免这种攻击。</li>
</ul>
<h3 id="针对设备转发表的攻击"><a href="#针对设备转发表的攻击" class="headerlink" title="针对设备转发表的攻击"></a>针对设备转发表的攻击</h3><ul>
<li>为了合理有限的转发数据，网络设备上一般都建立一些寄存器表项，比如MAC地址表，ARP表，路由表，快速转发表，以及一些基于更多报文头字段的表格，比如多层交换表，流项目表等。这些表结构都存储在设备本地的内存中，或者芯片的片上内存中，数量有限。如果一个攻击者通过发送合适的数据报，促使设备建立大量的此类表格，就会使设备的存储结构消耗尽，从而不能正常的转发数据或崩溃。<br>下面针对几种常见的表项，介绍其攻击原理：</li>
<li>针对MAC地址表的攻击<br>MAC地址表一般存在于以太网交换机上，以太网通过分析接收到的数据幀的目的MAC地址，来查本地的MAC地址表，然后作出合适的转发决定。<br>这些MAC地址表一般是通过学习获取的，交换机在接收到一个数据幀后，有一个学习的过程，该过程是这样的：<br>a) 提取数据幀的源MAC地址和接收到该数据幀的端口号；<br>b) 查MAC地址表，看该MAC地址是否存在，以及对应的端口是否符合；<br>c) 如果该MAC地址在本地MAC地址表中不存在，则创建一个MAC地址表项；<br>d) 如果存在，但对应的出端口跟接收到该数据幀的端口不符，则更新该表；<br>e) 如果存在，且端口符合，则进行下一步处理。</li>
</ul>
<p>分析这个过程可以看出，如果一个攻击者向一台交换机发送大量源MAC地址不同的数据幀，则该交换机就可能把自己本地的MAC地址表学满。一旦MAC地址表溢出，则交换机就不能继续学习正确的MAC表项，结果是可能产生大量的网络冗余数据，甚至可能使交换机崩溃。<br>而构造一些源MAC地址不同的数据幀，是非常容易的事情。</p>
<ul>
<li>针对ARP表的攻击<br>ARP表是IP地址和MAC地址的映射关系表，任何实现了IP协议栈的设备，一般情况下都通过该表维护IP地址和MAC地址的对应关系，这是为了避免ARP解析而造成的广播数据报文对网络造成冲击。ARP表的建立一般情况下是通过二个途径：<br>1、 主动解析，如果一台计算机想与另外一台不知道MAC地址的计算机通信，则该计算机主动发ARP请求，通过ARP协议建立（前提是这两台计算机位于同一个IP子网上）；<br>2、 被动请求，如果一台计算机接收到了一台计算机的ARP请求，则首先在本地建立请求计算机的IP地址和MAC地址的对应表。</li>
</ul>
<p>因此，如果一个攻击者通过变换不同的IP地址和MAC地址，向同一台设备，比如三层交换机发送大量的ARP请求，则被攻击设备可能会因为ARP缓存溢出而崩溃。<br>针对ARP表项，还有一个可能的攻击就是误导计算机建立正确的ARP表。根据ARP协议，如果一台计算机接收到了一个ARP请求报文，在满足下列两个条件的情况下，该计算机会用ARP请求报文中的源IP地址和源MAC地址更新自己的ARP缓存：<br>1、 如果发起该ARP请求的IP地址在自己本地的ARP缓存中；<br>2、 请求的目标IP地址不是自己的。</p>
<p>可以举一个例子说明这个过程，假设有三台计算机A，B，C，其中B已经正确建立了A和C计算机的ARP表项。假设A是攻击者，此时，A发出一个ARP请求报文，该请求报文这样构造：<br>1、 源IP地址是C的IP地址，源MAC地址是A的MAC地址；<br>2、 请求的目标IP地址是A的IP地址。</p>
<p>这样计算机B在收到这个ARP请求报文后（ARP请求是广播报文，网络上所有设备都能收到），发现B的ARP表项已经在自己的缓存中，但MAC地址与收到的请求的源MAC地址不符，于是根据ARP协议，使用ARP请求的源MAC地址（即A的MAC地址）更新自己的ARP表。<br>这样B的ARP混存中就存在这样的错误ARP表项：C的IP地址跟A的MAC地址对应。这样的结果是，B发给C的数据都被计算机A接收到。</p>
<ul>
<li>针对流项目表的攻击<br>有的网络设备为了加快转发效率，建立了所谓的流缓存。所谓流，可以理解为一台计算机的一个进程到另外一台计算机的一个进程之间的数据流。如果表现在TCP/IP协议上，则是由（源IP地址，目的IP地址，协议号，源端口号，目的端口号）五元组共同确定的所有数据报文。<br>一个流缓存表一般由该五元组为索引，每当设备接收到一个IP报文后，会首先分析IP报头，把对应的五元组数据提取出来，进行一个HASH运算，然后根据运算结果查询流缓存，如果查找成功，则根据查找的结果进行处理，如果查找失败，则新建一个流缓存项，查路由表，根据路由表查询结果填完整这个流缓存，然后对数据报文进行转发（具体转发是在流项目创建前还是创建后并不重要）。<br>可以看出，如果一个攻击者发出大量的源IP地址或者目的IP地址变化的数据报文，就可能导致设备创建大量的流项目，因为不同的源IP地址和不同的目标IP地址对应不同的流。这样可能导致流缓存溢出。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[springMVC学习笔记]]></title>
      <url>http://yoursite.com/2016/06/09/springMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>SpringMVC 使用@RequestMapping 注解为控制器指定可以处理哪些URL请求<br>在控制器的类定义及方法定义处都可标注<br>@RequestMapping<br>类定义处： 提供初步的请求映射信息，相对于WEB应用的根目录<br>方法处：提供进一步的细分映射信息。相对于类定义处的URL。若类定义处未标注@RequestMapping，则方法标记的URL相对于WEB应用的根目录<br>DispatcherServlet 截获请求后，就通过控制器上@RequestMapping 提供的映射信息确定请求所对应的处理方法</p>
<p>eg<br>    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"><br>        <property name="prefix" value="/WEB-INF/views/"></property><br>        <property name="suffix" value=".jsp"></property><br>    </bean></p>
<p><a href="springmvc/testRequestMapping">test requestMapping </a></p>
<p>// 类定义处标记的@RequestMapping限定了处理器可以处理所有URI为 /spring的请求，它相对于WEB容器部署的根路径<br>@RequestMapping(“/springmvc”)<br>@Controller<br>public class SpringMVCTest {<br>    private static final String SUCCESS = “success”;<br>    // 处理器类可以定义多个处理方法，处理来自 /springmvc的请求<br>    @RequestMapping(“/testRequestMapping”)<br>    public String testRequestMapping(){<br>        System.out.println(“testRequest…”);<br>        return SUCCESS;<br>    }<br>}</p>
<pre><code>&lt;a href=&quot;springmvc/testRequestMethod&quot;&gt;test requestMethod &lt;/a&gt;

&lt;br&gt;
&lt;a href=&quot;springmvc/testParamsAndHeaders?username=atguigu&amp;age=10&quot;&gt;test ParamsAndHeaders &lt;/a&gt;
&lt;br&gt;

&lt;a href=&quot;springmvc/test/mnxyv/abc&quot;&gt;test AntPath &lt;/a&gt;
&lt;br&gt;

&lt;a href=&quot;springmvc/testParamsAndHeaders?username=atguigu&amp;age=10&quot;&gt;test ParamsAndHeaders &lt;/a&gt;
&lt;br&gt;

&lt;form action=&quot;springmvc/testRequestMethod&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;br&gt;
&lt;a href=&quot;springmvc/testRequestMapping&quot;&gt;test requestMapping &lt;/a&gt;
&lt;br&gt;
&lt;a href=&quot;helloworld&quot;&gt;HelloWorld&lt;/a&gt;
</code></pre><p>@Controller<br>public class HelloWorld {<br>    /**</p>
<pre><code> * 1. 使用 @RequestMapping 注解来映射请求的url
 * 2. 返回值会通过视图解析器解析为实际的物理视图
 * 对于InternalResourceViewResolver视图解析器，做如下解析
 * prefix+returnVal+suffix 这样的方式得到实际的物理视图
 */
@RequestMapping(&quot;/helloworld&quot;)
public String hello() {
    System.out.println(&quot;hello world&quot;);
    return &quot;success&quot;;
}
</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>RequestMapping 除了可以使用请求URL映射请求外，还可以使用请求方法，请求参数及请求头映射请求<br>RequestMapping 的value,method,params及headers分别表示请求URL，请求方法、请求参数及请求头的映射条件，他们之间是与的关系，联合使用多个条件可以让请求映射更加精确<br>params和headers支持简单的表达式：<br>param1: 表示请求必须包含名为param1的请求参数<br>!param1: 表示请求不能包含名为param1的请求参数<br>param1!=value1: 表示请求必须包含名为param1的请求参数，值不能为value1<br>{“param1=value”,”param2”} : 表示必须包含param1和param2，且param1的参数值必须为value</p>
<p>@RequestMapping(“/springmvc”)<br>@Controller<br>public class SpringMVCTest {<br>    private static final String SUCCESS = “success”;<br>    // 指定接收POST的请求，页面可以设置为form表单<br>    @RequestMapping(value=”/testRequestMethod”,method=RequestMethod.POST)<br>    public String testRequestMethod(){<br>        System.out.println(“testRequestMethod…”);<br>        return SUCCESS;<br>    }<br>    // 必须包含username属性和age属性，且age不能为1，否则不予接收<br>    @RequestMapping(value=”testParamsAndHeaders”,params={“username”,”age!=1”})<br>    public String testParams(){<br>        System.out.println(“testParamsAndHeaders…”);<br>        return SUCCESS;<br>    }<br>    // 支持匹配符<br>    // ? 匹配文件名中的一个字符<br>    // <em> 匹配文件名中的任意字符<br>    // ** 匹配多层路径<br>    // 还支持Ant风格的URL<br>    @RequestMapping(“/test/</em>/abc”)<br>    public String testRequestMapping(){<br>        System.out.println(“testRequest…”);<br>        return SUCCESS;<br>    }<br>}</p>
<p>@PathVariable 映射URL绑定的占位符<br>带占位符的URL是SpringMVC向REST目标挺进发展具有里程碑的意义<br>通过@PathVariable 可以将URL中占位符参数绑定到控制器处理方法的入参中；URL 中的{xxx}占位符可以通过@PathVariable(“xxx”)绑定到操作方法的入参中<br>eg : <a href="springmvc/testPathVariable/1">test requestMapping </a></p>
<p>// @PathVariable 可以映射URL中的占位符到目标方法的参数中 - REST风格<br>    @RequestMapping(“/testPathVariable/{id}”)<br>    public String testPathVariable(@PathVariable(“id”) Integer id){<br>        System.out.println(“testPathVariable “+id);<br>        return SUCCESS;<br>    }</p>
<p>REST Representational State Transfer 资源表现层状态转化<br>具体的说就是HTTP协议里面，GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源</p>
<p>form表单只支持GET与POST请求，Spring 使用 HiddenHttpMethodFilter 把这些请求转换为标准的http方法，使得支持GET,POST,PUT 与DELETE请求<br>把 HiddenHttpMethodFilter 配置到web.xml中，可以把post请求转为delete或post请求</p>
<ol>
<li>配置HiddenHttpMethodFilter</li>
<li>发送post请求时，携带一个name=”_method”的隐藏域，值为delete或put</li>
</ol>
<p>Rest 风格</p>
<form action="springmvc/testRest/1" method="post"><br>    <input type="hidden" name="_method" value="PUT"><br>    <input type="submit" value="PUT"><br></form>

<p><br></p>
<form action="springmvc/testRest/1" method="post"><br>    <input type="hidden" name="_method" value="Delete"><br>    <input type="submit" value="test delete"><br></form><br><br><br><br>@RequestMapping(value=”/testRest/{id}”, method=RequestMethod.PUT)<br>    public String testRestPut(@PathVariable Integer id){<br>        System.out.println(“Put: “+id);<br>        return SUCCESS;<br>    }<br><br>    @RequestMapping(value=”/testRest/{id}”, method=RequestMethod.DELETE)<br>    public String testRestDelete(@PathVariable Integer id){<br>        System.out.println(“Delete: “+id);<br>        return SUCCESS;<br>    }<br><br>web.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">  	&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</div><div class="line">  	// 配置HiddenHttpMethodFilter 可以把POST请求转换为DELETE或POST请求</div><div class="line">  	&lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;</div><div class="line">  &lt;/filter&gt;</div><div class="line">  &lt;filter-mapping&gt;</div><div class="line">  	&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</div><div class="line">  	&lt;url-pattern&gt;&apos;/*&apos;&lt;/url-pattern&gt;</div><div class="line">  &lt;/filter-mapping&gt;</div><div class="line"></div><div class="line">  &lt;servlet&gt;</div><div class="line">    &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;</div><div class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</div><div class="line">  &lt;/servlet&gt;</div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure><br><br>在springMVC中得到id,使用 @PathVariable 注解<br><br>Spring MVC 通过分析处理方法的签名，将HTTP请求信息绑定到处理方法的相应入参中。<br>必要时可以对方法及方法入参标注相应的注解(@PathVariable,@RequestParam,@RequestHeader 等)，Spring MVC 框架会将HTTP请求的信息绑定到相应的方法入参中，并根据方法的返回值类型做出相应的后续处理<br><br>eg:<br><a href="springmvc/testRequestParam?username=haha&age=10">Test RequestParam</a><br>/<em>*
 </em> [testRequestParam description]<br> <em> @RequestParam 映射请求参数
 </em>  value 值即请求参数的参数名<br> <em>  required 该参数是否必须，默认为true
 </em>   defaultValue 请求参数的默认值<br> */<br>@RequestMapping(value=”/testRequestParam”)<br>    public String testRequestParam(@RequestParam(value=”username”) String un,<br>            // (value=”age”, required=false, defaultValue=”0”) int age)<br>            @RequestParam(value=”age”, required=false) Integer age){   // 若某个值不是必须的，可以使用required=false注解<br>        System.out.println(“username =　“ + un + “; age = “+age);<br>        return SUCCESS;<br>    }<br>——————<br><a href="springmvc/testRequestHeader">Test RequestHeader</a><br><br>@RequestMapping(“/testRequestHeader”)<br>    public String testRequestHeader(@RequestHeader(value=”Accept-Language”) String al){<br>        System.out.println(“testRequestHeader,Accept-Language : “+al);<br>        return SUCCESS;<br>    }<br><br>———————-<br>使用 @CookieValue 取得Cookie值，映射一个Cookie值，属性同@RequestParam<br>@RequestMapping(“/testCookievalue”)<br>    public String testCookieValue(@CookieValue(“JSESSIONID”) String sessionId){<br>        System.out.println(“testCookieValue:sessionId “+sessionId);<br>        return SUCCESS;<br>    }<br><br>使用POJO对象绑定请求参数值<br>SpringMVC 会按请求参数名和POJO属性名进行自动匹配，自动为该对象填充属性值，支持级联属性，如dept.deptId, dept.address.tel 等<br><br><form action="springmvc/testPojo" method="post"><br>        username:<input type="text" name="username"><br>        <br><br>        password:<input type="password" name="password"><br>        <br><br>        email:<input type="text" name="email"><br>        <br><br>        age:<input type="text" name="age"><br>        <br><br>        city:<input type="text" name="address.city"><br>        <br><br>        province:<input type="text" name="address.province"><br>        <br><br><br>        <input type="submit" value="submit"><br>    </form>

<p>public class User {<br>    private String username;<br>    private String password;<br>    private String email;<br>    private int age;<br>    private Address address;<br>    getter…setter …<br>}<br>@RequestMapping(“/testPojo”)<br>    public String testPojo(User user){<br>        System.out.println(“testPojo “+user);<br>        return SUCCESS;<br>    }</p>
<p>MVC 的Handler方法可以接受哪些ServletAPI类型的参数<br>HttpServletRequest HttpServletResponse HttpSession java.security.Principal Locale InputStream OutputStream Reader Writer</p>
<p>Spring MVC 提供了一下几种途径输出模型数据：<br>ModelAndView：处理方法返回值类型为ModelAndView时，方法体即可通过该对象添加模型数据<br>Map 及 Model:入参为 org.springframework.ui.Model 、 org.springframework.ui.ModelMap 或 java.util.Map 时，处理方法返回时，Map 中的数据会自动添加到模型中<br>@SessionAttributes:将模型中的某个属性暂存到HttpSession中，以便多个请求之间可以共享这个属性<br>@ModelAttribute:方法入参标注该注解后，入参的对象就会放到数据模型中</p>
<p>控制器处理方法的返回值如果为ModelAndView，则其既包含视图信息，也包含模型数据信息<br>添加模型数据：<br>ModelAndView addObject(String attributeName,Object attributeValue)<br>ModelAndView addAllObject(Map<string,?> modelMap)<br>设置视图：<br>void setView(View view)<br>void setViewName(String viewName)</string,?></p>
<p>/**</p>
<ul>
<li>目标方法的返回值可以是ModelAndView类型</li>
<li>其中可以包含视图和模型信息</li>
<li>Spring MVC 会把ModelAndView的model中数据放入到request域对象中</li>
<li>@return [description]<br>*/<br>@RequestMapping(“/testModelAndView”)<br> public ModelAndView testModelAndView(){<pre><code>String viewName = SUCCESS;
ModelAndView modelAndView = new ModelAndView(viewName);
modelAndView.addObject(&quot;time&quot;,new Date());
return modelAndView;
</code></pre> }</li>
</ul>
<body><br>    <h4>Success Page</h4><br>    time: ${requestScope.time}<br></body>

<hr>
<p>@RequestMapping(“/testMap”)<br>    public String testMap(Map<string,object> map){<br>        map.put(“name”,Arrays.asList(“tom”,”jerry”,”Mike”));<br>        return SUCCESS;<br>    }</string,object></p>
<p>Name: ${requestScope.name } 取得map模型数据</p>
<hr>
<p>若希望在多个请求之间公用某个模型属性数据，可以在控制器上标注一个 @SessionAttributes，Spring MVC 将在模型中对应的属性暂存到 HttpSession 中的数据会自动添加到模型中<br>@SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外（使用value属性值），还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中（使用types属性值）。<strong> 注意：该注解只能放在类的上面不能放在方法上面 </strong><br>@SessionAttributes(type=User.class) 会将隐含模型中所有类型为User.class的属性添加到会话中<br>@SessionAttributes(value={“user1”,”user2”})<br>@SessionAttributes(types={User.class,Dept.class})<br>@SessionAttributes(value={“user1”,”user2”},types={Dept.class})</p>
<p>在已有基础上添加 @SessionAttributes({“user”})<br>@RequestMapping(“testSessionAttributes”)<br>    public String testSessionAttributes(Map<string,object> map){<br>        User user = new User(“Tom”, “123456”, “tom@gmail.com”, 16);<br>        map.put(“user”, user);<br>        return SUCCESS;<br>    }</string,object></p>
<p>requestUser : ${requestScope.user }<br>sessionUser:${sessionScope.user }</p>
<p>若注解改为  @SessionAttributes(value={“user”},types=String.class)  则<br>@RequestMapping(“testSessionAttributes”)<br>    public String testSessionAttributes(Map<string,object> map){<br>        User user = new User(“Tom”, “123456”, “tom@gmail.com”, 16);<br>        map.put(“user”, user);<br>        map.put(“school”,”atguigu”);<br>        return SUCCESS;<br>    }<br>    也会把school放入到request和session中</string,object></p>
<p>ModelAttribute<br>    &lt;!–</p>
<pre><code>    1. 原始数据  1,Tom,123456,tom@atguigu.com,12
    2. 密码不能修改
    3. 表单回显，模拟操作直接在表单填写对应的属性值
 --&gt;
&lt;form action=&quot;springmvc/testModelAttribute&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=1&gt;
    username:&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;Tom&quot;&gt;
    &lt;br&gt;
    email:&lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;tom@atguigu.com&quot;&gt;
    &lt;br&gt;
    age:&lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;12&quot;&gt;
    &lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
&lt;/form&gt;

/*
 * 有 @ModelAttribute标记的方法，会在每个目标方法执行之前被SpringMVC调用
 */
@ModelAttribute
public void getUser(@RequestParam(value=&quot;id&quot;,required=false) Integer id,
        Map&lt;String,Object&gt; map){
    if(id!=null){
        User user = new User(1,&quot;Tom&quot;,&quot;1256&quot;,&quot;tom@atguigu.com&quot;,12);
        System.out.println(&quot; 从数据库获取一个对象 &quot;+user);
        map.put(&quot;user&quot;,user);
    }
}
/*
 * 1. 执行@ModelAttribute注解修饰的方法，从数据库中取出对象，把对象放入到了Map中，键为 user
 * 2. SpringMVC 从Map中取出User对象，并把表单的请求参数赋给该User对象的对应属性
 * 3. SpringMVC 把上述对象传入目标方法的参数
 * 注意： 在ModelAttribute修饰的方法中，放入到Map时的键需要和目标方法入参类型的第一个字母小写的字符串一致，即必须是 user
 */
@RequestMapping(&quot;/testModelAttribute&quot;)
public String testModelAttribute(User user){
    System.out.println(&quot;modify &quot;+user);
    return SUCCESS;
}
</code></pre><p>可以用@ModelAttribute 注释方法参数或方法。带有@ModelAttribute 注解的方法会将其要输入的或创建的参数对象添加到Model对象中（若方法没有显示添加）<br>SpringMVC 确定目标方法POJO类型入参的过程</p>
<ol>
<li>确定一个key<br>1)若目标方法的POJO类型的参数木有使用@ModelAttribute 作为修饰，则key为POJO类型第一个字母的小写<br>2)若使用了@ModelAttribute 来修饰，则key为@ModelAttribute 注解的value属性值</li>
<li>在implicitModel 中查找key对应的对象，若存在，则作为入参传入<br>若在@ModelAttribute 标记的方法中在Map中保存过，则key和1确定的key一致，则会获取到<br>3.若implicitModel中不存在key对应的对象，则检查当前的Handler是否使用@SessionAttribute 注解修饰，若使用了该注解，且@SessionAttributes 注解的value属性值中包含了key，则会从HttpSession中来获取key所对应的value值，若存在则直接传入到目标方法的入参中，若不存在则将抛异常</li>
<li>若Handler没有标记@SessionAttributes 注解或@SessionAttributes 注解的value值不包含key，则会通过反射来创建POJO类型的参数，传入为目标方法的参数</li>
<li>SpringMVC 会把key和POJO类型的对象保存在impliciModel中，进而会保存到request中</li>
</ol>
<p>SpringMVC 视图解析流程分析<br>请求处理方法完成后，最终赶回一个ModelAndView对象，对于那些返回String,View 或ModelMap等类型的处理方法，Spring MVC 也会在内部将他们装配成一个ModelAndView对象，包含了逻辑名和模型对象的视图<br>Spring MVC 借助视图解析器（ViewResolver）得到最终的视图对象，最终的视图可以是JSP，也可能是Excel、JFreeChart 等各种表现形式的视图<br>视图的作用是渲染模型数据，将模型的数据以某种形式呈现给客户<br>为了实现视图模型和具体实现技术的解耦，Spring 在org.springframework.web.servlet 包中定义了一个高度抽象的View接口<br>视图对象由视图解析器负责实例化，由于视图是无状态的，所有他们不会有线程安全的问题</p>
<p>InternalResourceViewResolver JSP 是最常见的视图技术，可以使用InternalResourceViewResolver作为视图解析器<br>若项目中使用了JSTL，则SpringMVC会自动把视图</p>
<p><mvc:view-controller path="/success" view-name="success"></mvc:view-controller></p>
<p><mvc:annotation-driven></mvc:annotation-driven></p>
<p>若希望使用Excel展示数据列表，仅需要扩展SpringMVC提供的AbstractExcelView或AbstractJExcel View 即可。实现buildExcelDocument()方法，在方法中使用模型数据构建Excel文档就可以了<br>视图对象需要配置IOC容器中的一个bean，使用BeanNameViewResolver作为视图解析器即可<br>若希望直接在浏览器中直接下载Excel文档，则可以设置响应头 Content-Disposition 的值为attachment;filename=xxx.xls</p>
<p>自定义视图<br>配置xml<br><!-- 扫描包 --><br>    <context:component-scan base-package="com.atguigu.springmvc"></context:component-scan></p>
<pre><code>&lt;!-- 配置视图解析器，如何把handler方法返回值解析为实际的物理视图 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- 配置BeanNameViewResolver视图解析器;使用视图的名字来解析视图 --&gt;
&lt;!-- 通过order属性定义视图的优先级，order值越小视图解析器优先级越高。
InternalResourceViewResolver 优先级数值最大，所有优先级最低--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;&gt;
    &lt;property name=&quot;order&quot; value=&quot;100&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>@RequestMapping(“/testView”)<br>    public String testView(){<br>        System.out.println(“test view”);<br>        return “helloView”;<br>    }</p>
<p>@Component<br>public class HelloView implements View{</p>
<pre><code>@Override
public String getContentType() {
    return &quot;text/html&quot;;
}

@Override
public void render(Map&lt;String, ?&gt; arg0, HttpServletRequest request,
        HttpServletResponse response) throws Exception {
    response.getWriter().print(&quot;hello view time:&quot;+new Date());
}
</code></pre><p>}</p>
<p>重定向<br>@RequestMapping(“/testRedirect”)<br>    public String testRedirect(){<br>        System.out.println(“testRedirect”);<br>        return “redirect:/index.jsp”;  // 重定向到根目录的页面，<br>    }<br>重定向和Flash属性<br>转发比重定向快，因为重定向经过客户端，而转发没有。但是，有时采用重定向更好，若需要重定向到一个外部网站，则无法使用转发<br>使用重定向的一个不方便的地方是：无法轻松的传值给目标页面，而采用转发，则可以简单的将属性添加到model中。Spring 3 版本通过Flash属性提供了一种供重定向传值的方法<br>要使用Flash属性，必须在Spring MVC 配置文件中有一个<annotation-driver> 元素，然后还必须在方法参数里面添加一个新的参数u类型<br>org.springframework.web.servlet.mvc.support.RedirectAttributes<br>@RequestMapping(value=”product-save”,method=RequestMethod.POST)<br>public String saveProduct(ProductForm productForm, RedirectAttributes redirectAttributes){<br>    redirectAttributes.addFlashAttribute(“message”,”The product was successfully added”);<br>    return “redict:/product_view” + product.getId();<br>}</annotation-driver></p>
<h3 id="tomcat默认就是不允许PUT和DELETE的"><a href="#tomcat默认就是不允许PUT和DELETE的" class="headerlink" title="tomcat默认就是不允许PUT和DELETE的"></a>tomcat默认就是不允许PUT和DELETE的</h3><p>如何配置Tomcat支持HTTP Delete和Put 方法<br>在tomcat web.xml文件中配置org.apache.catalina.servlets.DefaultServlet的</p>
<p><init-param><br>    <param-name>readonly</param-name><br>    <param-value>false</param-value><br></init-param><br>readonly参数默认是true，即不允许delete和put操作，所以通过XMLHttpRequest对象的put或者delete方法访问就会报告http 403错误。为REST服务起见，应该设置该属性为false。</p>
<p>Jstl 学习<br>页面请求：　<a href="emps">List All Employees</a><br>Handler 处理<br>@RequestMapping(“/emps”)<br>    public String list(Map<string, object=""> map){<br>        // 把结果放入到employees这个map中，返回<br>        map.put(“employees”, employeeDao.getAll());<br>        return “list”;<br>    }<br>list.jsp<br><br> 我是分割线<br><br>    <c:if test="${empty requestScope.employees }"><br>        没有任何员工信息<br>    </c:if><br>    <c:if test="${!empty requestScope.employees }"><br>        <table border="1" cellpadding="10" cellspacing="1"><br>            <tr><br>                <th>ID</th><br>                <th>LastName</th><br>                <th>Email</th><br>                <th>Gender</th><br>                <th>Department</th><br>                <th>Edit</th><br>                <th>Delete</th><br>            </tr><br>            <c:foreach items="${requestScope.employees }" var="emp"><br>                <tr><br>                    <td>${emp.id }</td><br>                    <td>${emp.lastName }</td><br>                    <td>${emp.email }</td><br>                    <td>${emp.gender==0?’Female’ : ‘Male’ }</td><br>                    <td>${emp.department.departmentName }</td><br>                    <td><a href="">Edit</a></td><br>                    <td><a href="">Delete</a></td><br>                </tr><br>            </c:foreach><br>        </table><br>    </c:if></string,></p>
<p>可以在spring MVC 中配置 <mvc:default-servlet-handler> 可以解决静态资源文件找不到的问题</mvc:default-servlet-handler></p>
<p>xml配置文件可以通过一份主配置文件，其它文件导入</p>
<p>应用MVC，可以在Controller类中调用后端业务逻辑，通常，需要若干封装了后端复杂逻辑的Service类，在Service类中，可以实例化一个DAO类来访问数据库。在Spring MVC 中，Service 对象可以自动被注入到Controller对象中，而DAO对象可以自动被注入到Service对象中。<br>&lt;%@ taglib prefix=”form” uri=”<a href="http://www.springframework.org/tags/form" target="_blank" rel="external">http://www.springframework.org/tags/form</a>“ %&gt;<br>&lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core" target="_blank" rel="external">http://java.sun.com/jsp/jstl/core</a>“ %&gt;</p>
<p><c:if test="${requestScope.errors !=null}"><br>    <p id="errors"><br>    Errors(s)!<br>    <ul><br>    <c:foreach var="errors" items="${requestScope.errors}"><br>        <li>${error}</li><br>    </c:foreach><br>    </ul><br>    </p><br></c:if></p>
<p>一般的， @RequestMapping(“/custom”) 和 @RequestMapping(value=”/custom”) 一样，如果有超过一个属性时，必须写入value属性名称<br>method属性用来指示该方法处理哪些HTTP方法 eg: RequestMethod.PUT</p>
<p>import org.apache.commons.logging.Log ;<br>import org.apache.commons.logging.LogFactory;<br>private static final Log logger = LogFactory.getLog(Product.class)<br>logger.info(“save product”);</p>
<hr>
<h3 id="编写转换器-amp-amp-验证器"><a href="#编写转换器-amp-amp-验证器" class="headerlink" title="编写转换器 &amp;&amp; 验证器"></a>编写转换器 &amp;&amp; 验证器</h3><p>一. 转换器</p>
<ol>
<li>实现Converter<s,t> 接口，S 输入，T输出；<br> eg: 编写StringToDateConverter</s,t></li>
<li><p>注册转换器</p>
 <bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"><br>     <property name="converters"><br>         <list><br>             <bean class="com.yuchuan.controller.StringToDateConverter"><br>                 <constructor-arg type="java.lang.String" value="MM-dd-yyyy"></constructor-arg><br>             </bean><br>         </list><br>     </property><br> </bean>

 <mvc:annotation-driven conversion-service="conversionService"></mvc:annotation-driven></li>
<li>编写控制类调用<br> @RequestMapping(value=”employee_save”)<br> public String saveEmployee(@ModelAttribute Employee employee,<pre><code>    BindingResult bindingResult,Model model){
if(bindingResult.hasErrors()){
    FieldError fieldError = bindingResult.getFieldError();
    logger.info(&quot;Code:&quot;+fieldError.getCode()+&quot;,field:&quot;+fieldError.getField());
    return &quot;EmployeeForm&quot;;
}
logger.info(&quot;employeeDeatails&quot;);
model.addAttribute(&quot;employee&quot;,employee);
return &quot;EmployeeDetails&quot;;
</code></pre> }<br>每个需要校验的Bean后面紧跟一个BindingResult，SpringMVC框架会将校验结果保存在它里面，通过hasErrors方法可以<br>判断是否有校验错误；最后，当返回到原页面以后，SpringMVC框架还会将所有校验错误信息保存在上下文中，供页面上取得<br>校验错误，Spring提供了一套JSP自定义标签。</li>
</ol>
<p>注意引入css文件 <style type="text/css">@import url(“<c:url value="/css/main.css"/>“);</style><br>不经过springmvc默认拦截器<br>    <mvc:annotation-driven><br>    <mvc:resources mapping="/css/**" location="/css/"><br>    <mvc:resources mapping="/*.html" location="/"></mvc:resources></mvc:resources></mvc:annotation-driven></p>
<p>二、 验证器</p>
<ol>
<li>编写ProductValidator，实现Validator接口</li>
<li>xml文件 <bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"><br>     <property name="basename" value="/WEB-INF/resource/messages"></property><br> </bean></li>
<li>编写Controller<br>@RequestMapping(“/product_save”)<br> public String saveProduct(@ModelAttribute Product product,<pre><code>    BindingResult bindingResult,Model model){
ProductValidator productValidator = new ProductValidator();
productValidator.validate(product, bindingResult);
if(bindingResult.hasErrors()){
    FieldError fieldError = bindingResult.getFieldError();
    logger.info(&quot;Code:&quot;+fieldError.getCode()+&quot;,field:&quot;+fieldError.getField());
    return &quot;ProductForm&quot;;
}
model.addAttribute(&quot;product&quot;,product);
return &quot;ProductDetails&quot;;
</code></pre> }</li>
</ol>
<p>JSTL<br>遍历对象</p>
<p><c:foreach items="${books}" var="book"><br>    <tr><br>        <td>${book.category.name}</td><br>        <td>${book.title}</td><br>        <td>${book.isbn}</td><br>        <td>${book.author}</td><br>    </tr><br></c:foreach></p>
<p>遍历 HashMap<string,string></string,string></p>
<p><c:foreach items="${requestScope.capitals }" var="map"><br>        <tr><br>            <td>${map.key }</td><br>            <td>${map.value }</td><br>        </tr><br>    </c:foreach></p>
<p>遍历 HashMap<string,string[]></string,string[]></p>
<p><c:foreach items="${requestScope.bigCities}" var="mapItem"><br>    <tr><br>        <td>${mapItem.key}</td><br>        <td><br>            <c:foreach items="${mapItem.value}" var="city" varstatus="status"><br>                ${city}<c:if test="${!status.last}">,</c:if><br>            </c:foreach><br>        </td><br>    </tr><br>    </c:foreach></p>
<p>遍历以特殊符号分割的字符串<br>    <c:fortokens items="Ab,Ba,BC" delims="," var="item"><br>                <c:out value="${item}"></c:out><br>    </c:fortokens></p>
<p><fmt:formatnumber value="12" type="number"></fmt:formatnumber></p>
<p><fmt:formatnumber value="12" type="number" minintegerdigits="3"></fmt:formatnumber></p>
<p><fmt:formatnumber value="123434" pattern=".000"></fmt:formatnumber></p>
<p><fmt:formatnumber value="12" type="currency"></fmt:formatnumber></p>
<p><fmt:formatnumber value="0.12" type="percent"></fmt:formatnumber></p>
<p><fmt:formatnumber value="0.125" type="percent" minfractiondigits="2"></fmt:formatnumber></p>
<p>使用上传文件（使用commons-fileupload和commons-io）<br>@RequestMapping(value = “/product_save”)<br>    public String saveProduct(HttpServletRequest servletRequest,<br>            @ModelAttribute Product product, BindingResult bindingResult,<br>            Model model) {</p>
<pre><code>    List&lt;MultipartFile&gt; files = product.getImages();

    List&lt;String&gt; fileNames = new ArrayList&lt;String&gt;();
    File imageFile = null;
    if (null != files &amp;&amp; files.size() &gt; 0) {
        for (MultipartFile multipartFile : files) {

            String fileName = multipartFile.getOriginalFilename();
            fileNames.add(fileName);

            imageFile = new File(servletRequest.getServletContext()
                    .getRealPath(&quot;/image&quot;), fileName);
            logger.info(&quot;path is :&quot; + imageFile);
            try {
                multipartFile.transferTo(imageFile);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    // save product here
    model.addAttribute(&quot;product&quot;, product);
    model.addAttribute(&quot;path&quot;,imageFile);
    return &quot;ProductDetails&quot;;
}
</code></pre><p>JSP</p>
<p><c:foreach items="${product.images}" var="image"><br>            <li>${image.originalFilename}<br>            <img src="${path }"><br>            </li><br>        </c:foreach><br>配置</p>
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"><br>        <property name="maxUploadSize" value="2000000"><br>    </property></bean>


<p>Servlet 注意线程安全性。Servlet 实例会被一个应用程序中的所有用户共享，因此不建议使用类级变量，除非它们是只读的，或者是java.util.concurrent.atomic 包的成员<br>将项目打包成war文件复制放在Tomcat的webapps目录下，当开始启动Tomcat时，Tomcat 就会自动解压这个war文件，部署成war文件所有Servlet容器中都适用</p>
<p>ServletRequest 方法<br>public int getContentLength()<br>public String getContentType()<br>public Stirng getProtocol()<br>public String getParameter(Stirng name)<br>还可以使用getParameterNames/getParameterMap/getParameterValues 获取表单域名、值及查询字符串。</p>
<p>ServletResponse<br>在调用Servlet的Service方法前，Servlet 容器首先创建一个ServletResponse，并将它作为第二个参数传给Service方法。ServletResponse 隐藏了向浏览器发送响应的复杂过程 。在ServletResponse中定义的方法之一是getWritter方法，它返回了一个可以向客户端发送文本的PrintWriter.还有一个方法可以用来向浏览器发送输出，getOutputStream,但这个方法是用于发送二进制数据，因此大部分情况下使用的是getWriter,而不是getOutputStream.<br>ServletConfig<br>当Servlet容器初始化Servlet时，Servlet 容器会给Servlet的init方法传入一个ServletConfig.ServletConfig 封装可以通过@Webservlet 或者部署描述符（web.xml）传给Servlet配置信息。这样传入的每一个条信息就叫一个初始参数。一个初始参数有key和value两个元件。<br>为了从servlet内部获取到初始参数的值，要在Servlet容器传给Servlet的init方法的ServletConfig中调用getInitParameter方法。<br>String getInitParameter(String name) 此外，getInitParameterNames方法则是返回所有参数名称的一个Enumeration。<br>除了getInitParameter和getInitParameterNames，ServletConfig 还提供了 getServletContext 方法。<br>@WebServlet(name=”MyServlet”,<br>    urlPatterns={“/my”},<br>    initParams={<br>            @WebInitParam(name=”admin”,value=”Harry”),<br>            @WebInitParam(name=”email”,value=”admin@example.com”)<br>    })<br>public class MyServlet implements Servlet{<br>    public void service(ServletRequest request, ServletResponse response){<br>        String admin = servletConfig.getInitParameter(“admin”);<br>        String email = servletConfig.getInitParameter(“email”);<br>    }<br>}</p>
<p>ServletContext<br>可以共享从应用程序中的所有资料处访问到的信息 ，并且可以动态注册web对象，前者将对象保存在ServletContext中的一个内部Map中<br>Object getAttribute(String name)<br>java.util.Enumeration<stirng> getAttributeNames()<br>void setAttribute(String name,Object object)<br>void remove Attribute(String name)</stirng></p>
<p>GenericServlet<br>public void service(ServletRequest paramServletRequest, ServletResponse paramServletResponse)<br>            throws ServletException, IOException {<br>        ServletConfig servletConfig = getServletConfig();<br>        String admin = servletConfig.getInitParameter(“admin”);<br>        paramServletResponse.setContentType(“text/html”);<br>        PrintWriter writer = paramServletResponse.getWriter();<br>        writer.println(“<html><head></head>“<br>                +”<body>Hello From “ + admin<br>                +”</body></html>“);<br>    }</p>
<p>HttpServlet<br>查阅HttpServlet 中service方法源码，该方法会检验用来发送请求的HTTP方法（通过调用request.getMethod）并调用以下方法之一：doGet/doPost/doHead/doPut/doDelete/doTrace/doOptions。这七种方法每一种方法都表示一个HTTP方法<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-6-5/85130786.jpg" alt="javax.servlet主要类型"><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-6-5/57507735.jpg" alt="javax.servlet.http主要类型"></p>
<p>Servlet 上的WebServlet标注如果如果同时也在部署描述符中进行声明，那么它将不起作用。但是，在有部署描述符的应用程序中，却不在部署描述符中标注的Servlet时，则仍然有效。这意味着，可以标注Servlet，并在同一个应用程序的部署描述符中声明这些Servlet<br>Filter 配置eg:</p>
<p><filter><br>    <filter-name>Logging Filter</filter-name><br>    <filter-class>com.yuchuan.LoggingFilter</filter-class><br></filter></p>
<p><filter-mapping><br>    <filter-name>Logging Filter</filter-name><br>    <url-pattern>MyServlet</url-pattern><br></filter-mapping></p>
<p>Listener 用来注册一个监听器，子元素listener-class包含监听器类的全路径名</p>
<listener><br>    <listener-class>com.yuchuan.ApplicationListener</listener-class><br></listener>

<p>servlet-mapping<br>映射一个Servlet到/first</p>
<p><servlet><br>    <servlet-name>FirstServlet</servlet-name><br>    <servlet-class>com.yuchuan.FirstServlet</servlet-class><br></servlet></p>
<p><servlet-mapping><br>    <servlet-name>FirstServlet</servlet-name><br>    <url-pattern>/first</url-pattern><br></servlet-mapping></p>
<p>session-config 元素定义了javax.servlet.http.HttpSession 实例的参数，此元素可以包含session-timeout cookie-config或 tracking-mode<br>session-timeout 指定会话时间超时间隔（分钟），必须为整数。如果该值为零或负数，则会话永不超时<br>cookie-config 定义了跟踪会话创建的cookie的配置<br>tracking-mode  定义了跟踪会话模式，有效值是 Cookie URL 或 SSl<br>eg: 表示应用的HttpSession对象在不活动12min后失效。<br>     <session-config><br>          <session-timeout>12</session-timeout><br>     </session-config></p>
<p>xsi:schemaLocation 属性制定了模式文档的位置，以便可以进行验证。</p>
<p>@RequestMapping(value=”/url”)<br>public String myMethod(){<br>    session.addAttribute(key,value);<br>}<br>Spring MVC 中可以在请求处理方法中出现的参数类型包括：<br>javax.servlet.ServletRequest 或 javax.servlet.http.HttpServletRequest<br>javax.servlet.ServletResponse 或 javax.servlet.http.HttpServletResponse<br>javax.servlet.HttpSession<br>org.springframework.web.context.request.WebRequest<br>java.util.Locale<br>java.io.InputStream 或  java.io.Reader<br>java.io.OutputStream 或 java.io.Writer<br>java.security.Principal<br>HttpEntity&lt;?&gt;<br>java.util.Map / org.springframework.ui.Model<br>org.springframework.web.servlet.mvc.support.RedirectAttributes<br>org.springframework.validation.Errors<br>org.springframework.validation.BindingResult<br>org.springframework.web.bind.support.SessionStatus<br>org.springframework.web.util.UriComponentsBuilder<br>带@PathVariable, @MatrixVariable 注解的对象<br>@RequestParam @RequestHeader @RequestBody @RequestPart<br>注意： org.springframework.ui.Model 类型，这不是一个Servlet API 类型，而是一个包含Map的Spring MVC 类型。每次调用请求处理方法时，Spring MVC 都创建Model对象并将其Map注入到各种对象<br>请求处理方法可以返回如下类型的对象：<br>ModelAndView<br>Model<br>Map 包含模型的属性<br>View<br>代表逻辑视图名的String<br>提供对Servlet的访问，以响应Http头部和内容 HttpEntity 或 ResponseEntity 对象<br>Callable<br>DeferredResult<br>其他任意类型，Spring 将其视作输出给View的对象模型</p>
<p><mvc:annotation-driven></mvc:annotation-driven></p>
<p><mvc:resources mapping="/css/**" location="/css/"></mvc:resources></p>
<p><mvc:resources mapping="/*.html" location="/"></mvc:resources></p>
<p><annotation-driven> 元素做的事情包括注册用于支持基于注解的控制器的请求处理方法的bean对象。<resource> 元素则只是Spring MVC 哪些静态资源需要单独处理（不通过dispatcher servlet）<br>第一个确保在CSS目录下的所有文件可见，第二个允许显示所有的.html文件<br>注意： 如果没有 <annotation-driven> <resources>元素会阻止任意控制器被调用，若不需要使用resources,则不需要<annotation-driven>元素</annotation-driven></resources></annotation-driven></resource></annotation-driven></p>
<p>无论是否会使用Model，Spring MVC 都会在每一个请求处理方法被调用时创建一个Model实例，用于增加需要显示在视图中的属性。例如通过<br>model.addAttribute(“product”,product) 来添加实例 。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[spring笔记2]]></title>
      <url>http://yoursite.com/2016/06/09/spring%E7%AC%94%E8%AE%B02/</url>
      <content type="html"><![CDATA[<p>Spring_note.java<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-17/8333499.jpg" alt="第一阶段"><br><br><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-17/71841689.jpg" alt="第二阶段"><br><br><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-17/89899451.jpg" alt="第三阶段"></p>
<p>ApplicationContext 主要实现类：</p>
<ol>
<li>ClassPathXmlApplicationContext</li>
<li>FileSystemApplicationContext<br>属性可以指定类型<br><bean id="car" class="com.Po.Car"><pre><code>&lt;constructor-arg value=&quot;Audi&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt;
&lt;constructor-arg value=&quot;Shagnhai&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt;
&lt;constructor-arg value=&quot;240&quot; type=&quot;int&quot;&gt;&lt;/constructor-arg&gt;
</code></pre></bean><br>若属性过多，可以指定type类型或index属性来声明<br>属性字符值有特殊字符 ，使用CDATA设置  <value>&lt;![CDATA[^shanghai&gt;]]&gt;</value></li>
</ol>
<p>通过p的命名空间为bean的属性赋值，需要先导入P命名空间，相对于传统的配置方式更加简洁</p>
<bean id="person" class="com.Po.Person" p:name="Queen" p:car-ref="car" p:address-ref="address"><br>自动装配 （根据名字自动装配）<br><bean id="person" class="com.Po.Person" p:name="Queen" autowire="byName"><br>byName根据bean的名字和当前bean的setter风格的属性名进行自动装配<br><br>bean配置之间的继承<br><bean id="address" class="com.Po.Address" p:city="beijing" p:street="Wudaokou"></bean><br><bean id="address2" p:street="Dazhongsi" parent="address"></bean><br>子bean从父bean继承配置，可以覆盖配置<br>可以把需要被继承的bean  加上属性  abstract=”true” ,就只能被其他bean继承，不能被实例化<br><br>bean之间的依赖关系<br>depends-on=”car” IOC容器初始化的时候没有这个实例则报错，若有多个，通过逗号分隔<br><br>PropertyPlaceholderConfigurer<br><br>db.properties<br>user = root<br>password = root<br>driverClass = com.mysql.jdbc.Driver<br>jdbcUrl = jdbc:mysql://127.0.0.1:3306/test<br><br>spring.xml<br><context:property-placeholder location="classpath:db.properties"><br><br>    <bean id="datasource" class="com.mchange.v2.c3p0.ComboPooledDataSource"><br>        <property name="user" value="${user}"></property><br>        <property name="password" value="${password}"></property><br>        <property name="driverClass" value="${driverClass}"></property><br>        <property name="jdbcUrl" value="${jdbcUrl}"></property><br>    </bean>


<p>Spring<br>spring 调用无参构造器，使用set方法<br>通过反射的方式在IOC容器中创建Bean，所有类必须含有无参构造器<br>使用构造器注入属性值可以指定参数的位置和参数的类型，以区分重载的构造器</p>
<bean id="car2" class="com.atguigu.spring.beans.Car"><br>        <constructor-arg value="Baoma" type="java.lang.String"></constructor-arg><br>        <constructor-arg value="Shanghai" type="java.lang.String"></constructor-arg><br>        <constructor-arg value="240000" type="int"></constructor-arg><br></bean>

<p>字面值： 可用字符串表示的值，可以通过value属性或者value子节点<br>若要包含特殊字符，使用 <value>&lt;![CDATA[<shanghai^]]></shanghai^]]></value></p>
<p>自动装配Bean，在<bean>的autowire属性里指定自动装配的模式<br>byType  byName   根据类型和名称自动装配<br>赋值为null    <constructor-arg><null></null></constructor-arg></bean></p>
<bean id="person3" class="com.atguigu.spring.beans.collection.Person"><br>         <property name="name" value="Mike"></property><br>         <property name="age" value="27"></property><br>         <property name="car"><br>             <list><br>                 <ref bean="car"><br>             </ref></list><br>         </property><br></bean><br>使用map<br><map><br>    <entry key="AA" value-ref="car"></entry><br>    <entry></entry><br></map><br>通过p命名空间为bean的属性赋值，需要先导入P命名空间<br>        加入 xmlns:p=”<a href="http://www.springframework.org/schema/p" target="_blank" rel="external">http://www.springframework.org/schema/p</a>“<br><bean id="person5" class="com.atguigu.spring.beans.collection.Person" p:age="30" p:name="Queen" p:car-ref="car"></bean>

<p>autowire=”byName” 根据名字自动装配<br>autowire=”byType” 根据bean的类型和当前bean的属性的类型进行自动装配，若IOC容器有1个以上的相同类型，无法装配<br>autowire 缺点 1.只希望装配个别属性时，不够灵活  2） 要么根据名称装配，要么根据类型装配，不够灵活</p>
<p>parent指定继承哪个配置   eg: parent = “address” ,子bean从父bean继承属性值，也可以覆盖继承的属性值<br>抽象bean  ，abstract=”brue” 其他bean继承它<br>eg <bean id="address" p:city="Beijing" abstract="true"></bean><br>子Bean定义可以从父Bean继承实现类、构造器参数、属性值等配置信息。可以增加新的配置信息，覆盖父类配置信息<br>子Bean无法从父Bean继承如下属性：depends-on/autowire/singleton/scope/lazy-init，这些属性将总是从子Bean定义中获得，或采用默认值</p>
<p>若某一个bean的class属性没有被指定，则必须是一个抽象bean<br>并不是bean里面所有的属性都会被继承，比如 abstract autowire不会被继承<br>前置依赖的bean会在本bean之前创建好  depends-on=”car”<br>scope=”singleton”  创建容器的时候创建bean<br>scope=”Prototype”  默认不创建，每次请求时都创建一个新的bean<br>scope=”session”  or  “request”  对应web</p>
<p>PropertyPlaceholderConfigure 的BeanFactory 后置处理器允许用户将Bean配置的部分内容外移到配置文件中</p>
<p><context:property-placeholder location="classpath:db.properties"><br>    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"><br>        <property name="user" value="${user}"></property><br>        <property name="password" value="${password}"></property><br>        <property name="driverClass" value="${driverClass}"></property><br>        <property name="jdbcUrl" value="${jdbcUrl}"></property><br></bean></context:property-placeholder></p>
<p>db.properties<br>user=root<br>password=root<br>driverClass=com.mysql.jdbc.Driver<br>jdbcUrl=jdbc:mysql://localhost:3306/test<br>测试：<br>DataSource dataSource = (DataSource) ctx.getBean(“datasource”);<br>        System.out.println(dataSource.getConnection());</p>
<p>spring使用#{…}作为定界符，所有在大框号的字符都将被认为是SpEL<br>SpEL 为bean的属性进行动态赋值提供了便利<br>字面量的表示：<br>整数  <property name="count" value="#{5}"><br>小数  <property name="frequency" value="#{89.7}"><br>boolean <property name="enabled" value="#{false}"><br>String可以使用单引号或者双引号作为字符串的定界符号</property></property></property></p>
<p><property name="name" value="#{'Chunk'}"> 或 <property name="name" value="#{"Chunk"}"></property></property></p>
<p>算数运算符</p>
<p><property name="one" value="#{counter.total+42}"></property></p>
<p><property name="one" value="#{2 * T(java.lang.Math).PI * circle.radius}"><br>加号还可以作字符串连接</property></p>
<p><constructor-arg value="#{performer.firstName + ' ' + performer.lastname"><br>比较运算符</constructor-arg></p>
<p><property name="one" value="#{counter.total==100}"></property></p>
<p><property name="two" value="#{counter.total le 1000}"><br>逻辑运算符</property></p>
<p><property name="large" value="#{shape.king=='circle' and shape.perimeter gt 10000}"></property></p>
<p><property name="outOfStock" value="#{!product.available}"></property></p>
<p><property name="outofStock" value="#{not product.available}"><br>if-else 运算</property></p>
<p><constructor-arg value="{songSelector.selectSong()=='Jingle one' ? 'Jing two':'Jing bells"><br>正则表达式</constructor-arg></p>
<constructor-arg value="#{admin.email matches '[a-zA-Z0-9]'} ">


<p>调用静态方法或静态属性：通过T()调用一个类的静态方法，它将返回一个Class Object ，然后再调用相应的方法或属性</p>
<p><property name="initValue" value="#{T(java.lang.Math).PI}"></property><br>SpEL表达式case<br>    <bean id="address" class="com.Po.Address"><br>        <property name="city" value="#{'beijing'}"></property><br>        <property name="street" value="WuDaoKou"></property><br>    </bean></p>
<pre><code>&lt;bean id=&quot;car&quot; class=&quot;com.Po.Car&quot;&gt;
    &lt;property name=&quot;brade&quot; value=&quot;Audi&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;price&quot; value=&quot;50000&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;tyrePerimter&quot; value=&quot;#{T(java.lang.Math).PI*2}&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;person&quot; class=&quot;com.Po.Person&quot;&gt;
    &lt;property name=&quot;car&quot; value=&quot;#{car}&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;address&quot; value=&quot;#{address}&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;#{car.brade}&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>声明注入实例前后要执行的方法</p>
<bean id="car" class="com.Po.Car" init-method="initExe" destroy-method="stopExe"><br><br>        <property name="brade" value="Audi"></property><br>        <property name="price" value="#{2000}"></property><br>        <property name="tyrePerimter" value="#{2*T(java.lang.Math).PI}"></property><br></bean><br>或者 后置处理器<br><beans><br><bean id="car" class="com.Po.Car"><br><br>        <property name="brade" value="Audi"></property><br>        <property name="price" value="#{2000}"></property><br>        <property name="tyrePerimter" value="#{2*T(java.lang.Math).PI}"></property><br>    </bean>

<bean class="com.Po.MyBeanPostProcessor"><br></bean>

<p>MyBeanPostProcessor 该类实现BeanPostProcessor接口<br>public class MyBeanPostProcessor implements BeanPostProcessor{</p>
<pre><code>@Override
public Object postProcessAfterInitialization(Object bean, String beanName)
        throws BeansException {
    System.out.println(&quot;postProcessAfterInitialization &quot; + bean+&quot;, &quot;+beanName );
    return bean;
}

@Override
public Object postProcessBeforeInitialization(Object bean, String beanName)
        throws BeansException {
    System.out.println(&quot;postProcessBeforeInitialization &quot; + bean+&quot;, &quot;+beanName );
    return bean;
}
</code></pre><p>}<br>可以在以上两个方法中修改返回的bean，甚至返回一个新的bean</p>
<p>静态工厂方法<br>public class StaticCarFactory {<br>    private static Map<string,car> cars = new HashMap<string, car="">();<br>    static{<br>        cars.put(“audi”, new Car(“audi”,30000));<br>        cars.put(“ford”, new Car(“ford”,40000));<br>    }</string,></string,car></p>
<pre><code>public static Car getCar(String name){
    return cars.get(name);
}
</code></pre><p>}<br>通过静态工厂方法来配置bean，注意不是配置静态工厂方法实例，而是配置bean实例<br>class属性：指向静态工厂方法的全类名<br>factory-method:指向静态工厂方法的名字<br>constructor-arg: 如果工厂方法需要传入参数u，使用constructor-arg 传参</p>
<bean id="car1" class="com.Po.StaticCarFactory" factory-method="getCar"><br>        <constructor-arg value="audi"></constructor-arg><br></bean>

<p>实例工厂方法<br>先需要创建工厂本身，在调用工厂的方法<br>public class InstanceCarFactory {<br>    private Map<string, car=""> cars = null;</string,></p>
<pre><code>public InstanceCarFactory() {
    cars = new HashMap&lt;String, Car&gt;();
    cars.put(&quot;audi&quot;, new Car(&quot;audi&quot;, 30000));
    cars.put(&quot;ford&quot;, new Car(&quot;ford&quot;, 30000));
}

public Car getCar(String brand) {
    return cars.get(brand);
}
</code></pre><p>}</p>
<bean id="carFactory" class="com.Po.InstanceCarFactory"></bean>

<bean id="car2" factory-bean="carFactory" factory-method="getCar"><br>    <constructor-arg value="ford"></constructor-arg><br></bean>

<p>通过FactoryBean返回bean的实例，class:指向FactoryBean的全类名，property：配置FactoryBean的属性<br>但实际返回的实例FactoryBean的getObejct()方法返回的实例。</p>
<bean id="car2" class="com.Po.CarFactoryBean"><br>        <property name="brand" value="AUdi"></property><br></bean>


<p>public class CarFactoryBean implements FactoryBean<car>{</car></p>
<pre><code>private String brand;
public void setBrand(String brand){
    this.brand = brand;
}

@Override
public Car getObject() throws Exception {
    return new Car(&quot;BMW&quot;,500000);
}

@Override
public Class&lt;?&gt; getObjectType() {
    return Car.class;
}

@Override
public boolean isSingleton() {
    return true;
}
</code></pre><p>}<br>配置说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">静态工厂配置</div><div class="line">public class BeingFactory &#123;</div><div class="line">	public static Being getBeing(String arg)&#123;</div><div class="line">		if(arg.equalsIgnoreCase(&quot;dog&quot;))&#123;</div><div class="line">			return new Dog();</div><div class="line">		&#125;else</div><div class="line">			return new Cat();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">&lt;bean id=&quot;dog&quot; class=&quot;com.yuchuan.BeingFactory&quot;</div><div class="line">	factory-method=&quot;getBeing&quot;&gt;</div><div class="line">	&lt;!-- constructor-arg 元素用于为静态工厂方法指定参数--&gt;</div><div class="line">	&lt;constructor-arg value=&quot;dog&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line">	&lt;!-- property 元素驱动spring执行setter方法 --&gt;</div><div class="line">	&lt;property name=&quot;msg&quot; value=&quot;i am dog&quot;&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean id=&quot;cat&quot; class=&quot;com.yuchuan.BeingFactory&quot;</div><div class="line">	factory-method=&quot;getBeing&quot;&gt;</div><div class="line">	&lt;constructor-arg value=&quot;cat&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line">	&lt;property name=&quot;msg&quot; value=&quot;i am cat&quot;&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">实例工厂配置</div><div class="line">public class PersonFactory &#123;</div><div class="line">	public IPerson getPerson(String ethnic)&#123;</div><div class="line">		if(ethnic.equalsIgnoreCase(&quot;chin&quot;))&#123;</div><div class="line">			return new Japanese();</div><div class="line">		&#125;else</div><div class="line">			return new American();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;bean id=&quot;PersonFactory&quot; class=&quot;com.yuchuan.PersonFactory&quot;&gt;&lt;/bean&gt;</div><div class="line">&lt;bean id=&quot;american&quot; factory-bean=&quot;PersonFactory&quot;</div><div class="line">	factory-method=&quot;getPerson&quot;&gt;</div><div class="line">	&lt;constructor-arg value=&quot;chin&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean id=&quot;japanese&quot; factory-bean=&quot;PersonFactory&quot;</div><div class="line">	factory-method=&quot;getPerson&quot;&gt;</div><div class="line">	&lt;constructor-arg value=&quot;chin2&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>基于注解的方式</p>
<p><context:component-scan>  扫描多个包可以使用逗号分隔<br>@Service<br>@Controller<br>@Respository</context:component-scan></p>
<!-- 可以通过resource-patter指定扫描的资源 -->
<pre><code>&lt;context:component-scan base-package=&quot;com.atguigu.spring.beans.annotation&quot;
    resource-pattern=&quot;respository/.class&quot;&gt;&lt;/context:component-scan&gt;
</code></pre><p>context:exclude-filter  根据表达式排除指定包的类</p>
<p><context:component-scan base-package="com.atguigu.spring.beans.annotation"><br>        <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository"><br>    </context:exclude-filter></context:component-scan></p>
<p>context:include-filter 根据表达式只扫描指定包的类，注意要和 use-default-filters=”false” 一起使用</p>
<p><context:component-scan base-package="com.atguigu.spring.beans.annotation" use-default-filters="false"><br>        <context:include-filter type="annotation" expression="org.springframework.stereotype.Repository"><br>    </context:include-filter></context:component-scan></p>
<p>不包含某个接口和所有实现该接口的类</p>
<p><context:component-scan base-package="com.atguigu.spring.beans.annotation"><br>        <context:exclude-filter type="assignable" expression="com.atguigu.spring.beans.annotation.respository.UserRespository"><br>    </context:exclude-filter></context:component-scan></p>
<p>只包含实现了某个接口</p>
<p><context:component-scan base-package="com.atguigu.spring.beans.annotation" use-default-filters="false"><br>        <context:include-filter type="assignable" expression="com.atguigu.spring.beans.annotation.respository.UserRespository"><br>    </context:include-filter></context:component-scan></p>
<p><context:component-scan> 元素还会自动注册AutowiredAnnotationBeanPostProcessor实例，该实例可以自动装配具有@Autowired 和 @Resource<br>@Inject 注解的属性</context:component-scan></p>
<p>@Autowired 注解自动装配具有兼容类型的单个Bean属性<br>构造器，普通字段(及时非public)，一切具有参数的方法都可以应用 @Autowired 注解<br>默认情况下，所有使用@Autowired 注解的属性都需要被设置，当Spring找不到匹配的Bean装配属性时，会抛出异常，若某一属性允许不被设置，可以设置@Autowired 注解的required属性为false   eg: @Autowired(required=false),找不到这个实例不会报错，而是为该实例为null</p>
<p>@Autowired 也可以应用在数据类型上，此时Spring会把所有匹配的Bean进行自动装配<br>@Autowired 也可以应用在集合上，此时Spring读取该集合的类型信息，自动装配所有与之兼容的Bean<br>@Autowired 用在Map 上，若该Map的键值为String，那么Spring将自动装配与之Map值类型兼容的Bean，此时Bean的名称作为键，bean本身作为值</p>
<p>若指定包含某个实现了接口的类<br>可以<br>@Autowired<br>@Qualifier(“userRepository”) 指定名字</p>
<p>泛型依赖注入<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-18/14319610.jpg" alt=""><br>public class BaseRepository<t> {</t></p>
<p>}<br>public class BaseService<t>{<br>    @Autowired<br>    protected BaseRepository<t> repository;</t></t></p>
<pre><code>public void add(){
    System.out.println(&quot;add...&quot;);
    System.out.println(repository);
}
</code></pre><p>}</p>
<p>@Repository<br>public class UserRepository extends BaseRepository<user>{</user></p>
<p>}</p>
<p>@Service<br>public class UserService extends BaseService<user>{</user></p>
<p>}</p>
<p>public class User{</p>
<p>}</p>
<p>父类之间建立了联系，子类继承了这种联系，还使用了User具体类型代替泛型 T</p>
<p>动态代理实现AOP<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-19/31932448.jpg" alt=""></p>
<p>public class ArithmeticCalculatorImpl implements ArithmeticCalculator{</p>
<pre><code>@Override
public int add(int i, int j) {
    int result = i+j;
    return result;
}

@Override
public int sub(int i, int j) {
    int result = i-j;
    return result;
}
</code></pre><p>}</p>
<p>public class ArithmeticCalculatorLoggingProxy {<br>    // 要代理的对象<br>    private ArithmeticCalculator target;</p>
<pre><code>public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) {
    this.target = target;
}

public ArithmeticCalculator getLoggingProxy(){
    ArithmeticCalculator proxy = null;
    // 代理对象由哪一个类加载器负责加载
    ClassLoader loader = target.getClass().getClassLoader();
    // 代理对象的类型，其中有哪些方法
    Class[] interfaces = new Class[]{ArithmeticCalculator.class};
    // 当调用代理对象其中的方法时，该执行的代码
    InvocationHandler h = new InvocationHandler() {
        /**
         * @proxy： 正在返回的那个代理对象，一般情况下，在invoke方法都不使用该对象
         * method：正在被调用的方法
         * args : 调用方法时传入的参数
         */
        @Override
        public Object invoke(Object proxy, Method method, Object[] args)
                throws Throwable {
            String methodName = method.getName();
            System.out.println(&quot;The methodName&quot;+methodName+&quot; begins with&quot; + Arrays.asList(args));
            Object result=method.invoke(target, args);
            System.out.println(&quot;method &quot; + methodName +&quot; ends with &quot;+result);
            return result;
        }
    };
    proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader, interfaces, h);

    return proxy;
}
</code></pre><p>}</p>
<p>public class MainTest {<br>    public static void main(String[] args) {</p>
<pre><code>    ArithmeticCalculator target = new ArithmeticCalculatorImpl();
    ArithmeticCalculator proxy = new ArithmeticCalculatorLoggingProxy(target).getLoggingProxy();


    int result = proxy.sub(2, 1);
    System.out.println(&quot;--&gt;&quot;+result);

    result = proxy.add(1, 2);
    System.out.println(&quot;--&gt;&quot; + result);

}
</code></pre><p>}</p>
<p>输出<br>The methodNamesub begins with[2, 1]<br>method sub ends with 1<br>–&gt;1<br>The methodNameadd begins with[1, 2]<br>method add ends with 3<br>–&gt;3</p>
<p>AOP 的主要编程对象是切面，而切面模块化横切关注点<br>在应用AOP编程时，仍然需要定义公共功能，但可以明确的定义这个功能在哪里，以什么方式应用，并且不必修改受影响的类，这样一来横切关注点就被模块化到特殊对象里<br>AOP好处：<br>每个事物逻辑位于一个位置，代码不分散，便于维护和升级<br>业务模块更简洁，只包含核心业务代码</p>
<p>切面：横切关注点模块化的对象<br>连接点：程序执行的某个特定位置<br>切点： 每个类都拥有多个连接点，连接点是程序类客观存在的事务。AOP 通过切点定位到特定的连接点，类比：连接点相当于数据库中的记录，切点相当于查询条件。切点和连接点不是一对一，一个切点匹配多个连接点，切点通过org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件</p>
<p>AspectJ: java社区里最完整最流行的AOP框架<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-19/90018731.jpg" alt=""></p>
<p>@Component(value=”arithm”)<br>public class ArithmeticCalculatorImpl implements ArithmeticCalculator{</p>
<pre><code>@Override
public int add(int i, int j) {
    return i+j;
}

@Override
public int sub(int i, int j) {
    return i-j;
}
</code></pre><p>}</p>
<p>// 把这个类声明为一个切面，放入IOC容器中，再声明为一个切面<br>@Aspect<br>@Component<br>public class LoggingAspect {<br>    // 声明该方法是一个前置通知 ：在目标方法开始之前执行<br>    @Before(“execution(public int com.atguigu.aspect.ArithmeticCalculatorImpl.add(int, int))”)<br>    public void beforeMethod(JoinPoint joinPoint){<br>        String methodName = joinPoint.getSignature().getName();<br>        List<object> args = Arrays.asList(joinPoint.getArgs());<br>        System.out.println(“the method “ + methodName + “ begins with args “+args);<br>    }<br>}</object></p>
<p><context:component-scan base-package="com.atguigu.aspect"></context:component-scan><br>    <!-- 使用AspectJ注解 自动为匹配的类生成代理对象 --><br>    <aop:aspectj-autoproxy></aop:aspectj-autoproxy></p>
<ol>
<li>切面首先是一个IOC的bean，加入@Component 注解</li>
<li>切面 @Aspect 注解</li>
<li><aop:aspectj-autoproxy></aop:aspectj-autoproxy></li>
</ol>
<p>在类中声明通知</p>
<ol>
<li>声明一个方法</li>
<li>在方法前加入@Before 注解</li>
</ol>
<p>可以在通知里声明一个类型为JoinPoint的参数，就能访问链接细节，如方法名称和参数值</p>
<p>后置通知使在连接点完成之后执行的，即连接点返回结果或者抛出异常的时候<br>在后置通知中还不能访问目标方法执行的结果（可以在返回通知里面访问结果）<br>@After(“execution(<em> com.atguigu.aspect.</em>.*(int,int))”)<br>    public void afterMethod(JoinPoint joinPoint){<br>        String methodName = joinPoint.getSignature().getName();<br>        System.out.println(“the method “+methodName+” ends “);<br>    }</p>
<p>// 把这个类声明为一个切面，放入IOC容器中，再声明为一个切面<br>@Aspect<br>@Component<br>public class LoggingAspect {<br>    // 声明该方法是一个前置通知 ：在目标方法开始之前执行<br>    //前置通知<br>    @Before(“execution(<em> com.atguigu.aspect.</em>.<em>(int, int))”)<br>    public void beforeMethod(JoinPoint joinPoint){<br>        String methodName = joinPoint.getSignature().getName();<br>        List<object> args = Arrays.asList(joinPoint.getArgs());<br>        System.out.println(“the method “ + methodName + “ begins with args “+args);<br>    }<br>    // 后置通知<br>    @After(“execution(</object></em> com.atguigu.aspect.<em>.</em>(int,int))”)<br>    public void afterMethod(JoinPoint joinPoint){<br>        String methodName = joinPoint.getSignature().getName();<br>        System.out.println(“the method “+methodName+” ends “);<br>    }<br>    /**</p>
<pre><code> * 方法正常结束执行的代码
 * 返回通知使可以访问到方法的返回值的
 * @param joinPoint
 * @param result
 */
@AfterReturning(value=&quot;execution(* com.atguigu.aspect.*.*(int,int))&quot;,
            returning=&quot;result&quot;)
public void afterReturning(JoinPoint joinPoint, Object result){
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&quot;the methodName &quot;+methodName+&quot; ends with &quot;+result);
}
/**
 * 在目标方法出现异常时执行
 * @param joinPoint
 * @param ex
 */
@AfterThrowing(value=&quot;execution(* com.atguigu.aspect.*.*(int,int))&quot;,
            throwing=&quot;ex&quot;)
public void afterThrowing(JoinPoint joinPoint, Exception ex){
    String methodName = joinPoint.getSignature().getName();

}
</code></pre><p>}</p>
<p>环绕通知<br>@Aspect<br>@Component<br>public class LoggingAspect {</p>
<pre><code>/**
 * 环绕通知需要携带ProceedingJoinPoint 类型的参数
 * 类似于动态代理的全过程；ProceedingJoinPoint类型的参数可以决定是否执行目标方法
 * 且环绕通知必须有返回值，返回值即目标方法的返回值
 * @param pjd
 * @throws Throwable
 */
@Around(value=&quot;execution(* com.atguigu.aspect.*.*(int,int))&quot;)
public Object aroundMethod(ProceedingJoinPoint pjd) throws Throwable{
    Object result = null;
    String methodName = pjd.getSignature().getName();
    try {
        // 前置通知
        System.out.println(&quot;the method &quot;+methodName + &quot; begins with &quot;+Arrays.asList(pjd.getArgs()));
        // 方法执行
        result = pjd.proceed();
        // 后置通知
        System.out.println(&quot;the method &quot;+methodName+&quot; ends with &quot;+result);
    } catch (Exception e) {
         // 异常通知
    }
    // 后置通知
    System.out.println(&quot;ends &quot;);
    return result;
}
</code></pre><p>}</p>
<p>指定切面的优先级，值越小优先级越高，添加注解<br>@Order(2)<br>@Aspect<br>@Component</p>
<p>BeanPostProcessor 处理所有bean 接口 ，可以在其中选择过滤哪些bean</p>
<p>静态工厂方法和实例工厂方法  还可以通过  factory-bean 返回实例</p>
<bean id="car1" class="com.aiguigu.spring.beans.factory.StaticFactory" factory-method="getCar"><br>    <constructor-arg value="audi"></constructor-arg><br>    </bean>

<bean id="carFactory" class="com.aiguigu.spring.beans.factory.InstanceCarFactory"></bean><br>    <bean id="car2" factory-bean="carFactory" factory-method="getCar"><br>        <constructor-arg value="ford"></constructor-arg><br>    </bean>

<p>factory-bean 返回实例<br>实现 FactoryBean 接口，通过 FactoryBean 来配置Bean的实例，class指向FactoryBean的全类名，property配置FactoryBean<br>的属性，但实际返回的实例是 FactoryBean的getObject() 方法返回的实例。</p>
<p>@Component  标识一个受Spring管理的组件<br>@Respository   持久层组件<br>@Service    服务层组件，业务层<br>@Controller   表现层组件</p>
<p><context:component-scan base-package=""> 扫描当前包及其子包下的类<br>resource-pattern=”repository/*.class”  设置只扫描符合条件的类</context:component-scan></p>
<p><component-scan>可以包含若干 exclude-filter include-filter</component-scan></p>
<p><context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository"><br>注意若要使用 <context:include-filter>  则 <context:component-scan> 配置  <use-default-filters="false"></use-default-filters="false"></context:component-scan></context:include-filter></context:exclude-filter></p>
<p>@Autowired<br>@Qualifier(“userRepositoryImpl”) 指定名称</p>
<p>Spring AOP</p>
<ol>
<li>jar包   sopalliance    aspectj.weaver    aop-4.0       aspects-4.0</li>
<li>加入命名空间  aop context  bean<br>3.基于注解的方式   xml中加入  <aop:aspectj-autoproxy><br>把横切关注点的代码抽象到切面的类中，加入@Componet、@Aspect 注解，在方法前加 @Before<br>@Aspect<br>@Component<br>public class LoggingAspect {<br> @Before(“execution(<em> com.atguigu.spring.aop.impl.</em>.*(..))”)<br> public void beforeMethod(JoinPoint joinPoint) {<pre><code>String methodName = joinPoint.getSignature().getName();
List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs());
System.out.println(&quot;The method begins &quot; +args);
</code></pre> }<br>}<br>可以在通知方法中声明一个类型为JoinPoint的参数，就能访问链接细节，如方法名称和参数值<br>@Before 前置通知<br>后置通知中不论执行成功与否，都会打印出来<br>返回通知可以访问到执行方法的执行结果<br>@AfterReturning(value=””,returning=”result”)<br>public void afterReturning(JoinPoint joinPoint,Object result){<br> String methodName = joinPoint.getSignature().getName();<br> System.out.println(methodName+” “ +result);<br>}<br>异常通知，在方法出现异常时，捕获到异常<br>@AfterThrowing(value=””,throwing=”ex”)<br>public void afterThrowing(JoinPoint joinPoint,Exception ex){</aop:aspectj-autoproxy></li>
</ol>
<p>}<br>环绕通知需要携带ProceedingJoinPoint类型的参数，类似于动态代理的全过程，环绕通知必须有返回值，返回值即为目标方法<br>的返回值<br>@Around(“”)<br>public void aroundMethod(ProceedingJoinPoint pjd){<br>    String methodName = pjd.getSignature().getName();<br>    System.out.println(pjd.getArgs());<br>    Object result = pjd.proceed()<br>}<br>指定切面的优先级，值越小优先级越高，添加注解 @Order(1)<br>定义一个方法，用于声明切入点表达式，一般的，该方法不需要添加其他的代码<br>使用@Pointcut 声明切入点表达式<br>@Pointcut(“execution(<em> com.atguigu.spring.aop.impl.</em>.<em>(..))”)<br>    public void declareJoinPoint() {}<br>引用之 @Before(“declareJoinPoint()”)，如果不在一个类，添加类名，类似，不在一个包，添加包名<br>eg:<br>@Pointcut(“execution(</em> com.atguigu.aspect.<em>.</em>(int, int))”)<br>    public void declareJoinPointExpression(){}</p>
<p>@Before(“declareJoinPointExpression()”)<br>    public void beforeMethod(JoinPoint joinPoint) {<br>        String methodName = joinPoint.getSignature().getName();<br>        List<object> args = Arrays.asList(joinPoint.getArgs());<br>        System.out.println(“the method “ + methodName + “ begins with args “</object></p>
<pre><code>            + args);
}
</code></pre><p>如果切点跟引用点不在同一个包里面，需要加上包名<br>eg: @Before(“com.atguigu.spring.aop.LoggingAspect.declareJoinPointExpression()”)</p>
<p>配置的方式配置AOP<br>        <bean id="arithmeticCalculator" class="com.atguigu.spring.aop.impl.ArithmeticCalculatorImpl"></bean><br>        <bean id="loggingAspect" class="com.atguigu.spring.aop.impl.LoggingAspect"></bean><br>        <bean id="validationAspect" class="com.atguigu.spring.aop.impl.ValidationAspect"></bean></p>
<pre><code>&lt;aop:config&gt;
    &lt;aop:pointcut expression=&quot;execution(* com.atguigu.spring.aop.impl.*.*(..))&quot; id=&quot;pointcut&quot;/&gt;
    &lt;aop:aspect ref=&quot;loggingAspect&quot;&gt;
        &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;aop:before method=&quot;afterMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:aspect&gt;
    &lt;aop:aspect ref=&quot;validationAspect&quot;&gt;
        &lt;aop:before method=&quot;validateArgs&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre><p>db.properties<br><!-- 导入资源文件--></p>
<p><context:property-placeholder location="classpath:db.properties"><br><!-- 配置C3p0数据源--><br>    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"><br>        <property name="user" value="${jdbc.user}"></property><br>        <property name="password" value="${jdbc.password}"></property><br>        <property name="driverClass" value="${jdbc.driverClass}"></property><br>        <property name="jdbcUrl" value="${jdbc.jdbcUrl}"></property><br>        <property name="initialPoolSize" value="${jdbc.initPoolSize}"></property><br>        <property name="maxPoolSize" value="${jdbc.maxPoolSize}"></property><br>    </bean></context:property-placeholder></p>
<p>使用jdbcTemplate</p>
<p><context:property-placeholder location="classpath:db.properties"><br>    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"><br>        <property name="user" value="${jdbc.user}"></property><br>        <property name="password" value="${jdbc.password}"></property><br>        <property name="driverClass" value="${jdbc.driverClass}"></property><br>        <property name="jdbcUrl" value="${jdbc.jdbcUrl}"></property><br>        <property name="initialPoolSize" value="${jdbc.initPoolSize}"></property><br>        <property name="maxPoolSize" value="${jdbc.maxPoolSize}"></property><br>    </bean></context:property-placeholder></p>
<pre><code>&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;  // jdbcTemplate需要数据源
&lt;/bean&gt;

&lt;bean id=&quot;namedParameterJdbcTemplate&quot;
    class=&quot;org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate&quot;&gt;
    &lt;constructor-arg ref= &quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><p>public class JDBCTest {<br>    ClassPathXmlApplicationContext ctx =null;<br>    JdbcTemplate jdbcTemplate = null;<br>    private NamedParameterJdbcTemplate namedParameterJdbcTemplate;</p>
<pre><code>{
    ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    jdbcTemplate = (JdbcTemplate) ctx.getBean(&quot;jdbcTemplate&quot;);
    namedParameterJdbcTemplate = (NamedParameterJdbcTemplate) ctx.getBean(&quot;namedParameterJdbcTemplate&quot;);
}

@Test
public void test() throws SQLException {
    DataSource dataSource = (DataSource) ctx.getBean(&quot;dataSource&quot;);
    System.out.println(dataSource.getConnection());
}

@Test
public void testUpdate(){
    String sql = &quot;update course set cname=? where tnum=?&quot;;
    jdbcTemplate.update(sql,&quot;French&quot;,&quot;01&quot;);
}

@Test
public void testBatchUpdate(){
    String sql = &quot;insert into course values(?,?,?)&quot;;
    List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();
    batchArgs.add(new Object[]{&quot;08&quot;,&quot;Chinese&quot;,&quot;02&quot;});
    batchArgs.add(new Object[]{&quot;05&quot;,&quot;French&quot;,&quot;05&quot;});
    batchArgs.add(new Object[]{&quot;06&quot;,&quot;hello&quot;,&quot;03&quot;});
    batchArgs.add(new Object[]{&quot;090&quot;,&quot;English&quot;,&quot;02&quot;});
    jdbcTemplate.batchUpdate(sql, batchArgs);
}
/**
 * 从数据库获取一条记录，实际得到一个对象
 *  BeanPropertyRowMapper&lt;Employee&gt;(Class&lt;Employee&gt; mappedClass)
 *  不是调用 queryForObject(String sql, Class&lt;Employee&gt; requiredType, Object... args)
 *  而是调用  queryForObject(String sql, RowMapper&lt;Employee&gt; rowMapper, Object... args)
 *  1. 其中RowMapper指定如何去映射结果集的行，常用的实现类为BeanPropertyRowMapper
 *  2. 使用SQL中列的别名完成列名和类的属性名的映射
 *  3. 不支持级联属性，不是ORM
 */
@Test
public void testQueryForObject(){
    String sql = &quot;select id,lastname,email from employees where id=?&quot;;
    RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class);
    Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, 1);
    System.out.println(employee);
}
/**
 * 查询结果为集合
 */
@Test
public void testQueryForList(){
    String sql = &quot;select id,lastName,email from employees where id &gt; ?&quot;;
    RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class);
    List&lt;Employee&gt; employees = jdbcTemplate.query(sql, rowMapper,1);
    for (Employee employee : employees) {
        System.out.println(employee);
    }
}

/**
 * 获取单个列的值或统计查询
 */
@Test
public void testQueryForObjectColunmn(){
    String sql = &quot;select count(id) from employees&quot;;
    long count = jdbcTemplate.queryForObject(sql, Long.class);
    System.out.println(count);
}
/**
 * 具名参数 ，可以为参数起名字
 * 1
 */
@Test
public void testNamedParameterJdbcTemplate(){
    String sql = &quot;insert into employees values(:id,:lastname,:email)&quot;;
    Map&lt;String,Object&gt; paramMap = new HashMap&lt;&gt;();
    paramMap.put(&quot;id&quot;,99);
    paramMap.put(&quot;lastname&quot;,&quot;hello&quot;);
    paramMap.put(&quot;email&quot;,&quot;yu@163.com&quot;);
    namedParameterJdbcTemplate.update(sql, paramMap);
}

@Test
public void testNamedParameterJdbcTemplate2(){
    // values里面的字段名称跟实体类字段一致（大小写）
    String sql = &quot;insert into employees values(:id,:lastName,:email)&quot;;
    Employee employee = new Employee();
    employee.setLastName(&quot;xyz&quot;);
    employee.setEmail(&quot;yu@163.com&quot;);
    employee.setId(96);
    BeanPropertySqlParameterSource paramSource = new BeanPropertySqlParameterSource(employee);
    namedParameterJdbcTemplate.update(sql, paramSource);
}
</code></pre><p>}</p>
<p>spring的声明式事务</p>
<ol>
<li><!-- 配置事务管理器 -->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"><br>  <property name="dataSource" ref="dataSource"></property><br></bean>
</li>
<li><!-- 启用事务注解 -->
<tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven></li>
<li><p>对应的方法上添加@Transactional注解<br> @Transactional<br> @Override<br> public void purchase(String userName, String isbn) {</p>
<pre><code>// 1. 获取书的单价
int price  = bookShopDao.findBookPriceByIsbn(isbn);
// 2. 更新书的库存
bookShopDao.updateBookStock(isbn);
// 3. 更新用户余额
bookShopDao.updateUserAccount(userName, price);
</code></pre><p> }</p>
</li>
</ol>
<p>Spring 支持的事务传播行为<br>REQUIRED  如果有事务在运行，当前的方法在这个事务内运行，否则就启动一个新的事务，并在自己的事务内运行。买两本书不够，买一本够，两本都买不了<br>REQUIRED_NEW  当前的方法必须启动新事务，并在它自己的事务内运行，如果有事务正在运行，应该将它挂起。买两本书不够，买一本够，可以买一本<br>使用 propagetion指定事务的传播行为<br>eg: @Transactional(propagation=Propagation.REQUIRED) // 事务的默认行为</p>
<p>事务的隔离级别<br>isolation=Isolation.READ_COMMITTED 读已提交<br>默认情况下，Spring 的声明式事务对所有的运行时异常进行回滚<br>使用 readOnly指定事务是否只读，表示这个事务只读取数据不更新数据，有利于数据库引擎优化事务<br>使用timeout指定强制回滚之前事务可以占用的时间</p>
</beans></constructor-arg></context:property-placeholder></bean></bean>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[spring笔记]]></title>
      <url>http://yoursite.com/2016/06/09/spring%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>spring构造注入<br>public class Dog implements Animal{</p>
<pre><code>@Override
public void eat() {
    System.out.println(&quot;dog eat&quot;);
}
</code></pre><p>}</p>
<p>public class Person {<br>    private Dog dog;</p>
<pre><code>public Person(Dog dog) {
    this.dog = dog;
}

public void sayEat() {
    dog.eat();
}
</code></pre><p>}<br>每个<bean...> 元素默认驱动Spring调用 <strong>该类无参数的构造器</strong> 来创建实例，并将该实例作为Spring容器中的Bean</bean...></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<beans><br>    <!--  <property/> 元素的name属性值决定执行哪个setter方法，
    value（基本类型/包装类）或ref（引用类型）决定执行setter方法的传入参数 --><br>    <!-- constructor-arg 元素代表一个构造器参数，如果包含N个元素，则调用带N个参数的构造器创建对象 --><br>    <bean id="person" class="com.bean.Person"><br>        <constructor-arg ref="dog"></constructor-arg><br>    </bean><br>    <bean id="dog" class="com.bean.Dog"></bean><br></beans>

<p>public class Test {<br>    public static void main(String[] args) {<br>        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(“spring.xml”);<br>        Person p = (Person) ctx.getBean(“person”);<br>        p.sayEat();<br>    }<br>}</p>
<p>若要改为设值注入<br>spring.xml改为property方式<br><!--  <property/> 元素的name属性值决定执行哪个setter方法，
    value（基本类型/包装类）或ref（引用类型）决定执行setter方法的传入参数 --></p>
<p><bean id="person" class="com.bean.Person"><br>        <property name="dog" ref="dog"></property><br>    </bean><br>Person.java去掉构造方法，加set方法<br>public void setDog(Dog dog){<br>        this.dog = dog;<br>    }</p>
<p>bean配置项<br>id class  scope   Constructor arguments    Properties   Autowiring mode<br>lazy-initialization mode   Initialization/destruction method<br>配置单例</p>
<bean id="beanScope" class="com.scope.BeanScope" scope="singleton">

<p>A对象需要调用B对象方法的情形，被Spring成为依赖。即A对象依赖B对象。<br>设值注入</p>
<p><property name="axe" ref="axe"></property><br>构造注入</p>
<p><constructor-arg ref="axe"></constructor-arg><br>建议采用设值注入为主，构造方法为辅的注入策略。对于依赖关系无需变化的注入，尽量采用构造注入；而其他依赖关系的注入，则考虑采用设值注入</p>
<p><constructor-arg...> 元素可以指定index属性，用于指定该构造参数值将作为第几个构造参数值。index=”0” 表明该构造参数值将作为第一个构造参数值<br>为了更明确的指定数据类型，Spring允许为<constructor-arg...> 指定一个type属性 eg<constructor-arg value="23" type="int"><br>如果需要加载多个佩文文件来创建Spring 容器 ，则应该采用BeanFactory的子接口ApplicationContext<br>ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(“spring.xml”,”second.xml”);<br>当系统创建ApplicationContext 容器时，默认会预初始化所有的singleton Bean,包括调用构造器创建该Bean的实例，并根据<property>元素执行setter方法。<br>为了阻止Spring容器初始化容器中的single bean,可以为<bean>元素指定lazy-init=”true”,阻止容器预初始化该bean</bean></property></constructor-arg></constructor-arg...></constructor-arg...></p>
<p>ApplicationContext的事件机制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class EmailEvent extends ApplicationEvent</div><div class="line"></div><div class="line">public class EmailNotifier implements ApplicationListener &#123;</div><div class="line">	@Override</div><div class="line">	public void onApplicationEvent(ApplicationEvent event) &#123;</div><div class="line">		if(event instanceof EmailEvent)&#123;</div><div class="line">			EmailEvent emailEvent = (EmailEvent) event;</div><div class="line">			System.out.println(&quot;receive address &quot;+emailEvent.getAddress());</div><div class="line">			System.out.println(&quot;content is  &quot;+emailEvent.getText());</div><div class="line"></div><div class="line">		&#125;else&#123;</div><div class="line">			System.out.println(&quot;other event: &quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">测试代码</div><div class="line">ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);</div><div class="line">		EmailEvent emailEvent = new EmailEvent(&quot;test&quot;, &quot;spring@163.com&quot;, &quot;this is a test&quot;);</div><div class="line">		ctx.publishEvent(emailEvent);</div><div class="line">输出</div><div class="line">other event:</div><div class="line">receive address spring@163.com</div><div class="line">content is  this is a test</div></pre></td></tr></table></figure></p>
<p>让bean获取spring容器<br>private ApplicationContext ctx;<br>实现 ApplicationContextAware 接口 ，覆写 public void setApplicationContext(ApplicationContext ctx){<br>    this.ctx = ctx;<br>}<br>当spring容器创建该bean后，自动调用该方法时，它会把自身作为参数传入该方法。</p>
<p>Bean 的基本定义和Bean别名</p>
<beans...> 可以指定如下属性<br>default-lazy-init  指定该beans元素下配置的所有Bean默认的延迟初始化行为<br>default-merge   指定所有Bean默认的merge行为<br>default-autowire  指定所有Bean默认的自动装配行为<br>default-autowire-candidates: 指定所有Bean默认是否作为自动装配的候选Bean<br>default-init-method: 指定所有Bean默认的初始化方法<br>default-destroy-method: 所有Bean默认的回收方法<br><br><beans>元素所能指定的属性都可以在每个<bean> 子元素中指定。当二者所指定的属性不一致时，<bean>会覆盖<beans>指定的属性<br>构造注入就是通过<constructor-arg...> 驱动Spring执行有参数的构造器；设值注入就是通过<property...> 驱动Spring执行setter方法<br><br>注入集合值<br>java代码 如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Chinese &#123;</div><div class="line">	private List&lt;String&gt; schools;</div><div class="line">	private Map scores;</div><div class="line">	private Map&lt;String,Axe&gt; phaseAxes;</div><div class="line">	private Properties health;</div><div class="line">	private Set axes;</div><div class="line">	private String[] books;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>spring.xml 如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">	&lt;bean id=&quot;chinese&quot; class=&quot;com.yuchuan.Chinese&quot;&gt;</div><div class="line">		 &lt;property name=&quot;schools&quot;&gt;</div><div class="line">		 	&lt;list&gt;</div><div class="line">		 		&lt;value&gt;small&lt;/value&gt;</div><div class="line">		 		&lt;value&gt;medium&lt;/value&gt;</div><div class="line">		 		&lt;value&gt;big&lt;/value&gt;</div><div class="line">		 	&lt;/list&gt;</div><div class="line">		 &lt;/property&gt;</div><div class="line">		 &lt;property name=&quot;scores&quot;&gt;</div><div class="line">		 	&lt;map&gt;</div><div class="line">		 		&lt;entry key=&quot;math&quot; value=&quot;8&quot;&gt;&lt;/entry&gt;</div><div class="line">		 		&lt;entry key=&quot;english&quot; value=&quot;8&quot;&gt;&lt;/entry&gt;</div><div class="line">		 		&lt;entry key=&quot;chinese&quot; value=&quot;8&quot;&gt;&lt;/entry&gt;</div><div class="line">		 	&lt;/map&gt;</div><div class="line">		 &lt;/property&gt;</div><div class="line"></div><div class="line">		 &lt;property name=&quot;phaseAxes&quot;&gt;</div><div class="line">		 	&lt;map&gt;</div><div class="line">		 		&lt;entry key=&quot;origin&quot; value-ref=&quot;stoneAxe&quot;&gt;&lt;/entry&gt;</div><div class="line">		 		&lt;entry key=&quot;modern&quot; value-ref=&quot;stealAxe&quot;&gt;&lt;/entry&gt;</div><div class="line">		 	&lt;/map&gt;</div><div class="line">		 &lt;/property&gt;</div><div class="line">		 &lt;property name=&quot;health&quot;&gt;</div><div class="line">		 	&lt;props&gt;</div><div class="line">		 		&lt;prop key=&quot;AA&quot;&gt;normal&lt;/prop&gt;</div><div class="line">		 		&lt;prop key=&quot;BB&quot;&gt;175&lt;/prop&gt;</div><div class="line">		 	&lt;/props&gt;</div><div class="line">		 &lt;/property&gt;</div><div class="line">		 &lt;property name=&quot;axes&quot;&gt;</div><div class="line">		 	&lt;set&gt;</div><div class="line">		 		&lt;value&gt;普通字符串&lt;/value&gt;</div><div class="line">		 		&lt;bean class=&quot;com.yuchuan.StoneAxe&quot;&gt;&lt;/bean&gt;</div><div class="line">		 		&lt;ref bean=&quot;stoneAxe&quot;/&gt;</div><div class="line">		 		&lt;ref bean=&quot;stealAxe&quot; /&gt;</div><div class="line">		 		&lt;list&gt;</div><div class="line">		 			&lt;set&gt;</div><div class="line">		 				&lt;value type=&quot;int&quot;&gt;30&lt;/value&gt;</div><div class="line">		 			&lt;/set&gt;</div><div class="line">		 		&lt;/list&gt;</div><div class="line">		 	&lt;/set&gt;</div><div class="line"></div><div class="line">		 &lt;/property&gt;</div><div class="line">		 &lt;property name=&quot;books&quot;&gt;</div><div class="line">		 	&lt;list&gt;</div><div class="line">		 		&lt;value&gt;java&lt;/value&gt;</div><div class="line">		 		&lt;value&gt;C++&lt;/value&gt;</div><div class="line">		 		&lt;value&gt;python&lt;/value&gt;</div><div class="line">		 	&lt;/list&gt;</div><div class="line">		 &lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	&lt;bean id=&quot;stoneAxe&quot; class=&quot;com.yuchuan.StoneAxe&quot;&gt;&lt;/bean&gt;</div><div class="line">	&lt;bean id=&quot;stealAxe&quot; class=&quot;com.yuchuan.StoneAxe&quot;&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure><br><br>说明：<br>value 指定集合元素是基本类型或字符串类型<br>ref  集合元素是容器中的另一个bean实例<br>bean  指定集合元素是一个嵌套bean<br>list、set、map 指定集合<br>key-ref  如果map key 是容器中的另一个bean实例，则可使用该属性指定容器中其他bean的id<br>value-ref  如果map value是容器中的另一个bean实例，则可使用该属性指定容器中其他bean的id<br>数组和list用法一样<br><br>建议Spring中的bean应满足如下原则：<br>1. 尽量为每个bean实现类提供无参数的构造器<br>2. 接受构造注入的bean，则应提供对应的、带参数的构造函数<br>3. 接受设值注入的bean，则应提供对应的setter方法，并不要求提供对应的getter方法<br><br>spring提供两种方式在bean全部属性设置成功后执行特定行为：<br>1. 使用init-method属性<br>2. 实现InitializingBean 接口。覆写 afterPropertiesSet()方法<br>如果同时采用这两种方法，则先执行 InitializingBean 接口中定义的方法，然后执行init-method 方法<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class China implements Person, InitializingBean, BeanNameAware, ApplicationContextAware &#123;</div><div class="line">	private Axe axe;</div><div class="line"></div><div class="line">	public void setAxe(Axe axe)&#123;</div><div class="line">		System.out.println(&quot;axe setter...&quot;);</div><div class="line">		this.axe = axe;</div><div class="line">	&#125;</div><div class="line">	public China()&#123;</div><div class="line">		System.out.println(&quot;china构造方法&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</div><div class="line">		System.out.println(&quot;====setApplicationContext===&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void setBeanName(String name) &#123;</div><div class="line">		System.out.println(&quot;====setBeanName====&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void afterPropertiesSet() throws Exception &#123;</div><div class="line">		System.out.println(&quot;afterPropertiesSet&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void useAxe() &#123;</div><div class="line">		System.out.println(axe.chop());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void init()&#123;</div><div class="line">		System.out.println(&quot;init...&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">xml配置　　</div><div class="line">	&lt;bean id=&quot;china&quot; class=&quot;com.yuchuan.China&quot;</div><div class="line">		init-method=&quot;init&quot;&gt;</div><div class="line">		&lt;property name=&quot;axe&quot; ref=&quot;stoneAxe&quot;&gt;&lt;/property&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	&lt;bean id=&quot;stoneAxe&quot; class=&quot;com.yuchuan.StoneAxe&quot;&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">输出：</div><div class="line">china构造方法</div><div class="line">axe setter...</div><div class="line">====setBeanName====</div><div class="line">====setApplicationContext===</div><div class="line">afterPropertiesSet</div><div class="line">init...</div><div class="line">axe...</div></pre></td></tr></table></figure><br><br>Spring 也提供两种方式定制Bean实例销毁之前的特定行为<br>1. 使用destroy-method方法<br>2. 实现DisposableBean接口，覆写destroy()方法<br><br>协调作用于不同步的Bean<br>当singleton作用域的Bean依赖于prototype作用域的Bean时，会产生不同步的现象<br>public abstract class Chinese {<br>    private Dog dog;<br>    public abstract Dog getDog();<br>    public void hunt(){<br>        System.out.println(“我带着” + getDog());<br>        System.out.println(getDog().run());<br>    }<br>}<br>定义了一个抽象的getDog()方法，通常情况下，程序不能调用这个抽象方法，程序也不能使用抽象类创建实例。<br>接下来需要在配置文件中为<bean...>元素添加<lookup-method...> 子元素，<lookup-method...> 子元素告诉Spring需要实现哪些抽象方法。Spring 为抽象方法提供实现体之后，这个方法就会变成具体方法，这个类就变成了具体类，接下来Spring就可以创建该Bean的实例了。<br><lookup-method...> 中的name属性 指定需要让Spring实现的方法。 bean属性 指定Spring实现该方法的返回值<br>    <bean id="chinese" class="com.yuchuan.Chinese"><br>        <lookup-method name="getDog" bean="gunDog"><br>    </lookup-method></bean><br>    <bean id="gunDog" class="com.yuchuan.Dog" scope="prototype"><br>        <property name="name" value="旺财"></property><br>    </bean><br>    指定Spring应该负责实现getDog()方法，该方法的返回值是容器中的gundog实例<br>Test<br>Chinese p = ctx.getBean(“chinese”,Chinese.class);<br>p.hunt();<br>Chinese p2 = ctx.getBean(“chinese”,Chinese.class);<br>p2.hunt();<br><br>输出：<br>我带着com.yuchuan.Dog@47c3666a<br>旺财 run<br>我带着com.yuchuan.Dog@6d78ddf4<br>旺财 run<br><br>基于XML Schema 的简化配置方式<br>使用P命名空间，C 命名空间简化配置<br><bean id="per" class="com.yuchuan.Per" p:age="29" p:axe-ref="stoneAxe"></bean><br><bean id="per2" class="com.yuchuan.Per" c:axe-ref="stoneAxe" c:age="29"></bean><br><bean id="stoneAxe" class="com.yuchuan.StoneAxe"></bean><br>以上是同时配置使用构造方法和setter方法，注意要加入无参构造方法，才能使得setter方法设置注入和构造器注入共存<br>Spring 还支持一种通过索引来配置构造器参数的方式，上面Bean也可以写为如下形式：<br><bean id="per" class="com.yuchuan.Per" c:_0-ref="stoneAxe" c:_1="29"><br><br><br><br>Bean的生命周期<br>方案一：Bean开始和销毁前执行的方法<br><bean id="beanLifeCycle" class="com.life.BeanLifeCycle" init-method="start" destroy-method="stop"><br>public class BeanLifeCycle {<br>    public void start(){<br>        System.out.println(“bean start”);<br>    }<br><br>    public void stop(){<br>        System.out.println(“bean stop”);<br>    }<br>}<br><br>方案二：实现两个接口<br>spring.xml<br><bean id="beanLifeCycle" class="com.life.BeanLifeCycle"><br><br>public class BeanLifeCycle implements InitializingBean,DisposableBean{<br><br>    @Override<br>    public void destroy() throws Exception {<br>        System.out.println(“bean destroy2”);<br>    }<br><br>    @Override<br>    public void afterPropertiesSet() throws Exception {<br>        System.out.println(“bean start2”);<br><br>    }<br>}<br><br>DI是一种IOC的实现方式<br>容器负责创建对象，组装对象之间的关系<br>获得对象的过程被反转了<br><br>spring中提供了一些以Aware结尾的接口，实现了Aware接口的bean在被初始化之后，可以获取相应资源<br>为对spring进行简单的扩展提供了方便入口<br>ApplicationContextAware : 向实现了该接口的bean提供上下文信息<br>ApplicationEventPublisherAware :<br>BeanClassLoaderAware<br>BeanFactoryAware<br>BootstrapContextAware<br>LoadTimeWeaverAware<br>BeanNameAware ：<br>MessaageSourceAware<br>NotificationPublisherAware<br>PortletConfigAware<br>PortletContextAware<br>ResourceLoaderAware<br>ServletConfigAware<br>ServletContextAware<br><br>public class MoocApplicationContext implements ApplicationContextAware{<br><br>    private ApplicationContext applicationContext;<br>    @Override<br>    public void setApplicationContext(ApplicationContext applicationContext)<br>            throws BeansException {<br>        this.applicationContext = applicationContext;<br>        System.out.println(applicationContext.getBean(“moocApplicationContext”).hashCode());<br>    }<br><br>}<br><br>public class MoocBeanName implements BeanNameAware,ApplicationContextAware{<br><br>    private String beanName;<br><br>    @Override<br>    public void setBeanName(String name) {<br>        this.beanName = name;<br>        System.out.println(name);<br><br>    }<br><br>    @Override<br>    public void setApplicationContext(ApplicationContext applicationContext)<br>            throws BeansException {<br>        System.out.println(applicationContext.getBean(beanName));<br>    }<br><br>}<br><br>@Test<br>    public void test() {<br>        System.out.println(super.getBean(“moocBeanName”));<br>    }<br>输出 ==&gt;<br>moocBeanName<br>// 得到上下文applicationContext 引用，所以两个对象一样<br>com.aware.MoocBeanName@64bb8a39<br>com.aware.MoocBeanName@64bb8a39<br><br>Resource 用法<br>public class MoocResource implements ApplicationContextAware{<br><br>    private ApplicationContext context;<br>    @Override<br>    public void setApplicationContext(ApplicationContext context)<br>            throws BeansException {<br>        this.context = context;<br>    }<br><br>    public void resource() throws IOException{<br>        Resource resource = context.getResource(“file:C:\Users\chuan\workspace\packTest\src\spring.xml”);<br>        System.out.println(resource.getFilename());<br>        System.out.println(resource.contentLength());<br><br>    }<br>}<br>测试类<br>public void test() {<br>        MoocResource resource = super.getBean(“moocResource”);<br>        try {<br>            resource.resource();<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br><br><strong> Spring 可以自动检测类并注册Bean到ApplicationContext中 </strong><br><br>为了能够检测这些类并注册相应的Bean<br><context:component-scan base-package="org.exam"><br>component-scan包含了 annotation-config<br><br>类被自动发现并注册bean的条件是：使用@Component,@Repository,@Service，@Controller 注解或者使用@Component的自定义注解<br>可以通过过滤器修改上面的行为<br><beans><br>    <context:component-scan base-package="org.exam"><br>        <context:include-filter type="regex" expression=".*Stub.*Repository"><br>        <context:exclude-filter type="annotation" expression="org.stereotype.Repository"><br>    </context:exclude-filter></context:include-filter></context:component-scan><br></beans><br>自动查找的组件，scope是单例的<br><br>@scope(“prototype”)<br>@Repository<br>public class MovieFinderImpl implements MovieFinder(){<br><br>}<br>自定义scope，使用ScopeMetadataResolver接口并提供一个无参构造器<br><br>@Component   // 可以自定义 @Componet(“bean”) 在获取的时候使用该名称<br>public class BeanAnnotation {<br>    public void say(String arg){<br>        System.out.println(“BeanAnnotation : “+arg);<br>    }<br>}<br><br><context:component-scan base-package="com.res"></context:component-scan><br><br>BeanAnnotation bean =   super.getBean(“beanAnnotation”);  // 未指定名称，默认首字母小写<br><br>@Required 注解适用于bean属性的setter方法<br>这个注解仅仅表示，受影响的bean属性必须在配置时被填充，通过在bean定义或通过自动装配一个明确的属性值<br>@Autowired 范围更广，可以用在构造器或setter方法上<br>默认情况下，如果因找不到合适的bean将会导致autowired失败抛出异常，  @autowired(required=false)<br>每个类只能有一个构造器被标记为 required=true<br>@Autowired 的必要属性，建议使用@Required 注解<br><br>case: 使用注解 @Autowired<br>spring.xml<br><context:component-scan base-package="com.res"></context:component-scan><br><br>@Service<br>public class InjectServiceImpl implements InjectService{<br>    @Autowired<br>    private InjectDao injectDaoImpl;<br><br>    @Override<br>    public void save() {<br>        System.out.println(“service save”);<br>        injectDaoImpl.save();<br>    }<br><br>}<br><br>@Repository<br>public class InjectDaoImpl implements InjectDao{<br><br>    @Override<br>    public void save() {<br>        System.out.println(“injectDaoImpl save…”);<br>    }<br><br>}<br><br>@Test<br>    public void test() {<br>        InjectService bean =   super.getBean(“injectServiceImpl”);<br>        bean.save();<br>    }<br><br>换成设值注入<br>// @Autowired<br>    private InjectDao injectDaoImpl;<br>    @Autowired<br>    public void setInjectDaoImpl(InjectDao injectDaoImpl) {<br>        this.injectDaoImpl = injectDaoImpl;<br>    }<br><br>换成构造器注入<br>// @Autowired<br>    private InjectDao injectDaoImpl;<br>    // @Autowired<br>    public void setInjectDaoImpl(InjectDao injectDaoImpl) {<br>        this.injectDaoImpl = injectDaoImpl;<br>    }<br>    @Autowired<br>    public InjectServiceImpl(InjectDao injectDaoImpl){<br>        this.injectDaoImpl = injectDaoImpl;<br>    }<br><br>可以使用@Autowired 注解那些中所周知的解析依赖性接口，比如BeanFactory,ApplicationContext,Environment,ResourceLoader,ApplicationEventPublisher ,MessageSource<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-12/41292963.jpg" alt=""><br>@Autowired 是由 Spring BeanPostProcessor 处理的，所以不能在自己的BeanPostProcessor或BeanFactoryPostProcessor类型应用这些注解，这些类型必须通过XML或Spring的@Bean注解<br><br>@Order(value=1)  // 指定放入顺序<br>@Component<br>public class BeanImplOne implements BeanInterface {<br><br>}<br><br>@Order(value=2)<br>@Component<br>public class BeanImplTwo implements BeanInterface{<br><br>}<br><br>@Component<br>public class BeanInvoker {<br>    @Autowired<br>    private List<beaninterface> list;<br>    @Autowired<br>    private Map<string,beaninterface> map;<br><br>    public void say(){<br>        if(null != list){<br>            for (BeanInterface beanInterface : list) {<br>                System.out.println(beanInterface.getClass().getName());<br>            }<br>        }else{<br>            System.out.println(“null”);<br>        }<br><br>        if(null != map){<br>            for(Map.Entry<string,beaninterface> entry:map.entrySet()){<br>                System.out.println(entry.getValue().getClass().getName());<br>            }<br>        }<br>    }<br>}<br><br>测试<br>@Test<br>    public void test() {<br>        BeanInvoker bir = super.getBean(“beanInvoker”);<br>        bir.say();<br>    }<br><br><br>基于java容器注解<br>spring.xml<br><context:component-scan base-package="com.res"></context:component-scan><br><br>public class StringStore implements Store{<br>    public void init(){<br>        System.out.println(“this is init”);<br><br>    }<br><br>    public void stop(){<br>        System.out.println(“this is stop”);<br>    }<br>}<br><br><br>@Configuration<br>public class StoreConfig {<br><br>    @Bean(name = “store”,initMethod=”init”,destroyMethod=”stop”)<br>    public Store getStringStore(){<br>        return new StringStore();<br>    }<br>}<br><br>public class TestStore extends UnitTestBase{<br>    public TestStore(){<br>        super(“spring.xml”);<br>    }<br><br>    @Test<br>    public void test() {<br>        Store st = super.getBean(“store”);<br>        System.out.println(st.getClass().getName());<br>    }<br>}<br><br>使用@ImportResource 和 @Value 注解进行资源文件读取<br>@Configuration<br>@ImportResource(“classpath:/com/acme/properties-config.xml”)<br>public class AppConfig{<br>    @Value(“${jdbc.url}”)<br>    private String url;<br>    @Value(“${jdbc.username}”)<br>    private String username;<br>    @Value(“${jdbc.password”)<br>    private String password;<br>    @Bean<br>    public DataSource dataSource(){<br>        return new DriverManagerDataSource(url,username,password);<br>    }<br>}<br>————————————–<br>case :<br>spring.xml<br><context:component-scan base-package="com.imooc"></context:component-scan><br><br>public class MyDriverManager {<br>    public MyDriverManager(String url,String username,String password){<br>        System.out.println(“url “+url);<br>        System.out.println(“username “+username);<br>        System.out.println(“password “+password);<br>    }<br>}<br><br>– config.xml<br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemalocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-2.5.xsd
           http://www.springframework.org/schema/aop
           http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
           "><br>    <context:property-placeholder location="classpath:/config.properties"><br></context:property-placeholder></beans>

<p>config.properties<br>password = root<br>username = root<br>url = 127.0.0.1</p>
<p>StoreConfig<br>@Configuration<br>@ImportResource(“classpath:config.xml”)<br>public class StoreConfig {<br>    @Value(“${url}”)<br>    private String url;</p>
<pre><code>@Value(&quot;${username}&quot;)
private String username;

@Value(&quot;${password}&quot;)
private String password;

@Bean(name=&quot;mydriver&quot;)
public MyDriverManager myDriverManager(){
    return new MyDriverManager(url, username, password);
}
</code></pre><p>}</p>
<p>public class TestStore extends UnitTestBase{<br>    public TestStore(){<br>        super(“spring.xml”);<br>    }</p>
<pre><code>@Test
public void test() {
    MyDriverManager mydriver = super.getBean(&quot;mydriver&quot;);
    System.out.println(mydriver.getClass().getName());
}
</code></pre><p>}</p>
<hr>
<p>Bean 的作用于包括 singleton,prototype,request,session,global session<br>配置@Scope</p>
<pre><code>@Bean(name=&quot;store&quot;)
@Scope(value=&quot;prototype&quot;)
public Store getStringStore(){
    return new StringStore();
}
</code></pre><hr>
<p>基于泛型的自动装配<br>public interface Store<t> {</t></p>
<p>}</p>
<p>public class IntegerStore implements Store<integer>{<br>    // 此类实现泛型接口<br>}</integer></p>
<p>public class StringStore implements Store<string>{<br>    // 此类实现泛型接口<br>}</string></p>
<p>@Configuration<br>public class StoreConfig {<br>    // 自动装配，s1对应  return new StringStore()<br>    // 自动装配，S2对应  return new IntegerStore()<br>    @Autowired<br>    private Store<string> s1;<br>    @Autowired<br>    private Store<integer> s2;</integer></string></p>
<pre><code>@Bean
public StringStore getStringStore(){
    return new StringStore();
}

@Bean
public IntegerStore getIntegerStore(){
    return new IntegerStore();
}
// 此处返回不能为StirngStore或者IntegerStore,因为会造成冲突，
// 使得自动装配不能正确识别s1和s2
@Bean(name=&quot;stringStoreTest&quot;)
public Store stringStoreTest(){
    System.out.println(&quot;s1 &quot;+s1.getClass().getName());
    System.out.println(&quot;s2 &quot;+s2.getClass().getName());
    return new StringStore();
}
</code></pre><p>}</p>
<p>AOP : Aspect Oriented Programming 面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术<br>主要功能是：日志记录、性能统计、安全控制、事务处理、异常处理<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-13/33879222.jpg" alt="AOP相关概念"><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-13/15887480.jpg" alt=""></p>
<p>提供了声明式的企业服务，特别是EJB的替代服务的声明<br>允许用户定制自己的方面，以完成OOP与AOP的互补使用<br>Spring AOP 侧重于提供一种AOP实现和Spring IOC 容器之间的整合，用于帮助企业应用中的常见问题<br>Spring AOP 默认使用标准的JavaSE动态代理作为AOP代理，这使得任何接口都可以被代理<br>Spring AOP 中可以使用CGLIB代理</p>
<p>Spring 所有的切面和通知器都必须放在一个<aop:config>内（可以配置包含多个<aop:config>元素）每一个<aop:config>可以包含pointcut,advisor和aspect元素（必须按照这个顺序进行声明）</aop:config></aop:config></aop:config></p>
<p><aop:config> 风格大量使用了Spring的自动代理机制<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-13/51529359.jpg" alt=""><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-13/27499441.jpg" alt=""><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-13/18386608.jpg" alt=""><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-13/73688262.jpg" alt=""></aop:config></p>
<p>[Maven]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;4.11&lt;/version&gt;</div><div class="line">      &lt;scope&gt;test&lt;/scope&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">    	&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</div><div class="line">    	&lt;artifactId&gt;servlet-api&lt;/artifactId&gt;</div><div class="line">    	&lt;version&gt;3.0-alpha-1&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">  &lt;/dependencies&gt;</div></pre></td></tr></table></figure></p>
<p>Bean 后处理器会在Bean实例创建成功之后，对Bean实例进一步的增强处理<br>Spring 容器负责把各Bean创建出来，Bean 后处理器可以依次对每个Bean进行某种修改、增强，从而可以对容器中的Bean集中增加某种功能<br>@Component @Controller @Service @Repository</p>
<p>指定Bean的作用域<br>@Scope(“prototype”)<br>@Component<br>public class SteelAxe{ }</p>
<p>使用@Resource 配置依赖，与<property...> 元素的ref属性有相同的效果<br>@Component<br>public class Chinese{<br>    private Axe axe;<br>    @Resource(name=”stoneAxe”)<br>    public void setAxe(Axe axe){<br>        this.axe = axe;<br>    }<br>}<br>@Resource 不仅可以修饰setter方法，还可以修饰变量<br>@Resource(name=”stoneAxe”)<br>private Axe axe</property...></p>
<p>Spring 3.0 新增 @DependsOn({“steelAxe”,”abc”})  初始化之前，会强制初始化steelAxe,abc两个Bean<br>@Lazy(true) 指定当Spring容器初始化时，不会预初始化之</p>
<p>当使用@Autowired 标注setter方法时，默认采用byType自动装配策略<br>Spring4.0 @Autowired 可以根据泛型进行自动装配</p>
</string,beaninterface></string,beaninterface></beaninterface></context:component-scan></bean></bean></bean></lookup-method...></lookup-method...></lookup-method...></bean...></property...></constructor-arg...></beans></bean></bean></beans></beans...></bean>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[shadowSocks安装]]></title>
      <url>http://yoursite.com/2016/06/09/shadowSocks%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<ol>
<li>创建秘钥<br>其中private部分存储在你的设备本地，而public部分则需要上传到远程设备上</li>
</ol>
<p>ssh-keygen -t rsa -C “yuchuan512@163.com”  添加密钥</p>
<ol>
<li>安装shadowsocks<br>首先是安装一些必要的组件：在服务端输入以下指令：<br>yum install m2crypto python-setuptools<br>easy_install pip<br>pip install shadowsocks</li>
</ol>
<p>建立配置文件<br>/etc/shadowsocks.json<br>{<br>“server”:”2604:a880:1:20::74f:8001”,<br>“server_port”:”8388”,<br>“local_address”:”127.0.0.1”,<br>“local_port”:”1080”,<br>“password”:”yuchuan78”,<br>“method”:”aes-256-cfb”,<br>“fast_open”:”false”,<br>“workers”:”1”<br>}</p>
<p>启动SS<br>ssserver -c /etc/shadowsocks.json</p>
<h3 id="后台运行shadowsocks"><a href="#后台运行shadowsocks" class="headerlink" title="后台运行shadowsocks"></a>后台运行shadowsocks</h3><p>如果你想在后台运行 Shadowsocks，可以使用 supervisor<br><img src="https://github.com/clowwindy/shadowsocks/wiki/%E7%94%A8-Supervisor-%E8%BF%90%E8%A1%8C-Shadowsocks/a3a5d48dbe0e82a7b9b0836c3678230c8be457bd" alt="后台运行 "><br>echo_supervisord_conf &gt; /etc/supervisord.conf</p>
<p>编辑配置文件supervisord.conf，在后面添加</p>
<p>[program:shadowsocks]<br>command=ssserver -c /etc/shadowsocks.json<br>autostart=true<br>autorestart=true<br>user=nobody</p>
<p>启动<br>默认路径配置启动：supervisord<br>指定路径配置启动：supervisord -c “指定路径”/supervisord.conf</p>
<p>常用命令<br>获得所有程序状态 supervisorctl status<br>关闭目标程序 supervisorctl stop ssserver[shadowsocks]<br>启动目标程序 supervisorctl start ssserver[shadowsocks]<br>关闭所有程序 supervisorctl shutdown</p>
<p>可以检查日志或者控制 Shadowsocks 的运行：<br>supervisorctl tail -f shadowsocks stderr<br>supervisorctl restart shadowsocks</p>
<h3 id="finalspeed"><a href="#finalspeed" class="headerlink" title="finalspeed"></a>finalspeed</h3><p>一键安装之后<br>chmod+  +X /etc/rc.local 编辑 /etc/rc.loal ，加入 /fs/start.sh<br>设置定时重启，防止撑破内存<br>crontab -e 加入<br>0 1 <em> </em> * sh /fs/restart.sh，定时凌晨1点重启释放缓存<br>常用命令<br>启动   sh /fs/start.sh<br>停止   sh /fs/stop.sh<br>重启   sh /fs/restart.sh<br>卸载   sh /fs/stop.sh   rm -fr /fs<br>默认会占用150端口，若端口已经被占用，需重新指定端口<br>mkdir -p /fs/cnf; echo 端口号 &gt; /fs/cnf/listen_port; sh /fs/restart.sh<br>查看日志文件   tail -f  /fs/server.log</p>
<p><strong> 若出现端口8388连接不上，则把shadowsocks.json中的 server改为 “0.0.0.0” </strong></p>
<h3 id="Chrome工具"><a href="#Chrome工具" class="headerlink" title="Chrome工具"></a>Chrome工具</h3><p>SwitchyOmega.crx  自由切换<br>OmegaOptions.bak  规则备份</p>
<p>使用Proxifier设置全局代理</p>
<h3 id="安装Pip"><a href="#安装Pip" class="headerlink" title="安装Pip"></a>安装Pip</h3><p>Centos 下载编译安装 pip<br>wget –no-check-certificate <a href="https://github.com/pypa/pip/archive/1.5.5.tar.gz" target="_blank" rel="external">https://github.com/pypa/pip/archive/1.5.5.tar.gz</a><br>tar zvxf 1.5.5.tar.gz    #解压文件<br>cd pip-1.5.5/<br>python setup.py install</p>
<h3 id="升级python"><a href="#升级python" class="headerlink" title="升级python"></a>升级python</h3><p><a href="https://www.python.org/ftp/python/3.4/Python-3.4.tar.bz2" target="_blank" rel="external">https://www.python.org/ftp/python/3.4/Python-3.4.tar.bz2</a><br>解压<br>tar -jxvf Python-2.7.3.tar.bz2<br>进入目录，编译安装</p>
<p>#./configure</p>
<p>#make all</p>
<p>#make install</p>
<p>#make clean</p>
<p>#make distclean<br>建立软连接，使系统默认的python指向python2.7</p>
<p>#mv /usr/bin/python /usr/bin/python2.6.6</p>
<p>#ln -s /usr/local/bin/python2.7 /usr/bin/python</p>
<p><a href="https://www.python.org/ftp/python/3.4.2/Python-3.4.2.tgz" target="_blank" rel="external">https://www.python.org/ftp/python/3.4.2/Python-3.4.2.tgz</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java源码解析]]></title>
      <url>http://yoursite.com/2016/06/09/java%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>private static class Node<e> {<br>        E item;<br>        Node<e> next;<br>        Node<e> prev;</e></e></e></p>
<pre><code>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
</code></pre><p>Node<e> node(int index) {<br>        // assert isElementIndex(index);</e></p>
<pre><code>    if (index &lt; (size &gt;&gt; 1)) {
        Node&lt;E&gt; x = first;
        for (int i = 0; i &lt; index; i++)
            x = x.next;
        return x;
    } else {
        Node&lt;E&gt; x = last;
        for (int i = size - 1; i &gt; index; i--)
            x = x.prev;
        return x;
    }
}
</code></pre><p>void linkBefore(E e, Node<e> succ) {<br>        // assert succ != null;<br>        final Node<e> pred = succ.prev;<br>        final Node<e> newNode = new Node&lt;&gt;(pred, e, succ);<br>        succ.prev = newNode;<br>        if (pred == null)<br>            first = newNode;<br>        else<br>            pred.next = newNode;<br>        size++;<br>        modCount++;<br>    }</e></e></e></p>
<p> public boolean remove(Object o) {<br>        if (o == null) {<br>            for (Node<e> x = first; x != null; x = x.next) {<br>                if (x.item == null) {<br>                    unlink(x);<br>                    return true;<br>                }<br>            }<br>        } else {<br>            for (Node<e> x = first; x != null; x = x.next) {<br>                if (o.equals(x.item)) {<br>                    unlink(x);<br>                    return true;<br>                }<br>            }<br>        }<br>        return false;<br>    }</e></e></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IntelliJ IDEA工具使用笔记]]></title>
      <url>http://yoursite.com/2016/06/09/IntelliJ-IDEA%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>IntelliJ IDEA 工具使用<br><a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/settings-introduce-1.html" target="_blank" rel="external">参考极客学院</a><br>ctrl+N 输入类名，从下拉列表选择<br>pyCharm Tips -&gt;<br>Open directory -&gt; Open in current window -&gt; Add to currently opended projects<br>Ctrl+shitf+T 快速打开类</p>
<p>Ctrl+空格  快速补全<br>ctrl+空格 两次，补全类名无论该类是否被引入<br>Ctrl+G find usages in the popup menu<br>ctrl+shift+空格  View | Quick Document   查看方法文档 （查看外部文档 用 Shift+F2）<br>F3    jump to declarations<br>ctrl+F3   浏览该类大致结构   Navigate  | File Structure<br>alt+shift+R     快速重命名    Refactor | Rename<br>补全的时候使用Tab<br>shift+click 或者 鼠标中键<br>alt+F1<br>ctrl+D  重复所选块<br>ctrl+p   此时，如果光标在括号中间，可以显示所需参数<br>ctrl+q   最后一次修改的地方<br>ctrl+shift+上    移动<br>alt+enter  自动导入包<br>alt+F7  查找该方法，类 在其他地方的使用情况<br>ctrl+O  覆盖基类方法<br>ctrl+Q 快速文档<br>ctrl+B  跳转定义<br>ctrl+F12  类结构<br>重命名变量  选中 shift+F6<br>ctrl+I 实现接口方法<br>alt+insert  生成getter、setter方法<br>ctrl+alt+T  surround with<br>ctrl+shift+空格   补全new<br>ctrl+shift+backspace  适用于跟代码很深，需要返回原来的编辑位置<br>Alt+Q  查看当前所属于哪个类<br>Ctrl+E  最近打开的文件<br>Ctrl+J  呼出 Live Template abbreviation   eg： it ctrl+J<br>方法之间有虚线分割： open the editor settings and select the Show method separators check box in the Appearance page.<br>Alt+Up/Down  当前类的方法之间循环切换<br>while debugging the program, select its text in the editor (you may press a Ctrl+W a few times to efficiently perform this operation) and press Alt+F8.</p>
<p>To quickly evaluate the value of any expression while debugging the program, hold Alt and click this expression to see its value and calculate it, call a method, etc.</p>
<p>Alt+Shift+C  快速浏览该项目最近操作<br>Ctrl+空格    完成html,css等的文件名称|属性补全<br>直接写出文件名称，会提示是否创建该文件<br>Ctrl+Shift+I 快速浏览某类或方法<br>Alt+Shift+F10 you can access the Run/Debug dropdown<br>You can quickly open a Maven project by selecting a pom.xml file in the File | Open dialog. The corresponding Maven project is imported with default settings, without launching the wizard.</p>
<p>eg:<br>private FileOutputStream 此时按下 ctrl+shift+空格  会补全一个本地变量 fileOutputStream</p>
<p>.IntelliJ IDEA 这个目录保存IntelliJ的配置，如果配置乱了可以删掉这个目录重新设置</p>
<ol>
<li>config 目录：是 IntelliJ IDEA 个性化化配置目录，这个目录主要记录了：IDE 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、Project 的 tasks 记录等等个性化的设置。</li>
<li>system 目录是 IntelliJ IDEA 系统文件目录，里面主要有：缓存、索引、容器文件输出等等<br>可以修改 bin/idea.properties里面的  idea.config.path=F:/360SycDir/idea_config/config 来指定config目录位置，同步自己的配置文件<br>右键 开启Toolbox</li>
</ol>
<p>Appearance 可以修改主题及主题字体<br>Font  可以修改代码字体<br>Console Font 可以修改控制台字体</p>
<p>如果遇到蓝屏断电等情况可能会造成InteliJ崩溃，缓存索引出问题，此时可以点击File-Invalidate Caches 就可以了</p>
<p>编译三种方式</p>
<ol>
<li>Compile： 对选定的目标（java类文件）进行强制性编译，不管目标是否被修改过</li>
<li>Rebuild：对选定的目标（Project)进行强制性编译，由于Rebuild的目标是Project，所以时间较长</li>
<li>Make   ：使用最多的编译操作，对选定的目标（Project或Module）进行编译，但是只编译修改过的文件</li>
</ol>
<p>点击项目栏可以直接进行搜索<br>has no Save button. Since in IntelliJ IDEA you can undo refactorings and revert changes from Local History<br>Code | Reformat Code  (CTRL+ALT+L)   格式化代码<br>Code | Optimiza Import (CTRL+ALT+O)  优化导入</p>
<p>Ctrl+F9 Make Project  可以映射Ctrl+S为Make Project，因为IntelliJ没有保存的概念<br>Shift X 2 可以呼出搜索框<br>Alt+左右箭头   切换Tab页<br>Smart completion   Ctrl+Shift+空格<br>Ctrl+Shift+F12 最大化窗口<br>Ctrl+E 最近文件<br>Ctrl+Tab  切换最近文件<br>Ctrl+F12    类文件结构   可以直接搜索<br>Shift+Alt+Up/Down   移动行<br>Ctrl+Y  删除行<br>查看提示  Alt+Enter<br>Ctrl+I  实现接口方法<br>Ctrl+H  在接口文件中查看接口被那些类实现<br>Ctrl+U  查看源代码<br>Alt+Left/Right 退回上一层代码</p>
<p>Shift+F10  Run<br>Shift+F9   Debug<br>Ctrl+F9    Make<br>Ctrl+F10   Update application</p>
<p>Shift+F9   Debug<br>Ctrl+Shift+I  快速浏览该类<br>Ctrl+Alt+T   Surround With<br>Ctrl+Alt+J  Surround with live template<br>Ctrl+Alt+U  UML图<br>Ctrl+Shift+Alt+T   重命名一个变量<br>Ctrl+G   定位到行</p>
<p>Ctrl+Shift+A  可以查看搜索所有的快捷键<br>Alt+Enter  快速修正<br>Alt+Insert  生成getter、setter方法<br>在左边的文件位置，可以直接按下Alt+Enter 新建文件<br>Ctrl+Q  快速浏览API说明<br>Ctrl+P 查看API参数<br>Ctrl+Shift+N  查找某个文件并定位到具体行数  Hello:18 表示定位到18行<br>Ctrl+空格  快速补全<br>ctrl+空格 两次，补全类名无论该类是否被引入<br>Ctrl+G find usages in the popup menu<br>ctrl+shift+空格  View | Quick Document   查看方法文档 （查看外部文档 用 Shift+F2）<br>F3    jump to declarations<br>ctrl+F3   浏览该类大致结构   Navigate  | File Structure<br>alt+shift+R     快速重命名    Refactor | Rename<br>补全的时候使用Tab<br>shift+click 或者 鼠标中键<br>alt+F1<br>ctrl+D  重复所选块<br>ctrl+p   此时，如果光标在括号中间，可以显示所需参数<br>ctrl+q   最后一次修改的地方<br>ctrl+shift+上    移动<br>alt+enter  自动导入包<br>alt+F7  查找该方法在其他地方的使用情况<br>ctrl+o  覆盖基类方法</p>
<p>模板用法，可以在  Editor | Live Templates修改，使用的时候Tab即可</p>
<h3 id="Eclipse-VS-IntelliJ-IDEA"><a href="#Eclipse-VS-IntelliJ-IDEA" class="headerlink" title="Eclipse VS  IntelliJ IDEA"></a>Eclipse VS  IntelliJ IDEA</h3><table>
<thead>
<tr>
<th>template</th>
<th>Eclipse</th>
<th>IntelliJ IDEA</th>
</tr>
</thead>
<tbody>
<tr>
<td>Define a main method</td>
<td>main</td>
<td>psvm</td>
</tr>
<tr>
<td>Iterate over an array</td>
<td>for</td>
<td>itar</td>
</tr>
<tr>
<td>Iterate over a collection</td>
<td>for</td>
<td>itco</td>
</tr>
<tr>
<td>Iterate over a list</td>
<td>for</td>
<td>itli</td>
</tr>
<tr>
<td>Iterate over an iterable</td>
<td>foreach</td>
<td>iter</td>
</tr>
<tr>
<td>print to System out</td>
<td>sysout</td>
<td>sout</td>
</tr>
<tr>
<td>print to System err</td>
<td>syserr</td>
<td>serr</td>
</tr>
</tbody>
</table>
<p>apply a template to an expression you’ve already typed<br>eg .ifn   -&gt;   if(..==null){…}Statement<br>Editor  | General   | Postfix Completion</p>
<p>选中项目 - View -open module settings  - &gt; SDKS   可以指定多种SDK，方便在不同项目中切换<br>新建的包以层级目录显示 在设置齿轮 Compate empty middle package 去掉勾选</p>
<p>调试<br>step into   F7<br>smart step into  shift+F7<br>step over   F8<br>step over  F8<br>step out   shift+F8<br>Resume    F9<br>Toggle breakpoint   Ctrl+F8<br>Evaluate expression Alt+F8</p>
<p>deploying to application servers in IntelliJ IDEA is more or less similar to what you are probably used to in Eclipse</p>
<p>new Date().var 自动赋值给本地变量</p>
<p>断点进入后，点击Drop Frame按钮之后，断点重新回到方法体之外<br>IntelliJ自动补全功能默认区分大小写，可以在 Code Completion 中把Case sensitive completion 设置为None<br>Auto Import 中开启自动导包功能</p>
<p>Code Folding  设置哪些类型是默认折叠的<br>若文件太多行数，可以进行垂直或水平分割修改代码<br>Debug状态下，如果要批量删除断点，可以点击左下角的红点，选中要删除的断点删除<br>Ctrl+Alt+T 选择自定义折叠代码区域功能<br>Editor Tabs show tabs in single row 把Tab分多行显示<br>Java- Code Generation 把注释放在紧贴代码的头部<br>Compiler -&gt; 在make或者rebuild过程很慢的时候，可以增加此堆的内存设置，一般大内存的机器设置1500<br>Editor-&gt;General 中设置查看最近文件数量</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Guava库学习]]></title>
      <url>http://yoursite.com/2016/06/09/Guava%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>Guava库学习</p>
<h3 id="Junit使用"><a href="#Junit使用" class="headerlink" title="Junit使用"></a>Junit使用</h3><blockquote>
<p>在InteliJ中，test目录右键，Mark Directory as -&gt; Test Source Root 然后在里面@Test引入Junit.jar即可编写测试用例</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>使用Files类来执行那些基本的任务，比如：移动或复制文件，或读取文件内容到一个字符串集合</li>
</ul>
</blockquote>
<ul>
<li><p>Closer类，提供了一种非常干净的方式，确保Closeable实例被正确的关闭</p>
</li>
<li><p>ByteSource 和 CharSource类，提供了不可变的输入流（Input）和读（Reader）</p>
</li>
<li><p>ByteSink 和 CharSink类，提供了不可变的输出流（Output）和写（Writer）</p>
</li>
<li><p>CharStreams和ByteStreams类，为读Readers、写Writers、输入流InputStreams、输出流OutputStreams 提供了一些静态的实用方法</p>
</li>
<li><p>BaseEncoding类，提供了编码和解码字节序列和ASCII字符的方法</p>
</li>
</ul>
<h5 id="文件的复制"><a href="#文件的复制" class="headerlink" title="文件的复制"></a>文件的复制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void testFile() throws IOException &#123;</div><div class="line">        File original = new File(&quot;D:\\test.txt&quot;);</div><div class="line">        File copy = new File(&quot;D:\\test3.txt&quot;);</div><div class="line">        Files.move(original,copy);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="文件的移动-重命名"><a href="#文件的移动-重命名" class="headerlink" title="文件的移动/重命名"></a>文件的移动/重命名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void readFileIntoListOfStirngTest() throws IOException &#123;</div><div class="line">        File file = new File(&quot;D:\\test3.txt&quot;);</div><div class="line">        List&lt;String&gt; expectedLines = Lists.newArrayList(&quot;hello one&quot;,&quot;two Hello&quot;,&quot;hello three&quot;);</div><div class="line">        List&lt;String&gt; readLine = Files.readLines(file,Charsets.UTF_8);</div><div class="line">        assertThat(expectedLines, is(readLine));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="像字符串一样处理文件"><a href="#像字符串一样处理文件" class="headerlink" title="像字符串一样处理文件"></a>像字符串一样处理文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">实现LineProcessor接口，此处采用集合泛型</div><div class="line">public class ToListLineProcessor implements LineProcessor&lt;List&lt;String&gt;&gt; &#123;</div><div class="line">    private static final Splitter splitter = Splitter.on(&quot;,&quot;);</div><div class="line">    private List&lt;String&gt; bookTitle = Lists.newArrayList();</div><div class="line">    private static final int TITLE_INDEX = 1;</div><div class="line">    // 文件的每一行都会经过processLine处理</div><div class="line">    @Override</div><div class="line">    public boolean processLine(String line) throws IOException &#123;</div><div class="line">        bookTitle.add(Iterables.get(splitter.split(line),TITLE_INDEX));</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    // 最终返回的结果</div><div class="line">    @Override</div><div class="line">    public List&lt;String&gt; getResult() &#123;</div><div class="line">        return bookTitle;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Test</div><div class="line">    public void readLinesWithProcessors() throws IOException &#123;</div><div class="line">        File file = new File(&quot;D:\\test3.txt&quot;);</div><div class="line">        List&lt;String&gt; readLines = Files.readLines(file, Charsets.UTF_8,new ToListLineProcessor());</div><div class="line">        List&lt;String&gt; expectedLines = Lists.newArrayList(&quot;hello&quot;,&quot;world&quot;,&quot;hello&quot;);</div><div class="line">        assertThat(expectedLines,is(readLines));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="文件的哈希值"><a href="#文件的哈希值" class="headerlink" title="文件的哈希值"></a>文件的哈希值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void testFilesHashing() throws IOException &#123;</div><div class="line">        File file = new File(&quot;D:\\test3.txt&quot;);</div><div class="line">        HashCode hashCode = Files.hash(file, Hashing.md5());</div><div class="line">        System.out.println(hashCode.toString().length());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="文件写和追加数据"><a href="#文件写和追加数据" class="headerlink" title="文件写和追加数据"></a>文件写和追加数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void appendingWritingFileTest() throws IOException &#123;</div><div class="line">        File file = new File(&quot;D:\\hello.txt&quot;);</div><div class="line">        file.deleteOnExit();</div><div class="line">        String hamletQuoteStart = &quot;To be ,or not to be&quot;;</div><div class="line">        Files.write(hamletQuoteStart, file, Charsets.UTF_8);</div><div class="line">        String hamletQuoteEnd = &quot;,that is the question&quot;;</div><div class="line">        Files.append(hamletQuoteEnd, file, Charsets.UTF_8);</div><div class="line">        assertThat(Files.toString(file, Charsets.UTF_8),is(hamletQuoteStart+hamletQuoteEnd));</div><div class="line"></div><div class="line">        String overWrites = &quot;OverWriting the file&quot;;</div><div class="line">        Files.write(overWrites, file, Charsets.UTF_8);</div><div class="line">        assertThat(Files.toString(file, Charsets.UTF_8), is(overWrites));</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们可以通过Files类提供的静态工厂方法来创建ByteSource、ByteSink、 CharSource、CharSink实例<br>我们将专注于ByteSource和ByteSink对象，CharSource和 CharSink对象与之相似，只是使用的是字符<br>ByteSource类表示一个可读的字节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void createByteSourceFromFileTest() throws IOException &#123;</div><div class="line">        File f1 = new File(&quot;D:\\test2.txt&quot;);</div><div class="line">        ByteSource byteSource = Files.asByteSource(f1);</div><div class="line">        byte[] readByte = byteSource.read();</div><div class="line">        assertThat(readByte,is(Files.toByteArray(f1)));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>ByteSink类表示一个可写的字节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void testCreateFileByteSink() throws IOException &#123;</div><div class="line">        File dest = new File(&quot;D:\\test.txt&quot;);</div><div class="line">        ByteSink byteSink = Files.asByteSink(dest);</div><div class="line">        File file = new File(&quot;D:\\test2.txt&quot;);</div><div class="line">        byteSink.write(Files.toByteArray(file));</div><div class="line">        assertThat(Files.toByteArray(dest), is(Files.toByteArray(file)));</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void copyToByteSinkTest() throws IOException &#123;</div><div class="line">        File source = new File(&quot;D:\\test.txt&quot;);</div><div class="line">        File dest = new File(&quot;D:\\test2.txt&quot;);</div><div class="line">        ByteSource byteSource = Files.asByteSource(source);</div><div class="line">        ByteSink byteSink = Files.asByteSink(dest);</div><div class="line">        byteSource.copyTo(byteSink);</div><div class="line">        assertThat(Files.toByteArray(dest), is(Files.toByteArray(source)));</div></pre></td></tr></table></figure>
<p>ByteStreams是一个实用的程序类，用来处理InputStream和OutputStream实例，CharStreams则是用来处理Reader和Writer实例的程序类。</p>
<h3 id="Strings类和Charsets类"><a href="#Strings类和Charsets类" class="headerlink" title="Strings类和Charsets类"></a>Strings类和Charsets类</h3><h6 id="Charsets类"><a href="#Charsets类" class="headerlink" title="Charsets类"></a>Charsets类</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Test</div><div class="line">    public void testCharsets()&#123;</div><div class="line">        print(Charsets.UTF_8);</div><div class="line">        print(Charsets.ISO_8859_1);</div><div class="line">        byte[] bytes;</div><div class="line">        try &#123;</div><div class="line">            bytes = string.getBytes(&quot;UTF-8&quot;);</div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        // Charsets类则包装了一些常用的 字符集常量，</div><div class="line">        // 使用Charsets封装的字符集避免处理异常</div><div class="line">        bytes = string.getBytes(Charsets.UTF_8);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="Strings类"><a href="#Strings类" class="headerlink" title="Strings类"></a>Strings类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void testString()&#123;</div><div class="line">        char c = &apos;s&apos;;</div><div class="line">        // 将param1的长度改变为length，长度不足的话向后追加字符param2</div><div class="line">        print(Strings.padEnd(string,6,c));</div><div class="line">        // 也有padStart()方法，向前追加，长度超出默认返回原字符</div><div class="line">        print(Strings.padStart(string,6,c));</div><div class="line">        print(Strings.nullToEmpty(null));</div><div class="line">        print(Strings.emptyToNull(&quot; &quot;));</div><div class="line">        print(Strings.isNullOrEmpty(null));</div><div class="line">        print(Strings.repeat(string,3));</div><div class="line">        // 返回两个字符串相同的前缀</div><div class="line">        print(Strings.commonPrefix(&quot;nihaoma?&quot;,&quot;nibuhaoma?&quot;));</div><div class="line">        // 返回两个字符串相同的后缀</div><div class="line">        print(Strings.commonSuffix(&quot;nihaoma?&quot;,&quot;nibuhaoma?&quot;));</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="ComparisonChain类的学习和使用"><a href="#ComparisonChain类的学习和使用" class="headerlink" title="ComparisonChain类的学习和使用"></a>ComparisonChain类的学习和使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Girl implements Comparable&lt;Girl&gt;&#123;</div><div class="line">    private String name;</div><div class="line">    private double height;</div><div class="line">    private String face;</div><div class="line"></div><div class="line">    public Girl(String face, double height, String name) &#123;</div><div class="line">        this.face = face;</div><div class="line">        this.height = height;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    // 使用了建造者模式</div><div class="line">    @Override</div><div class="line">    public int compareTo(Girl o) &#123;</div><div class="line">        return ComparisonChain.start()</div><div class="line">                .compare(name,o.name)</div><div class="line">                .compare(height,o.height)</div><div class="line">                .compare(face,o.face)</div><div class="line">                .result();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Joiner类的学习使用"><a href="#Joiner类的学习使用" class="headerlink" title="Joiner类的学习使用"></a>Joiner类的学习使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class JoinTest &#123;</div><div class="line">    private static String sep = &quot;|&quot;;</div><div class="line">    private static List list = initTestingData();</div><div class="line">    // HashMap 的一种新写法</div><div class="line">    private static Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;() &#123;</div><div class="line">        private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            put(&quot;i love u&quot;, &quot;u love me&quot;);</div><div class="line">            put(&quot;i like u&quot;, &quot;u like me&quot;);</div><div class="line">            put(&quot;i hate u&quot;, &quot;u hate me&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    private static List initTestingData() &#123;</div><div class="line">        List list = new ArrayList();</div><div class="line">        for (int i = 0; i &lt; 20; i++) &#123;</div><div class="line">            if (i % 5 == 0) &#123;</div><div class="line">                list.add(null);</div><div class="line">            &#125; else</div><div class="line">                list.add(&quot;test&quot; + i);</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testBuildStringWithJoin()&#123;</div><div class="line">        String str = Joiner.on(sep).skipNulls().join(list);</div><div class="line">        System.out.println(str);</div><div class="line">        String str2 = Joiner.on(sep).useForNull(&quot;hello&quot;).join(list);</div><div class="line">        System.out.println(str2);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testJoinerStringBuilder()&#123;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        Joiner joiner = Joiner.on(sep).skipNulls();</div><div class="line">        joiner.appendTo(sb,&quot;i love me&quot;,&quot;i like u &quot;,null,&quot;i hate u&quot;);</div><div class="line">        System.out.println(sb.toString());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testMapJoiner()&#123;</div><div class="line">        String str = Joiner.on(sep).withKeyValueSeparator(&quot;=&quot;).join(map);</div><div class="line">        System.out.println(str);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testJoiner()&#123;</div><div class="line">        String str1 = Joiner.on(&quot;;&quot;).skipNulls().join(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,null));</div><div class="line">        assertEquals(str1,&quot;a;b;c&quot;);</div><div class="line">        String str2 = Joiner.on(&quot;,&quot;).join(Arrays.asList(1,5,7));</div><div class="line">        assertEquals(str2,&quot;1,5,7&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">输出</div><div class="line">test1|test2|test3|test4|test6|test7|test8|test9|test11|test12|test13|test14|test16|test17|test18|test19</div><div class="line">hello|test1|test2|test3|test4|hello|test6|test7|test8|test9|hello|test11|test12|test13|test14|hello|test16|test17|test18|test19</div><div class="line">i love me|i like u |i hate u</div><div class="line">i hate u=u hate me|i like u=u like me|i love u=u love me</div></pre></td></tr></table></figure>
<p>skipNulls（）方法用于过滤集合中为null的元素，然后返回一个新的Joiner对象实例；<br>useForNull(String nullText)方法用于将集合中为null的元素替换成指定的字符串，并返回新的Joiner对象实例；<br>withKeyValueSeparator(String separator)方法，处理map时使用，接收map中key和value之间的分隔符；<br>join方法则用来接收需要处理的集合对象或object[]对象数组，返回处理后的字符串表示。</p>
<h3 id="Splitter的应用"><a href="#Splitter的应用" class="headerlink" title="Splitter的应用"></a>Splitter的应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void testSplitter() &#123;</div><div class="line">        // omitEmptyStrings方法用于忽略分割后产生的空值</div><div class="line">        Iterable strings = Splitter.on(separator).omitEmptyStrings()</div><div class="line">                .split(string);</div><div class="line">        // [i hate u=u hate me , i like u=u like me , i love u=u love me]</div><div class="line">        System.out.println(strings);</div><div class="line">        // trimResults方法用于处理分割后每一项中的空白符</div><div class="line">        Iterable strings2 = Splitter.on(separator)</div><div class="line">                .trimResults().split(string);</div><div class="line">        // [i hate u=u hate me, i like u=u like me, , , i love u=u love me]</div><div class="line">        System.out.println(strings2);</div><div class="line"></div><div class="line">        Iterable&lt;String&gt; string3 = Splitter.on(separator).omitEmptyStrings().trimResults().split(string);</div><div class="line">        System.out.println(string3);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">输出为</div><div class="line">[i hate u=u hate me , i like u=u like me , i love u=u love me]</div><div class="line">[i hate u=u hate me, i like u=u like me, , , i love u=u love me]</div><div class="line">[i hate u=u hate me, i like u=u like me, i love u=u love me]</div><div class="line"></div><div class="line">@Test</div><div class="line">    public void testMapSplitter() &#123;</div><div class="line">        Splitter.MapSplitter mapSplitter = Splitter.on(separator)</div><div class="line">                .omitEmptyStrings().withKeyValueSeparator(separator2);</div><div class="line">        Map&lt;String, String&gt; map = mapSplitter.split(string);</div><div class="line">        Set keySet = map.keySet();</div><div class="line">        // [i hate u, i like u, i love u]</div><div class="line">        System.out.println(keySet);</div><div class="line">    &#125;</div><div class="line">输出为</div><div class="line">[i hate u, i like u, i love u]</div></pre></td></tr></table></figure>
<p>Splitter是通过Splitter.on(分隔符).split(字符串)来处理字符串，与Joiner类似，通过静态on（）方法，我 们构建了一个Splitter对象，其中提供了两种常用的方法，分别是omitEmptyStrings（）和trimResults（），这两个方法的 调用都会返回一个新的Splitter对象实例。<br>omitEmptyStrings（）用于忽略字符串分割后产生的空值元素，trimResults（）用于去除字符串分割后子元素中的空白符。<br>与Joiner类似，Splitter也提供了一个内部类MapSplitter来处理字符串，返回map集合，调用方法为 withKeyValueSeparator(separator)，在静态on()方法之后调用，在分割后的子项中根据指定的separator再次分 割成key-value键值对，返回的结果为map集合。</p>
<h3 id="Guava-Collection学习"><a href="#Guava-Collection学习" class="headerlink" title="Guava Collection学习"></a>Guava Collection学习</h3><p>FluentIterable是一个抽象类同时实现了 Iterable接口，内部提供了一个静态的from方法，用于接收一个Iterable接口的实现作为参数，返回一个包装了Iterable接口的 FluentIterable实例。FluentIterable可以链式调用toList、toSet、 toMap、 toSortedList以及toSortedSet等方法，转换为我们熟悉的集合类型。</p>
<p>FluentIterable.filter和FluentIterable.transform方法，顾名思义，分别用于集合的过滤和转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class Girl&#123;</div><div class="line">private List&lt;Girl&gt; girls;</div><div class="line"></div><div class="line">    @Before</div><div class="line">    public void setUp()&#123;</div><div class="line">        Girl g1 = new Girl(17, &quot;nice&quot;);</div><div class="line">        Girl g2 = new Girl(18, &quot;beauty&quot;);</div><div class="line">        Girl g3 = new Girl(19, &quot;nice&quot;);</div><div class="line">        Girl g4 = new Girl(18, &quot;nice&quot;);</div><div class="line">        girls = Lists.newArrayList(g1,g2,g3,g4);</div><div class="line">    &#125;</div><div class="line">    @Test</div><div class="line">    public void testFluentIterable()&#123;</div><div class="line">        /**</div><div class="line">         * from方法：用于包装Iterable接口，返回FluentIterable实例</div><div class="line">         * filter方法：用于过滤集合中元素，返回过滤后的集合</div><div class="line">         */</div><div class="line">        FluentIterable.from(girls).filter(new Predicate&lt;Girl&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public boolean apply(Girl girl) &#123;</div><div class="line">                return &quot;nice&quot;.equals(girl.getFace());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        /**</div><div class="line">         * transform方法：用于根据指定Function转换集合元素，返回转换后的集合</div><div class="line">         */</div><div class="line">        FluentIterable&lt;String&gt; fluentIterable = FluentIterable.from(girls).transform(new Function&lt;Girl, String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public String apply(Girl girl) &#123;</div><div class="line">                return Joiner.on(&quot;,&quot;).join(girl.getAge(), girl.getFace());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">filter(Predicate&lt;? super E&gt; predicate)：</div><div class="line">---&gt; 接收一个Predicate作为参数，过滤那些能够满足predicate的元素，返回FluentIterable实例。</div><div class="line"></div><div class="line">transform(Function&lt;? super E, T&gt; function)：</div><div class="line">---&gt; 接收一个Function作为参数，相应转换集合中的元素，返回FluentIterable实例。</div></pre></td></tr></table></figure>
<h4 id="Collections-Lists"><a href="#Collections-Lists" class="headerlink" title="Collections Lists"></a>Collections Lists</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"> @Test</div><div class="line">    public void testLists() &#123;</div><div class="line">        /**</div><div class="line">         * 一些构造List实例的方法很简单</div><div class="line">         * 如：newArrayList(),newLinkedList()等</div><div class="line">         * 这里不再赘述</div><div class="line">         */</div><div class="line">        String str = &quot;i love u&quot;;//测试用</div><div class="line">        String[] strs = &#123;&quot;i like u&quot;, &quot;i miss u&quot;&#125;;//测试用</div><div class="line">        /**</div><div class="line">         * asList：返回一个不可变的List</div><div class="line">         * 其中包含指定的第一个元素和附加的元素数组组成</div><div class="line">         * 修改这个数组将反映到返回的List上</div><div class="line">         */</div><div class="line">        List&lt;String&gt; list = Lists.asList(str, strs);</div><div class="line">        System.out.println(list); //[i love u, i like u, i miss u]</div><div class="line">        strs[1] = &quot;i hate u&quot;;//对strs数组的修改会反映到List中</div><div class="line">        System.out.println(list);//[i love u, i like u, i hate u]</div><div class="line">        /**</div><div class="line">         * transform：根据传进来的function对fromList进行相应的处理</div><div class="line">         * 并将处理得到的结果存入到新的list对象中返回</div><div class="line">         */</div><div class="line">        List&lt;String&gt; newList = Lists.transform(list, new Function&lt;String, String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public String apply(String input) &#123;</div><div class="line">                //这里简单的对集合中的元素转换为大写</div><div class="line">                return input.toUpperCase();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        System.out.println(newList);//[I LOVE U, I LIKE U, I HATE U]</div><div class="line">         /**</div><div class="line">         * partition：根据size传入的List进行切割，切割成符合要求的小的List</div><div class="line">         * 并将这些小的List存入一个新的List对象中返回</div><div class="line">         */</div><div class="line">        List&lt;List&lt;String&gt;&gt; lists = Lists.partition(list, 2);</div><div class="line">        System.out.println(lists);//[[i love u, i like u], [i hate u]]</div><div class="line">        /**</div><div class="line">         * charactersOf：将传进来的String或者CharSequence分割为单个的字符</div><div class="line">         * 并存入到一个ImmutableList对象中返回</div><div class="line">         * ImmutableList：一个高性能、不可变的、随机访问列表的实现</div><div class="line">         */</div><div class="line">        ImmutableList&lt;Character&gt; characters = Lists.charactersOf(&quot;realfighter&quot;);</div><div class="line">        System.out.println(characters);//[r, e, a, l, f, i, g, h, t, e, r]</div><div class="line">        /**</div><div class="line">         * reverse：返回一个传入List内元素倒序后的List</div><div class="line">         */</div><div class="line">        List&lt;String&gt; reverse = Lists.reverse(list);</div><div class="line">        System.out.println(reverse);//[i hate u, i like u, i love u]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">输出</div><div class="line">[i love u, i like u, i miss u]</div><div class="line">[i love u, i like u, i hate u]</div><div class="line">[I LOVE U, I LIKE U, I HATE U]</div><div class="line">[[i love u, i like u], [i hate u]]</div><div class="line">[r, e, a, l, f, i, g, h, t, e, r]</div><div class="line">[i hate u, i like u, i love u]</div></pre></td></tr></table></figure>
<h3 id="CharMatcher"><a href="#CharMatcher" class="headerlink" title="CharMatcher"></a>CharMatcher</h3><p>字符串匹配 &amp;&amp; 字符处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">    public void testCharMatcher()&#123;</div><div class="line">        assertEquals(CharMatcher.DIGIT.retainFrom(&quot;some text 889983 and more&quot;),&quot;889983&quot;);</div><div class="line">        assertEquals(CharMatcher.DIGIT.removeFrom(&quot;some text 889983 and more&quot;),&quot;some text  and more&quot;);</div><div class="line">        assertEquals(CharMatcher.anyOf(&quot;abcxy&quot;).removeFrom(&quot;abcdefgxyz&quot;),&quot;defgz&quot;);</div><div class="line">        String str1 = CharMatcher.inRange(&apos;a&apos;,&apos;f&apos;)</div><div class="line">                .and(CharMatcher.isNot(&apos;c&apos;))</div><div class="line">                .and(CharMatcher.isNot(&apos;e&apos;))</div><div class="line">                .or(CharMatcher.is(&apos;z&apos;))</div><div class="line">                .replaceFrom(&quot;abyczef&quot;,&quot;*&quot;);</div><div class="line">        assertEquals(str1,&quot;**yc*e*&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="Big-Endian-和-Little-Endian"><a href="#Big-Endian-和-Little-Endian" class="headerlink" title="Big Endian 和 Little Endian"></a>Big Endian 和 Little Endian</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class CharUtil &#123;</div><div class="line">    /**</div><div class="line">     * big endian是指低地址存放最高有效字节（MSB），而little endian则是低地址存放最低有效字节（LSB）</div><div class="line">     * @param</div><div class="line">     *          bytes</div><div class="line">     * @return</div><div class="line">     *          int</div><div class="line">     */</div><div class="line">    public static int byte2Int(byte[] bytes)&#123;</div><div class="line">        int num = bytes[3] &amp; 0xFF;</div><div class="line">        num |= (bytes[2] &lt;&lt; 8) &amp; 0xFF00;</div><div class="line">        num |= (bytes[1] &lt;&lt; 16) &amp; 0xFF0000;</div><div class="line">        num |= (bytes[0] &lt;&lt; 24) &amp; 0xFF000000;</div><div class="line">        return num;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static byte[] int2ByteArray(int i)&#123;</div><div class="line">        byte[] result = new byte[4];</div><div class="line">        result[0] = (byte) ((i &gt;&gt; 24) &amp; 0xFF);</div><div class="line">        result[1] = (byte)((i &gt;&gt; 16 ) &amp; 0xFF);</div><div class="line">        result[2] = (byte)((i &gt;&gt; 8 ) &amp; 0xFF);</div><div class="line">        result[3] = (byte)(i &amp; 0xFF);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class testNum &#123;</div><div class="line">    @Test</div><div class="line">    public void testByte2Int()&#123;</div><div class="line"></div><div class="line">        byte[] bb = new byte[]&#123;0,0,1,1&#125;;</div><div class="line">        System.out.println(CharUtil.byte2Int(bb));</div><div class="line">    &#125;</div><div class="line">    @Test</div><div class="line">    public void testInt2ByteArray()&#123;</div><div class="line">        byte[] bt = CharUtil.int2ByteArray(258);</div><div class="line">        for (int i = 0; i &lt; bt.length; i++) &#123;</div><div class="line">            byte b = bt[i];</div><div class="line">            System.out.println(b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：OutputStream中直接写入一个int类型，会截取低8位，丢弃高24位，因此需要将基本类型先转换为字节流。Java采用的是BigEndian字节序，所有的网络协议都是采用BigEndian字节序来进行传输的，因此我们在进行数据的传输时，需要先将其转换成BigEndian字节序；同理，在数据接收时，也需要进行响应的转换</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[疯狂java讲义笔记一]]></title>
      <url>http://yoursite.com/2016/05/12/%E7%96%AF%E7%8B%82java%E8%AE%B2%E4%B9%89%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>开发定义类，方法时也可以先添加文档注释，然后使用 javadoc 工具来生成自己的API文档<br>将字符串转换为数值类型<br> Byte.parseByte(String str)<br> Integer.parseInt(String str)<br> Float.parseFloat(String str)<br>位运算符 &amp; 按位与  | 按位或  ~按位非   ^按位异或   &lt;&lt; 左移运算符 &gt;&gt; 右移运算符 &gt;&gt;&gt;无符号右移运算符<br> 逻辑运算符 &amp;&amp; 必须前后两个均为true,返回true   &amp; 不短路与<br> || 只要两个操作数有一个为true,就返回true   | 不短路或<br> 使用静态初始化的方法来初始化一个二维数组<br> String [][] str1 = new String[][]{new String[3],new String[]{“hello”}};</p>
<p>public static void test(int a,String…books){<br> for(String tmp : books){<br> System.out.println(tmp);<br> }<br>}<br> 数组形式的形参可以处于形参列表的任意位置，但个数可变的形参只能处于形参列表的最后，也就是，一个方法中最多只能有一个长度可变的形参</p>
<p>类的生命周期：一个类在使用之前要经过类加载，类验证，类准备，类解析，类初始化等几个阶段<br>对象并不是完全由构造器创建，在这之前系统会为该对象分配内存空间，并为这个对象执行默认初始化，这个对象已经产生了。<br> 构造器中通过this来引用他，使得这个对象作为构造器的返回值被返回，从而让外部程序可以访问该对象。</p>
<p>编译时的类型由声明该变量使用的类型决定，运行时的类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就出现了多态。<br>一个类里可以多多个初始化块，相同类型的初始化块之间有顺序，前面定义的初始化块先执行，后面定义的后执行<br> 初始化块总是在构造器执行之前执行</p>
<p>如果定义初始化块使用了static修饰符，则变成了静态初始化块，也被称为类初始化块。静态初始化块总是比普通初始化块先执行<br> 静态初始化块是类相关的，用于对整个类进行初始化处理。</p>
<p>对于特殊需求，可以通过重写equals方法来实现<br> 正确的重写equals方法英爱满足下列条件：<br> 自反性 对任意x,x.equals(x)一定返回true<br> 对称性  对任意x和y,若 x.equals(y) 返回true,则 y.equals(x)也返回true<br> 传递性  x-&gt;y y-&gt;z x-&gt;z<br> 一致性  对任意的x和y,无论调用多少次，结果不变<br> 对任何不是null的对象，x.equals(null) 一定返回false</p>
<p>public boolean equals (Object obj){<br> if(this == obj){return true;}<br> if(obj != null &amp;&amp; obj.getClass() == Person.class){<br>  Person PersonObj = (Person)obj;<br>  if(this.getIdStr().equals(PersonObj.getIdStr()))<br>  return true;<br>  }<br>}</p>
<p>Hash就是把任意长度的输入，通过散列算法，变变换成固定长度的输出，输出就是散列值<br> 这种转换是一种压缩映射，也就是说，散列值的空间通常远小于输入的空间<br> 不同的输入可能会散列成相同过的输出，而不可能从散列值来唯一的确定输入值<br>   对象相等则hashCode 一定相等，hashCode 相等对象未必相等</p>
<p>缓存实例eg:<br> public class CacheImmutale {<br>private final String name;<br>public CacheImmutale(String name){<br>this.name = name;<br>}<br>private String getName() {<br>return name;<br>}<br>private static CacheImmutale[] cache = new CacheImmutale[10];<br>private static int pos = 0;<br>public static CacheImmutale valueOf(String name){<br>for(int i = 0;i &lt; pos;i++){<br>if(cache[i] != null &amp;&amp; cache[i].getName().equals(name)){<br>return cache[i];<br>}<br>}<br>if(pos == 10){<br>cache[0] = new CacheImmutale(name);<br>pos = 1;<br>return cache[0];<br>}else{<br>cache[pos++] = new CacheImmutale(name);<br>return cache[pos-1];<br>}<br>}<br>public boolean equals(Object obj){<br>if(obj instanceof CacheImmutale){<br>CacheImmutale ci = (CacheImmutale)obj;<br>if(name.equals(ci.getName()))<br>return true;<br>}<br>return false;<br>}<br>public int hashCode(){<br>return name.hashCode();<br>}</p>
<p>抽象父类可以只定义需要使用的某些方法，其余则留给其子类实现。<br> eg:<br> public abstract class SpeedMeter {<br>private double turnRate;<br>public SpeedMeter(){</p>
<p>}<br>public abstract double getRadius();<br>public void setTurnRate(double turnRate){<br>this.turnRate = turnRate;<br>}<br>public double getSpeed() {<br>return java.lang.Math.PI <em> 2 </em>getRadius() * turnRate;<br>}<br> }</p>
<p> public class CarSpeedRate extends SpeedMeter{<br>public double getRadius(){<br>return 0.23;<br>}<br>public static void main(String[] args) {<br>CarSpeedRate csm = new CarSpeedRate();<br>csm.setTurnRate(15);<br>System.out.println(csm.getSpeed());<br>}<br> }</p>
<p>接口和抽象类的不同点<br> 接口体现的是一种规范，抽象体现的是一种模板设计<br> 接口里只能包含抽象方法，不包含已经提供实现的方法；抽象类可以包含普通方法<br> 接口里不能定义静态方法；抽象类里可以定义静态方法<br> 接口只能定义静态常量属性，不能定义普通属性；抽象类可以静态常量属性，也可以定义普通属性<br> 接口不包含构造器；抽象类可以包含构造器，抽象类的构造器并不是用于创建对象，而让其子类调用这些构造器来完成属于抽象类的初始化操作<br> 接口不难更包含初始化块，但抽象类可以包含初始化块。<br> 一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补java单继承的不足</p>
<p>Object[] toArray() 把集合装换成一个数组<br> int size() 返回集合里元素的个数<br> Iterator iterator()  返回一个Iterator对象，用于遍历集合里的对象<br> 可以使用泛型来限制集合里元素的类型，并让集合记住所有集合元素的类型</p>
<p>当使用Iterator对集合元素进行迭代时，Iterator并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量<br> 所以修改迭代变量的值对集合元素本身没有任何影响</p>
<p>重写hashCode()方法的基本原则：<br> 当两个对象通过equals() 方法比较返回true时，这两个对象的hashCode应该相等。<br> 对象中功能用作equals比较标准的属性，都应该用来计算hashCode值<br> HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等</p>
<p>TreeSet (排序)是SortedSet接口的唯一实现，可以确保集合元素处于排序状态<br>如果试图把一个对象添加进TreeSet时，则该对象的类必须实现Comparable接口，否则异常<br>Comparator comparator() 返回当前Set使用的Comparator或者返回null，表示以自然方式排序<br> Object first() 集合中第一个<br> Object last()  集合中最后一个<br> Object lower(Object e)  返回集合中位于指定元素之前的元素，注意是一个元素<br> Object higher(Object e)  之后的元素，注意是一个元素，不是返回集合<br> SortedSet subSet(fromElement,toElement)  返回此Set的集合，范围  包含开始，不包含结尾<br> SortedSet headSet(toElement)  返回Set的子集，由小于toElement的元素组成<br> SortedSet tailSet(fromElement) 返回Set的子集，由大于或等于fromElement的元素组成</p>
<p>操作数组的工具类 Arrays.asList(Object …a)方法可以把一个数组或指定个数的对象转换成一个List集合，这个list既不是ArrayList实现类<br> 的实例，也不是Vector实现类的实例，而是Arrays的内部类ArrayList的实例</p>
<p>List方法：<br>void add(int index,Object element)<br>boolean addAll(int index,Collection c) 将集合c所包含的所有元素插入在index处<br>Object get(int index)<br>int indexOf(Object o)  返回对象o在list出现的位置索引<br>int lastIndexOf(Object o) 返回对象o在list集合中最后一次出现的位置索引<br>Object remove(int index) 删除并返回index索引处的元素<br>Objece set(int index,Object element) 将index处的元素替换成element对象，返回新元素<br>List subList(int fromIndex,int toIndex) 返回从fromindex(包含)到toindex(不包含)所有集合元素的子集合<br>List的indexOf 方法判断两个对象相等的条件是通过equals方法比较返回true</p>
<p>List额外提供了一个listIterator()方法,该方法返回一个在Iterator接口基础上增加了如下方法：<br>boolean hasPrevious() 返回该迭代器关联的集合是否还有上一个元素<br>Object previous() 返回迭代器的上一个元素<br>void add()  在指定位置插入一个元素<br>List<string> booklist = new ArrayList<string>();<br>ListIterator<string> lt = booklist.listIterator();</string></string></string></p>
<p>ArrayList和Vector类都是基于数组实现的List类，提供了如下两个方法来操作capacity属性<br>void ensureCapacity(int minCapacity) 将ArrayList或Vector集合的capacity增加minCapacity<br>void trimToSize() 调整ArrayList或Vector集合的capacity为列表当前大小，可调用该方法减少ArrayList或Vector对象的存储空间<br>ArrayList和Vector显著区别是：ArrayList是线程不安全的，Vector集合则是线程安全的</p>
<p>vector提供了栈 stack。方法: peek()  pop()  push(Object item)<br>与java其他集合一样，进栈出栈的都是Object，因此从栈中取出元素后必须做类型转换<br>Object peek()  返回栈的第一个元素，但不出栈<br>Object pop()  返回栈的第一个元素，出栈<br>void push(Object item) 将其进栈</p>
<p>操作数组的工具类 Arrays，asList(Object …a)方法可以把一个数组或指定个数的对象转换成一个List集合，这个list既不是ArrayList实现类<br>的实例，也不是Vector实现类的实例，而是Arrays的内部类ArrayList的实例</p>
<p>Queue接口所提供的方法：用于模拟队列<br>void add(Object e)  加入此队列的尾部<br>Object element(); 获取队列头部元素，不删除<br>Object peek()读取队首元素<br>Object poll()获取队首元素并且删除<br>Objece remove()</p>
<p>Queue有两个常用的实现类： LinkedList  和   PriorityQueue</p>
<p>Deque接口定义了一些可以双向操作队列的方法<br>void addFirst(Object e)<br>void addLast(Object e)<br>Iterator descendingIterator() 返回以该双向队列对应的迭代器，该迭代器将以逆向顺序迭代队列中元素<br>Object getFirst() 获取，但不删除双向队列的第一个元素<br>Object getLast()  获取，但不删除双向队列的末尾<br>boolean offerFirst(Object e) 将指定元素插入该双向队列的开头<br>boolean offerLast(Object e)  将指定元素插入该双向队列的末尾<br>Object peekFirst()  获取，但不删除该双向队列的第一个元素<br>Object peekLast()  获取，但不删除该双向队列的最后一个元素<br>Object pollFirst() 获取，并删除双向队列的第一个元素<br>Object pollLast()获取，并删除双向队列的最后一个元素<br>Object pop() 出该双向队列表示的栈中的第一个元素<br>void push(Object e)  将一个元素push进该双向队列所表示的栈中</p>
<p>Object removeFirst() 获取删除该双向队列的第一个元素<br>Object removeFirstOccurrence(Object o) 删除该双向队列的第一次的出现元素o<br>removeLast() 获取删除该双向队列的最后一个元素<br>removeLastOccurrence(Object o) 删除该双向队列的最后一次出现元素o</p>
<p>LinkedList集合不仅提供了List功能，还提供了双向队列，栈的功能<br>PriorityQueue 保存队列元素的顺序并不是按加入队列的顺序，而是按队列元素的大小进行重新排序</p>
<p>Map接口中定义了如下常用的方法：<br>void clear() 删除Map对象中所有key-value对<br>boolean containsKey(Object key) 查询Map中是否包含指定key，如果包含返回true<br>boolean containsValue(Object value) 查询Map是否包含一个或多个value，如果包含返回true<br>Set entrySet()返回Map所包含的key-value对所组成的Set集合<br>Object get(Object key) 返回指定可以所对应的value<br>boolean isEmpty() 查询该Map是否为空<br>Set keySet()  返回该Map中所有可以所组成的Set集合<br>Object put(Object key,Object value)  添加一个key-value对，如果当前Map中已有一个与该key相等的key-value对，则新的key-value会覆盖原来的<br>void putAll(Map m) 将指定Map中的key-value对复制到本Map中<br>Object remove(Object key) 删除指定key 所对应的key-value对，返回被删除key所关联的value<br>int size()  返回Map中的key-value对的个数<br>Collection values()  返回该Map里所有value组成的collection</p>
<p>Map中博阿含一个内部类，Entry.该类封装了一个key-value对，Entry包含三个方法：<br>Object getKey() 返回该Entry里包含的key 值<br>Object getValue()  返回该Entry里包含的value值<br>Object setValue(V value) 设置该Entry里包含的value值，并返回新设置的value值</p>
<p>Hashtable和HashMap存在两点典型区别：<br>HashTable 是一个线程安全的Map实现，但HashMap是线程不安全的实现<br>Hashtable不允许使用null作为key和value</p>
<p>Properties类是HashTable类的自雷，可以把Map对象和属性文件关联起来，从而可以把Map对象中的key-value对写入属性文件<br>也可以把属性文件中的属性名属性值加载到Map对象中。<br>Properties提供了三个方法来修改Properties里的key,value值<br>String getProperty(String key)   获取Properties中指定属性名对应的属性值<br>String getProperty(String key,String defaultValue) 类似于前一个方法，如果Properties中不存在key时，返回默认值<br>Object setProperty(String key,String value) 设置属性值<br>void load(InputStream inStream)   从属性文件(以输入流表示)中加载属性名=属性值<br>void store(OutputStream out,String comments)  将Properties中的key-value对写入指定属性文件<br>eg:<br>Properties props = new Properties();<br>props.setProperty(“username”, “yee”);<br>props.setProperty(“password”, “12334”);<br>props.store(new FileOutputStream(“a.ini”), “comment line”);<br>Properties props2 = new Properties();<br>props2.setProperty(“gender”, “male”);<br>props2.load(new FileInputStream(“a.ini”));</p>
<p>操作集合的工具类 ： Collection<br>Java提供了一个操作Set,List和Map等集合的工具类 Collections，该工具提供了大量方法对集合排序，查询和修改操作<br>还提供了将集合对象设置为不可变，对集合对象实现同步控制等方法<br>Collections提供了如下几个方法用于对List集合元素进行排序<br>static void reverse(List list)  反转指定List集合中元素的顺序<br>static void shuffle(List lsit)  随机排序，shuffle方法模拟了洗牌动作<br>static void sort(List list)  自然顺序升序排序<br>static void sort(List list,Comparator) 根据Comparator产生的顺序对List集合的元素进行排序<br>static void swap(List list,int i,int j) 将制定List集合中 i 处元素和 j 处元素交换<br>static void rotate(List list, int distance) 将制定集合中i处元素和 list.length-i 处元素进行交换</p>
<p>static int binarySearch(List list,Object key)    使用二分搜索法搜索指定List集合<br>static Object max(Collection coll)   根据自然顺序，返回给定集合最大元素<br>static Object max(Collection coll,Comparator comp)  根据指定Comparator产生的顺序，返回给定集合最大元素<br>static Object min(Collection coll)     自然顺序，返回给定集合最小元素<br>static Object min(Collection coll,Comparator comp)    根据指定Comparator产生的顺序，返回给定集合最小元素<br>static void fill(List list,Object obj)   使用指定元素obj替换指定List集合的所有元素<br>static int frequency(Collection c,Object obj)   返回指定集合中等于指定对象的元素数量<br>static int indexOfSubList(List source,List target)   返回子List对象在母List对象中第一次出现的位置索引，若没有，返回-1<br>static int lastIndexOfSubList(List source,List target)  返回子List对象在母List对象中最后一次出现的位置索引，若没有，返回-1<br>static boolean replaceAll(List list,Object oldVal,Object newVal)   替换</p>
<p>同步控制：<br>Collections类中提供了多个synchronizedXxx方法，该方法返回指定集合对象对应的同步对象，从而可以解决多线程并发访问集合时的线程安全问题<br>Collections c = Collections.synchronizedCollection(new ArrayList())<br>List list = Collections.synchronizedList(new ArrayList())<br>Set s = Collections.synchronizedSet(new HashSet())<br>Map m = Collections.synchronizedMap(new HashMap())<br>在上面的实例中，直接将新创建的集合对象传给了Collections的synchronizedXxx方法，这样可以直接获取List,Set,Map 的线程安全时限版本。</p>
<p>泛型中子类重写父类方法时，要与父类的类型一致<br>List<string> ls = new ArrayList<string>();</string></string></p>
<p>java.util.Scanner<br>sr.useDelimiter(“\n”);<br>sr.hasNext()<br>sr.hasNextLine()</p>
<p>读取文件：Scanner sr = new Scanner(new File(“e:\a.txt”));</p>
<p>使用bufferedreader读取<br>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));<br>String sr = null;<br>while((sr=br.readLine())!=null){<br>System.out.println(sr);<br>}</p>
<p>使用Calendar<br>Calendar calendar =  Calendar.getInstance()</p>
<p>正则表达式：<br>boolean matches(String regex)<br>String replaceAll(String regexx,String replacement)<br>String replaceFirst(String regex,String replacement)<br>String[] split(String regex)</p>
<p>网状型数据库<br>层次性数据库<br>关系型数据库<br>面向对象数据库</p>
<p>SQL语句的关键字不区分大小写</p>
<p>java_300</p>
<p>取得选中项目 jcb_dish.getSelectedItem().toString()</p>
<p>for循环 for(String item:value){System.out.println(item+””)}</p>
<p>arr1复制到arr2中  int arr[]=Arrays.copyOfRange(arr1,5,arr1.length);</p>
<p>java的java.util.Arrays类中提供了sort()方法，可以采用二分排序</p>
<p>数组声明初始化：int arr[]=new int[]{22,23,45}<br>int arr2[]={23,45,34}</p>
<p>java.util.Arrays   Arrays.binarySearch(数组，关键字)<br>  Arrays.binarySearch(数组，开始（包含），结束（不包含），关键字)</p>
<p>简易for循环一般用来遍历List对象或Iterator对象</p>
<p>面向对象特征：封装，继承，多态</p>
<p>OOP(object-oriented programming) 面向对象编程<br>关键字abstract用于定义抽象类和抽象方法，抽象类是一种不可以被实例化的类</p>
<p>方法重载：在同一个类中有相同名称，不同参数的方法，这些方法有相同的功能</p>
<p>成员变量VS局部变量</p>
<p>只能通过构造方法创建对象吗 ？<br>不是，还可以通过工厂方法创建对象，通过反射创建对象</p>
<p>隐藏类的属性，使其不被其他类使用 private</p>
<p>某个变量的值能被所有对象共享，可以将变量声明为静态变量 private static int num=10;<br>静态常量  public static final double pi=3.14<br>用static 修饰的方法称为静态方法</p>
<p>static{}静态语句块  比如用在数据库连接，初始化图像等<br>final修饰常量</p>
<p>浅克隆：被克隆的各个对象都是基本类型，而不是引用类型<br>深克隆：存在引用类型 ，相当于在浅克隆的基础上对引用类型加以处理</p>
<p>两种方式实现克隆：序列化的方式   一次克隆各个可变的引用类型域的方式</p>
<p>匿名内部类是指没有指定类名的内部类，当某个类不需要重复使用时，就可以把该类定义为匿名内部类，由于匿名内部类 没有类名，所以在程序中只能使用一次，<br>   在图形化编程的事件监控器代码中，会大量使用匿名内部类</p>
<p>创建class对象的方法：<br>1.存在某个类完整路径的字符串，通过class类的forName()方法<br>2.知道某个类student  通过 student.class()<br>3.知道某个类的实例 如：student.getClass()</p>
<p>重写equals()方法遵循      自反性，对称性，传递性，一致性</p>
<p>在java中使用反射创建对象的两种方法:<br>1 通过使用class类的newInstance()方法实现   适合无参<br>2 使用constructor类实现  适合有参</p>
<p>自动装包指的是 基本类型自动转换为包装类<br>自动拆包指的是 包装类自动转换为基本类型</p>
<p>int 是Java中的基本数据类型，Integer是包装类，java将包装类作为对象调用</p>
<p>基本数据类型有 boolean char float double （四种整数） byte,short,int long</p>
<p>java笔记</p>
<p>数据类型可以从低变量到高变量<br>高精度到低精度 强制转换 int a=(int)1.2<br>精度由低到高 byte short int long float duoble<br>在java中的小数默认是double<br>class 类名{成员变量（属性），成员函数（方法），构造方法}<br>一个类可以定义多个构造方法<br>this只能在类定义内部使用</p>
<p>类变量，类方法<br>static int total<br>//total 是静态变量，因此可以被任何一个对象访问<br>类变量是该类的所有对象共享的变量<br>类方法是属于所有对象实例的<br>加上static 成为类变量或者静态变量，否则实例变量<br>java面向对象编程的四大特征 ：（抽象） 封装，继承，多态<br>把一类食物的共同属性和行为提取出来，形成一个物理模型，称为抽象</p>
<p>封装就是把抽象出的数据和对数据的操作封装在一起<br>字体：window–general–appearance–colors and font–basic–YaHei</p>
<p>包名小写<br>常用的包 java.util.<em>工具    java.net.</em>网络</p>
<p>成员变量，成员方法都有访问修饰符<br>继承： class pupil extends stu<br>public protected 属性和方法都被继承，若不希望子类继承某个属性或者方法，则声明为私有的<br>方法重载  方法覆盖  @override<br>使用“+”与字符串连接的任何类型的数据都会转换成字符串进行连接<br>eg: “3+5=”+3+5  返回的是“3+5=35”</p>
<p>java中String str=null 与String str=””的区别 ？<br>前者表示声明了一个String对象的引用str，但是没有为其分配内存空间<br>后者表示创建了一个长度为0的空字符串， and 在内存中为其分配了内存空间</p>
<p>被final关键字修饰的变量是不可以被继承的，没有被final关键字修饰的类是可以被继承的<br> String类为final关键字修饰的类，所以不能被继承</p>
<p>str.toLowerCase()  str.toUpperCase()  返回一个处理过的字符串，str本身不会有任何改变</p>
<p>“==”和equals()区别？<br>“==”比较的是两个对象使用的内存地址和内容；<br>equals() 比较的是内容</p>
<p>判断字符串是否为空：<br>1.sVar==null<br>2.sVar.equals(“”)<br>3.sVar.length()==0</p>
<p>去掉字符串的空格： String str=” “  str.replaceAll(“ “,””) OR  str.trim()</p>
<p>子字符串  str.substring(x[包含],y[不包含])</p>
<p>char[] chars=str.toCharArray();   //将字符串存到字符数组中<br>for(int i=0;i&lt;chars.length;i++){bool=character.isDigit(char[i]); if(bool==true){break;}  }<br>str.indexOf(“h”) 在字符串中搜寻指定字符</p>
<p>进制转换 Integer类的几个方法<br>二进制to十进制 int no=Integer.parseInt(“10001000”,2)  parseInt(String s,int radix[基数])</p>
<p>toBinaryString(int i)    toHexString(int i)   toOctalString(int i)</p>
<p>StringBuilder对象是一个可变的字符序列，大大提高了频繁增加字符串的效率  “+”会产生新的String实例，在内存中创建新的字符串对象</p>
<p>StringBuffer 类也是一个包含有缓冲区的字符串对象   StringBuilder类是非线程安全的，StringBuffer是线程安全的</p>
<p>str=str.replace(“ “,””);   str.replaceFirst(“ “,” “); str.replaceAll(String regex,String replacement);</p>
<p>编码格式：byte[] btutf=str.getBytes(“UTF-8”);<br>String strz=new String(btutf,”UTF-8”);</p>
<p>String value=”dfasdfds”  byte[] bt=value.getBytes(); //转换为字符数组</p>
<p>使用try…catch,try…catch…finally.以及try…finally等语句块进行异常处理，还可以通过throws关键字声明方法抛出的异常<br>通过throws声明方法抛出的异常可以简化程序编写，只在最后调用方法时进行异常处理</p>
<p>对于字节文件：FileInputStream  FileOutputStream<br>对于字符文件：FileReader   FileWriter</p>
<p>Java枚举  values()返回一个包含全部枚举元素的数组<br>valuesOf()返回当前字符串对应的枚举元素</p>
<p>泛型提高程序健壮性，指的是把一些运行时Bug改为编译时Bug，通过及时修复Bug而提高程序健壮性</p>
<p>泛型声明类型参数，命名要求：E:元素  K:键  N:数字  V:值<br> T:类型，S,U，V类型</p>
<p>Java语言不支持多继承，因此在限制类型参数范围是，不能使用两个类</p>
<p>在java中，数组是协变的，例如：Integer类是Number类的子类，那么可以<br>将Integer类型的数组复制给Number类型的数组</p>
<p>泛型不能协变<br>泛型中的擦除是指在程序编译后，就将类型信息擦除了</p>
<p>新建一个进程，两种方法。<br>1.public class Test extends Thread{} //继承Thread<br>2.public class Test implements Runnable{}  //Runnable接口</p>
<p>由于java仅支持单继承，却可以实现多个接口，推荐用第二种方法</p>
<p>java<br>并发性和并行性区别：<br>并行是指在同一时刻，有多条指令在多个处理器上同事执行；并发是指在同一时刻只能有一条指令执行，<br>但多个的进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果</p>
<p>一个进程你可以拥有多个线程，一个线程必须有一个父进程。线程可以拥有自己的堆栈，自己的程序计数器和局部变量<br>但不拥有系统资源，它与父进程的其他线程共享 该进程所拥有的全部资源。<br>使用继承thread时获得当前线程对象比较简答，直接使用this就可以了；使用时限Runnable接口时要获得当前<br>对象必须使用Thread.currentThread()方法。</p>
<p>每个线程的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级<br>synchronized关键字可以i修饰方法，可以修饰代码块</p>
<p>yield让出cpu的使用权，让给同优先级的或者更高优先级的<br>join()线程等待被join的线程结束才继续运行</p>
<p>重写hashCode()方法和equals()方法<br>public int hashCode(){<br>return accountNo.hashCode();<br>}<br>public boolean equals(Object obj){<br>if(obj!=null&amp;&amp;obj.getClass()==Account.class){<br>Account target = (Account)obj;<br>return target.getAccountNo().equals(accountNo);<br>}<br>return false;<br>}</p>
<p>public synchronized void draw(){}通过synchronized关键字来声明加锁</p>
<p>Lock是控制多个线程对共享资源进行访问的工具。<br>class x{<br>private final ReentrantLock lock = new ReentrantLock();<br>public void m(){<br>lock.lock();<br>try{</p>
<p>}<br>finally}<br>lock.unlock();<br>}<br>}<br>加锁和释放锁要出现在一个块结构中，而且当获取了多个锁时，他们必须以相反的顺序释放<br>ReentrantLock锁具有重入性，也就是可以对已经加锁的ReentrantLock再次加锁。<br>Object类提供的wait(),notify()和notifyAll()三个方法，这三个方法不属于Thread类，而是属于Object<br>但这三个方法必须由同步监视器对象来调用，分为两种情况<br>1）使用synchronized修饰的同步方法，因为该类默认实例就是同步监视器，所以在同步方法中直接调用这三个方法<br>2）使用synchronized修饰的同步代码块，同步监视器是synchronized括号里的对象，必须使用该对象调用这三个方法</p>
<p>自定义线程捕获异常<br>package com.yu;<br>public class ExHandler {<br>public static void main(String[] args) {<br>Thread.currentThread().setUncaughtExceptionHandler(new MyExHandler());<br>int a = 5/0;<br>}<br>}<br>class MyExHandler implements Thread.UncaughtExceptionHandler{<br>@Overrideto<br>public void uncaughtException(Thread t, Throwable e) {<br>// TODO Auto-generated method stub<br>System.out.println(t+”线程出现问题”+e);<br>}<br>}</p>
<p>使用线程池可以很好的提高性能，尤其是当程序需要创建大量生存期很短暂的线程时，更应该考虑使用线程池<br>public class ThreadPoolTest {<br>public static void main(String[] args) {<br>ExecutorService pool = Executors.newFixedThreadPool(6);<br>pool.submit(new TestThread());<br>pool.submit(new TestThread());<br>pool.shutdown();<br>}<br>}<br>class TestThread implements Runnable{<br>@Override<br>public void run() {<br>// TODO Auto-generated method stub<br>for(int i = 0;i &lt; 100;i++){<br>System.out.println(Thread.currentThread().getName()+”的i为:”+i);<br>}<br>}<br>}</p>
<p>计算机网络协议通常由三部分组成，语义部分，用于决定给双方对话的类型；语法部分，用于决定双方对话的格式<br>变换规则，用于决定通信双方的应答关系</p>
<p>java为网络支持提供了java.net包，该包下的URL和URLConnection等类提供了以编程方式访问Web服务的功能<br>而URLDecoder和URLEncoder则提供了普通字符串和application/x-www-form-urlencoded MIME字符串相互转换的静态方法</p>
<p>多线程下载；如果要实现断点下载，则还需要额外增加一个配置文件（所有支持断点下载的工具都会在下载<br>开始生成两个文件，一个是与网络资源大小相同的文件夹，一个是配置文件），该配置文件分别记录每个线程<br>已经下载到了那个字节，当网络断开后再次开始下载时，每个线程根据配置文件里记录的位置向后下载即可</p>
<p>java使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信</p>
<p>java获取指定元素的节点<br>public static void main(String[] args) throws ParserException {<br>String url = “<a href="http://www.ttmeishi.com/CaiXi/" target="_blank" rel="external">http://www.ttmeishi.com/CaiXi/</a>“;<br>Parser parser = new Parser(url);<br>   parser.setEncoding(“utf-8”);<br>   NodeFilter filter = new TagNameFilter(“a”);<br>   NodeList list = parser.extractAllNodesThatMatch(filter);<br>System.out.println(list.toHtml());<br>= list.elementAt(1);<br>}</p>
<p>byte  -128 ~ 127<br>short -32768 ~ 32767<br>NullPointerException 空指针异常，引用数据类型，观察其是否被正确实例化<br>匿名对象 new Person(“zhang”,20).tell()<br>数组静态初始化： int[] data = new int[]{20,32,32}<br>数组动态初始化： int[] data = new int[3]<br>数组排序  Arrays.sort(data)<br>System.arrayCopy(dataB,5,dataA,2,3);<br>每一个字符串都是String的匿名对象。<br>在String类进行设计的时候采用了一种共享设计模式的概念，在每一个运行的JVM层存在一个字符串的对象池，如果用户直接赋值，会将字符串<br>放入到池中，以供其他继续使用直接赋值方式的String对象使用。</p>
<p>String str = new String(“hello”)创建了两个实例化对象，一个是String类的匿名对象hello，一个是使用关键字new实例化的String对象</p>
<p>String类的常用方法：<br>字符串与字符：<br>public String(char[] value) 将全部的字符数组 ——&gt; 字符串<br>public String(char[] value,int offset,int count)  将部分字符数组变为字符串<br>public charAt(int index)  取得指定索引位置上的字符<br>public char[] toCharArray()  将字符串—–&gt; 字符数组<br>字符串与字节<br>public String(byte[] bytes)<br>public String(byte[] bytes,int offset,int length)<br>public byte[] getBytes()<br>public Bytes[] getBytes(String charSetName)<br>字符串比较： equals(String str)   equalsIgnoreCase(String str)   compareTo(String str)<br>字符串查找<br>public boolean contains(String s)<br>public int indexOf(String s) //查找字符串的位置<br>public int indexOf(String str,int fromIndex)<br>public int lastIndexOf(String str)<br>public int lastIndexOf(String str,int fromIndex)<br>public boolean startsWith(String prefix)  //是否以指定字符串开头<br>public boolean startsWith(String prefix,int offset)<br>public boolean endsWith(String suffix)<br>字符串替换<br>public String replaceAll(String regex,String replacement)<br>public String replaceFirst(String regex,String replacement)<br>字符串截取：<br>public String subString(int beginIndex)<br>public String subString(int beginIndex,int endIndex)<br>字符串拆分：<br>public String[] split(String regex)<br>public String[] split(String regex,int limit)<br>其他方法：<br>public boolean isEmpty()<br>public int length()<br>public String trim()<br>public String toLowerCase()<br>public String toUpperCase()<br>public String concat(String str)</p>
<p>引用传递：<br>public static void main(String args[]){<br>String str = “hello”;<br>fun(str);<br>System.out.println(str);</p>
<p>}<br>public static void fun(){<br>temp = “world”;<br>}<br>结果输出  hello，因为temp改变了指向</p>
<p>static 定义的属性保存在全局数据区， 使用 类名称.static属性 的方式来完成<br>java主要存在四块内存空间<br>1.栈内存空间，保存所有的对象名称<br>2.堆内存空间 保存每个对象的具体属性内容<br>3.全局数据区 保存static类型的属性<br>4.全局代码区  保存所有的方法定义</p>
<p>private static int count = 0;<br>public Person(){<br>System.out.println(“num is:” + ++count);<br>}<br>public static void main(String[] args) {<br>new Person();<br>new Person();<br>new Person();<br>}</p>
<p>代码块有 普通代码块，构造块，静态块<br>构造块优先于构造方法执行<br>静态块优先于构造块执行，而且不管有多少个实例化对象产生，静态块只会执行一次，主要作用是为类中的static属性初始化<br>主类中的静态块的执行优先于主方法</p>
<p>内部类的用法:<br>class Outer{<br>private String msg=”hello”;<br>class Inner{<br>public void print(){<br>System.out.println(msg);<br>}<br>}<br>public void fun(){<br>Inner in = new Inner();<br>in.print();<br>}<br>}<br>public  class TestDemo{<br>public static void main(String[] args) {<br>Outer out = new Outer();<br>out.fun();<br>}<br>}</p>
<p>子类对象的实例化操作会调用父类的构造方法，super调用父类构造时一定要放在构造方法的首行上。<br>final:<br>1.final修饰的类不能有子类，无法被其他类继承。<br>2.使用final定义的方法不能被子类所重写<br>3.使用final定义的变量，就表示敞亮，常量在定义时必须设置默认值，且不能修改。</p>
<p>构造方法私有化—&gt; 隐藏构造方法，单例模式<br>eg:<br>class Singleton{<br>private final static Singleton instance = new Singleton();<br>private Singleton(){}<br>public static Singleton getInstance()<br>{return instance;}<br>public void print(){<br>System.out.println(“hello”);<br>}<br>}<br>public class Test{<br>public static void main(String args[]){<br>Singleton inst = Singleton.getInstance();<br>inst.print();<br>}<br>}</p>
<p>多例模式：<br>class Sex {<br>private static final Sex MALE = new Sex(“男”);<br>private static final Sex FEMALE = new Sex(“女”);<br>private String title;<br>private Sex(String title){<br>this.title = title;<br>}<br> public static Sex getInstance(String msg){<br>switch(msg){<br>case “male”:<br>return MALE;<br>case “female”:<br>return FEMALE;<br>default:<br>return null;<br>}<br>}<br>}</p>
<p>如果在try语句中有一个return语句，那么紧跟在try后面的finally一定会被执行，并且是在return 前执行<br>RuntimeException和Exception区别，并列举出 几个常见的RuntimeException<br>Exception定义了必须处理的异常，而RuntimeException定义的异常可以选择性的进行处理<br>RuntimeException是Exception的子类，常见的RuntimeException有： NumberFormatException ClassCastException NullPointerException<br>ArithmeticException ArrayIndexOutOfBoundException</p>
<p>断言指的是程序执行到某行后，其结果一定是预期的结果<br>自定义异常：<br>class MyException extends Exception{<br>public MyException(String msg) {<br>// TODO Auto-generated constructor stub<br>super(msg);<br>}<br>}<br>main:  throw new MyException(“it’s a exception”);<br>异常是导致程序中断运行的一种指令流<br>throws用在方法声明处，表示本方法不处理异常<br>throw表示在方法中手工抛出一个异常<br>不同包的同名类，则导入的时候要指定完整名称 eg: cn.mldn.util.Message msg = new cn.mldn.util.Message()</p>
<p>命名规范：<br>类名称  每一个单词的开头首字母大写，如TestDemo<br>变量名称 第一个单词的首字母小写，之后每个单词的首字母大写 如stuName<br>方法名称  第一个单词的首字母小写，之后每个单词的首字母大写 如 printInfo()<br>常量名称  每个字母大写 如FLAG<br>包名称  所有字母小写  如 cn.mldnjava.util</p>
<p>可变参数： 可以比较直观的传递任意多个参数<br>public static int add(int… data) {<br>int sum = 0;<br>for (int x = 0; x &lt; data.length; x++) {<br>sum += data[x];<br>}<br>return sum;<br>}</p>
<p>foreach 语句<br>for(int x:data){<br>sum+=x;<br>}</p>
<p>泛型：类中操作的属性或方法的参数类型不在定义时声明，而是在使用时动态设置<br>枚举来写多例设计模式<br>enum Color{<br>RED,GREEN,BLUE;<br>}<br>Color c = Color.RED;</p>
<p>jdk1.7之后，switch可以操作Strint数据<br>可以使用通配符？接受全部的泛型类型对象<br>通过&lt;？extend 类&gt;可以设置泛型的上限，&lt;？super 类&gt;可以设置泛型的下限<br>在java中使用enum关键字定义一个枚举类，每个枚举类都是集成Enum类<br>enum Color{<br>RED,GREEN,BLUE;<br>}<br>for(Color c:Color.values())  //取得全部的枚举值<br>System.out.println(c.ordinal()+” “ + c.name())</p>
<p>线程的命名和取得<br>public Thread(Runnable target ,String name)  //实例化线程对象，接受Runnable接口子类对象，同时设置线程名称<br>public final void setName(String name) //设置线程名称<br>public final String getName()  //取得线程名称<br>线程的休眠  在run方法中，Thread.sleep(100)   System.out.println(Thread.currentThread().getName())<br>线程优先级设置<br>public static final int MAX_PRIORITY<br>public static final int NORM_PRIORITY<br>public static final int MIN_PRIOTITY<br>public final void setPriority(int newPriority) // Runnable mt = new Runnable() ; Thread t = new Thread(mt,”线程A”)<br>public final int getPriority() //  t.setPriority(Thread.MAX_PRIORITY)  System.out.println(Thread.currentThread().getPriority())</p>
<p>同步：使用同步代码块，或者使用同步方法<br>同步代码块只需要在执行的大括号前加上 synchronized(this)<br>同步方法 public synchronized void sale()<br>static native synchronized 都不能和abstract同时声明方法</p>
<p>解决重复的问题需要等待及唤醒机制，这一机制的实现只能依靠Object类完成，Object定义了3个方法来完成线程操作<br>public final void wait() throws InterruptedException<br>public final void notify()<br>public final void nofityAll()</p>
<p>sleep()和wait()区别<br>sleep是Thread类定义的static方法，表示线程休眠，将执行机会让给其他线程，但监控状态依然保持，到时候会自动恢复<br>wati是Object类定义的方法，表示线程等待，一直到执行了notify或notifyAll方法后才结束</p>
<p>一般 通过设置一个标志位的方式停止一个线程的运行<br>String不适合被频繁修改的字符串，这种情况下可以使用StringBuffer，方便用户进行内容的修改<br>一个类是否可以继承String类？ 不能，String类使用了final定义，不能被其他类继承</p>
<p>操作一：将String变为StringBuffer<br>方法一 利用StringBuffer的构造方法   public StringBuffer(String str)  —&gt; StringBuffer bf = new StringBuffer(str);<br>方法二   StringBuffer的append()方法   buf.append(str)</p>
<p>操作二 将StringBuffer变为String  StringBuffer的toString()方法  String str = buf.toString() 方法<br>StringBuffer常用方法：<br>bf.reverse()  bf.replace(int start,int end,String str)  br.insert(int offset,数据)</p>
<p>System类提供了两个常用方法：<br>public static void arrayCopy(Object src,int srcPos,Object dest,int destPos,int length)<br>public static long currentTimeMillis()<br>eg:long start = System.currentTimeMillis();    long end = System.currentTimeMillis(); —&gt;(end - start)<br>日期操作类<br>public Date()<br>public Date(long date) //将数字变为Date类对象，long为日期时间数据<br>eg: Date date = new Date(System.currentTimeMillis());<br>public long getTime()  //将当期那日期时间变为long型<br>eg: Date date = new Date();<br>long num = date.getTime();</p>
<p>日期格式化操作类 SimpleDateformat<br>public SimpleDateFormat(String pattern)  //传入日期时间标记实例化对象<br>public final String format(Date date)   //将日期格式化为字符串数据<br>public Date parse(String source) throws ParserException  //将字符串格式化为日期数据<br>eg:<br>Date date = new Date();<br>SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);<br>String str = sdf.format(date);   —–&gt;   2015-04-28 11:13:54   //日期格式化为字符串</p>
<p>eg:<br>String str = “1991-08-20 12:12:12.122”;<br>SimpleDateFormat sdf = new SimpleDateFormat(“yy-MM-dd HH:mm:ss.SSS”);<br>Date date = sdf.parse(str);   //将字符串格式化为日期数据</p>
<p>Random类<br>Random rand = new Random();  rand.nextInt(101);<br>大数字操作类：<br>java.math.BigInteger和java.math.BigDecimal 这两个类属于Number的子类<br>数组操作类： Arrays类<br>public static boolean equals(int[] a,int[] b)  //Arrays.equals(dataA,dataB)<br>public static void fill(int[] a,int val)   //Arrays.fill(dataA,3)<br>public static void sort(int[] a)   //Arrays.sort(dataA)<br>public static int binarySearch(int[] a,int key)    //Arrays.binarySearch(dataA,key)<br>public static String toString(int[] a)  //Arrays.toString(dataA)<br>普通的对象数组是不能够进行比较的，如果要比较需要比较器（Comparable接口就是一种比较器）的支持</p>
<p>比较器：<br>欲进行比较，需要实现Comparable接口<br>public class Person implements Comparable<person><br>重写compareTo方法<br>public int compareTo(Person o){<br>if(this.age &gt; o.age){<br>return 1;<br>}else if(this.age &lt; o.age){<br>return -1;<br>}else{<br>return 0;<br>}<br>}</person></p>
<p>对象克隆<br>实现Cloneable接口，但这个接口属于标识接口，只表示一种能力。<br>class Person implements Cloneable{  }<br>@Override<br>public String toString(){return “  “;}<br>@Override<br>protected Object clone() throws CloneNotSupportedException<br> {return super.clone();}</p>
<p>正则表达式<br>所有正则匹配的符号都在  java.util.regex.Pattern  类中进行定义<br>//  \ 匹配转移字符 “\”<br>\t匹配转移字符”\t”<br>^开始<br>$结束<br>.标识任意的一位字符<br>\d  表示任意的一位数字  \D非数字<br>\w 任意的一位字母,数字，下划线      \W非字母，数字，下划线<br>？0或1次</p>
<ul>
<li>0次，1次或多次</li>
</ul>
<ul>
<li>1次或多次<br>{n} 正好n次<br>{n,} n次以上<br>{n,m} 最少n次，最多m次<br>eg: 123.1   regex = “\d+(\.\d+)”<br>String类对正则的支持<br>public boolean matches(String regex)   str.matches(regex)<br>public String replaceAll(String regex,String replacement)<br>public String[] split(String regex )<br>eg: String str = “a1bb2cc3dddd4eeeee5fff6eddd7oooo8iiiiii9”;<br>String regex=”\d”;<br>String result[] = str.split(regex);<br>public String[] split(String regex,int limit)</li>
</ul>
<p>字符串—&gt; 数字<br>int data = Integer.parseInt(str)<br>double data = Double.parseDouble(str)<br>表示任意一个用[],如[a-zA-z0-9\.]，表示或者关系的用(xx|yy)<br>判断电话号码的regex      String regex = “((\d{3,4}|\(\d{3,4}\))-?)?\d{7,8}”;<br>简单的邮箱地址验证 String regex = “[a-zA-Z][a-zA-Z0-9]*@[a-zA-Z_0-9\.]+\.(com|cn|net)”</p>
<p>反射<br>Java IO操作<br>所有的IO操作都在java.io包中进行定义，而且整个java.io包实际上就是五个类和一个接口<br>五个类：File InputStrearm OutStream Reader Writer<br>一个接口： Serializable<br>public File(String pathname)  构造方法，给定一个要操作文件的完整路径<br>File file = new File(“D:\demo.txt”);<br>file.exists()  file.createNewFile()  file.delete()<br>public boolean createNewFile() throws ArrayIndexOutOfBoundException<br>public boolean delete()<br>public boolean exists()<br>File file = new File(“D:”+File.separator+”demo.txt”);   File.separator是为了在不同平台运行</p>
<p>创建有目录的文件<br>public File getParentFile()  找到一个指定路径的父路径<br>public boolean mkdirs()   创建指定目录<br>File file = new File(“D:”+File.separator+”hello”+File.separator+”test”+File.separator+”demo.txt”);<br>if(!file.getParentFile().exists()){<br>file.getParentFile().mkdirs();            //若不存在父文件，则创建之<br>}<br>if(file.exists()){<br>file.delete();        //若文件不存在，创建之<br>}else{<br>file.createNewFile();<br>}</p>
<p>File的其他用法：<br>public String getName()   //取得文件名称<br>public boolean isDirectory()<br>public boolean isFile()  //file.isFile()<br>public boolean isHidden()<br>public long lastModified()   //文件的最后一次修改日期<br>public long length()  //取得文件大小，以字节为单位返回<br>public boolean renameTo(File dest)   //为文件重命名      file.renameTo(newName)<br>public File[] listFiles()   //将目录中所有文件以File对象数组的方式返回   File result[] = file.listFiles()<br>递归输出目录下的文件<br>public static void print(File file){<br>    if(file.isDirectory()){<br>    File result[] = file.listFiles();<br>        if(result!=null){<br>            for(int x = 0; x &lt; result.length; x++)<br>                print(result[x]);<br>        }<br>    }<br>    System.out.println(file);<br>}</p>
<p>yuchuan—————–<br>字节操作流  OutputStream  InputStream<br>字符操作流  Writer  Reader</p>
<p>FileOutputStream类的构造方法：<br>public FileOutputStream(FIle file) throws FileNotFoundException  实例化FileOutputStream，主要用于新建数据<br>public FileOutputStream(File file,boolean append) throws FileNotFoundException   主要用于追加数据<br>OutputStream定义的方法<br>pubic FileOutpubStream(File file)throws FileNotFoundExceptin<br>public void write(byte[] b) throws IOException<br>public void write(byte[] b,int off,int len) throws IOException<br>对于OutputStream而言，它本身定义的是一个抽象类，按照抽象类的使用原则，需要定义抽象类的子类，子类要为抽象类进行对象的实例化<br>而后调用的方法以父类为主，而具体的实现是实例化这个父类的子类完成的，关心的是子类的构造方法。</p>
<p>InputStream定义方法：<br>public abstract int read() throws IOException   //读取一个字节，到结尾返回 -1<br>public int read(byte[] b)throws IOException   //读取多个字节，返回的是读取的数据个数<br>public int read(byte[] b,int off,int len) throws IOException</p>
<p>如果希望对输出的内容增加换行显示，可以使用”\r\n”来表示<br>eg：把内容输出到指定文件<br> File file = new File(“D:”+File.separator+”test.txt”);<br>OutputStream output = new FileOutputStream(file);<br>OutputStream output = new FileOutputStream(file,true); true表示追加数据<br>String data = “hello world”;<br>output.write(data.getBytes());<br>output.close();<br>eg:从指定文件读取内容：<br> InputStream input = new FileInputStream(file);<br>byte[] data = new byte[1024];<br>int len = input.read(data);<br>input.close();<br>System.out.println(“data is:”+new String(data,0,len));<br>字节流和字符流的区别<br>字节流在IO操作时，直接针对的是操作的数据端(如文件)，而字符流操作时不是直接针对于终端，而是针对于缓存区的操作，而后由缓存区<br>操作终端，属于间接操作。<br>字节流没有使用缓冲区，而字符流使用了缓冲区<br>处理各种数据都可以通过字节流完成，而在处理中文时使用字符流会更好</p>
<p>单个字节读取：<br>while((temp=input.read())!=-1){<br>data[foot++]=(byte) temp;<br>}<br>字符输出流 Writer类本身是一个抽象类，那么要使用它依然要依靠其子类，比如FileWriter类<br>public abstract void close() throws IOException<br>public void write(String str) throws IOException<br>public void wirte(char[] buf) throws IOException<br>public abstract void flush() throws IOException<br>eg:<br>Writer out = new FileWriter(file);<br>String data = “\r\nnice to meet you .\n”;<br>out.write(data);        //直接把字符串输出到文件中<br>out.close();</p>
<p>字符输入流<br>public abstract void close() throws IOException<br>public int read() throws IOException<br>public int read(char[] cbuf) throws IOException<br>Reader in = new FileReader(file);<br>char data[] = new char[1024];<br>int len = in.read(data);<br>System.out.println(“data is:” +new String(data,0,len));<br>in.close();</p>
<p>转换流<br>将字节输出流变为字符输出流 OutputSteam -&gt; Writer   OutputStreamWriter<br>将字节输入流变为字符输入流 InputStream -&gt;Reader   InputStreamReader<br>eg:<br>OutputStream output = new FileOutputStream(file);<br>Writer out = new OutputStreamWriter(output);<br>out.write(“hello world”);<br>out.close();</p>
<p>InputStream抽象类下面 有   FileInputStream 和 ByteArrayInputStream<br>OutputStream抽象类下面有   FileOutputStream 和 ByteArrayOutputStream</p>
<p>缓冲区操作 BufferedReader de 构造方法： public BufferedReader(Reader in)<br>读取操作  public String readLine() throws IOException</p>
<p>BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));<br>String str = buf.readLine()      //利用BufferedReader进行循环判断<br>if(str.matches(“\d+”)){</p>
<p>num = Integer.parseInt(str);</p>
<p>System.out.println(num*num);</p>
<p>}<br>Scanner 方法<br>pubic Scanner(InputStream source)<br>public boolean hasNext(Pattern pattern)  //判断输入的数据是否符合指定的正则标准<br>public boolean hasNext()  //判断有输入内容<br>public boolean hasNextxxx()  //判断输入的是否为指定的数据类型<br>public String next()          //接受内容<br>public String next(Pattern pattern)  //接受内容，进行正则验证<br>public int nextXxx()   //接受指定的输入类型<br>public Scanner useDelimiter(String pattern)      sn.useDelimiter(“\n”);    //设置读取的分隔符<br>由输入验证生日：<br>eg:<br>if(sn.hasNext(“\d{4}-\d{2}-\d{2}”)){<br>String str = sn.next(“\d{4}-\d{2}-\d{2}”);<br>Date date = new SimpleDateFormat(“yyyy-MM-dd”).parse(str);</p>
<p>对象序列化<br>对象序列指的是可以将内存中保存的对象数据（主要指的是一个对象里面所包含属性内容）进行二进制数据传输的一种操作，要想<br>实现这样的二进制操作，对象所在的类就必须实现java.io.Serializable 接口（这个接口和Cloneable接口一样，都属于一种标识接口<br>表示一种能力）可以使用transient关键字定义不被序列化的属性。</p>
<p>ServerSocket类的常用操作方法<br>public ServerSocket(int port) throws IOException<br>public Socket accept() throws IOException<br>public void close() throws IOException<br>Socket的常用操作方法<br>public Socket(String host,int port)<br>public OutputStream getOutputStream()<br>public InputStream getInputStream()</p>
<p>java习惯用法总结</p>
<ol>
<li>实现equals()</li>
</ol>
<p>class Person {<br>  String name;<br>  int birthYear;<br>  byte[] raw;<br>  public boolean equals(Object obj) {</p>
<pre><code>if (!obj instanceof Person)
  return false;
Person other = (Person)obj;
return name.equals(other.name)
    &amp;&amp; birthYear == other.birthYear
    &amp;&amp; Arrays.equals(raw, other.raw);
</code></pre><p>  }<br>  public int hashCode() { … }<br>}<br>参数必须是Object类型，不能是外围类。</p>
<p>foo.equals(null) 必须返回false，不能抛NullPointerException。（注意，null instanceof 任意类 总是返回false，<br>因此上面的代码可以运行。）</p>
<p>基本类型域（比如，int）的比较使用 == ，基本类型数组域的比较使用Arrays.equals()。</p>
<p>覆盖equals()时，记得要相应地覆盖 hashCode()，与 equals() 保持一致。</p>
<ol>
<li>实现hashCode()</li>
</ol>
<p>class Person {<br>  String a;<br>  Object b;<br>  byte c;<br>  int[] d;</p>
<p>  public int hashCode() {<br>    return a.hashCode() + b.hashCode() + c + Arrays.hashCode(d);<br>  }</p>
<p>  public boolean equals(Object o) { … }<br>}<br>当x和y两个对象具有x.equals(y) == true ，你必须要确保x.hashCode() == y.hashCode()。<br>根据逆反命题，如果x.hashCode() != y.hashCode()，那么x.equals(y) == false 必定成立。<br>你不需要保证，当x.equals(y) == false时，x.hashCode() != y.hashCode()。但是，如果你可以尽可能地使它成立的话，这会提高哈希表的性能。</p>
<p>3.实现compareTo()</p>
<p>class Person implements Comparable<person> {<br>  String firstName;<br>  String lastName;<br>  int birthdate;</person></p>
<p>  // Compare by firstName, break ties by lastName, finally break ties by birthdate<br>  public int compareTo(Person other) {<br>    if (firstName.compareTo(other.firstName) != 0)<br>      return firstName.compareTo(other.firstName);<br>    else if (lastName.compareTo(other.lastName) != 0)<br>      return lastName.compareTo(other.lastName);<br>    else if (birthdate &lt; other.birthdate)<br>      return -1;<br>    else if (birthdate &gt; other.birthdate)<br>      return 1;<br>    else<br>      return 0;<br>  }<br>}</p>
<p>4.实现clone()</p>
<p>class Values implements Cloneable {<br>  String abc;<br>  double foo;<br>  int[] bars;<br>  Date hired;</p>
<p>  public Values clone() {<br>    try {<br>      Values result = (Values)super.clone();<br>      result.bars = result.bars.clone();<br>      result.hired = result.hired.clone();<br>      return result;<br>    } catch (CloneNotSupportedException e) {  // Impossible<br>      throw new AssertionError(e);<br>    }<br>  }<br>}<br>使用 super.clone() 让Object类负责创建新的对象。<br>基本类型域都已经被正确地复制了。同样，我们不需要去克隆String和BigInteger等不可变类型。<br>手动对所有的非基本类型域（对象和数组）进行深度复制（deep copy）。<br>实现了Cloneable的类，clone()方法永远不要抛CloneNotSupportedException。因此，<br>需要捕获这个异常并忽略它，或者使用不受检异常（unchecked exception）包装它。</p>
<p>5.使用StringBuilder或StringBuffer</p>
<p>// join([“a”, “b”, “c”]) -&gt; “a and b and c”<br>String join(List<string> strs) {<br>  StringBuilder sb = new StringBuilder();<br>  boolean first = true;<br>  for (String s : strs) {<br>    if (first)<br>    first = false;<br>    else<br>    sb.append(“ and “);<br>    sb.append(s);<br>  }<br>  return sb.toString();<br>}<br>不要像这样使用重复的字符串连接：s += item ，因为它的时间效率是O(n^2)。<br>使用StringBuilder或者StringBuffer时，可以使用append()方法添加文本和使用toString()方法去获取连接起来的整个文本。<br>优先使用StringBuilder，因为它更快。StringBuffer的所有方法都是同步的，而你通常不需要同步的方法。</string></p>
<p>6.<br>Random rand = new Random();<br>System.out.println(rand.nextInt(6)+1);</p>
<p>7.使用Iterator.remove()</p>
<p>void filter(List<string> list) {<br>  for (Iterator<string> iter = list.iterator(); iter.hasNext(); ) {<br>    String item = iter.next();<br>    if (…)<br>      iter.remove();<br>  }<br>}</string></string></p>
<p>8.字符串反转(逆序)<br>public static String reverse(String s){<br>return new StringBuilder(s).reverse().toString();<br>}</p>
<p>9.启动线程<br>1)继承Thread类<br>class MyThread extends Thread{<br>public void run(){   …   }<br>}<br>new MyThread.start();<br>2) 实现Runnable接口<br>class MyRunnable implements Runnable{<br>public void run(){   …   }<br>}<br>new Thread(new MyRunnable()).start()<br>不要直接调用run()方法。总是调用Thread.start()方法，这个方法会创建一条新的线程并使新建的线程调用run()。</p>
<p>10.<br>如果try之前的语句运行失败并且抛出异常，那么finally语句块就不会执行<br>如果try语句块里面的语句抛出异常，那么程序的运行就会跳到finally语句块里执行尽可能多的语句，然后跳出这个方法（</p>
<ol>
<li>从输入流里读取字节数据</li>
</ol>
<p>InputStream in = (…);<br>try {<br>  while (true) {<br>    int b = in.read();<br>    if (b == -1)<br>      break;<br>    (… process b …)<br>  }<br>} finally {<br>  in.close();<br>}<br>read()方法要么返回下一次从流里读取的字节数（0到255，包括0和255），要么在达到流的末端时返回-1。</p>
<ol>
<li>从输入流里读取块数据</li>
</ol>
<p>InputStream in = (…);<br>try {<br>  byte[] buf = new byte[100];<br>  while (true) {<br>    int n = in.read(buf);<br>    if (n == -1)<br>      break;<br>    (… process buf with offset=0 and length=n …)<br>  }<br>} finally {<br>  in.close();<br>}<br>要记住的是，read()方法不一定会填满整个buf，所以你必须在处理逻辑中考虑返回的长度。</p>
<p>13.从文件里读取文本</p>
<p>BufferedReader in = new BufferedReader(<br>    new InputStreamReader(new FileInputStream(…), “UTF-8”));<br>try {<br>  while (true) {<br>    String line = in.readLine();<br>    if (line == null)<br>      break;<br>    (… process line …)<br>  }<br>} finally {<br>  in.close();<br>}<br>BufferedReader对象的创建显得很冗长。这是因为Java把字节和字符当成两个不同的概念来看待（这与C语言不同）。<br>你可以使用任何类型的InputStream来代替FileInputStream，比如socket。<br>当达到流的末端时，BufferedReader.readLine()会返回null。<br>要一次读取一个字符，使用Reader.read()方法。<br>你可以使用其他的字符编码而不使用UTF-8，但最好不要这样做。</p>
<p>14.向文件里写文本</p>
<p>PrintWriter out = new PrintWriter(<br>    new OutputStreamWriter(new FileOutputStream(…), “UTF-8”));<br>try {<br>  out.print(“Hello “);<br>  out.print(42);<br>  out.println(“ world!”);<br>} finally {<br>  out.close();<br>}<br>Printwriter对象的创建显得很冗长。这是因为Java把字节和字符当成两个不同的概念来看待（这与C语言不同）。<br>就像System.out，你可以使用print()和println()打印多种类型的值。<br>你可以使用其他的字符编码而不使用UTF-8，但最好不要这样做。</p>
<p>15.预防性检测（Defensive checking）数值<br>预防性检测对象<br>预防性检测数组索引<br>预防性检测数组区间</p>
<p>16.填充数组元素<br>byte[] a =new byte[10];<br>Arrays.fill(a,(byte)123);<br>for (byte b : a) {<br>System.out.println(b);<br>}</p>
<p>17.把4个字节包装（packing）成一个int</p>
<p>int packBigEndian(byte[] b) {<br>  return (b[0] &amp; 0xFF) &lt;&lt; 24<br>       | (b[1] &amp; 0xFF) &lt;&lt; 16<br>       | (b[2] &amp; 0xFF) &lt;&lt;  8<br>       | (b[3] &amp; 0xFF) &lt;&lt;  0;<br>}</p>
<p>int packLittleEndian(byte[] b) {<br>  return (b[0] &amp; 0xFF) &lt;&lt;  0<br>       | (b[1] &amp; 0xFF) &lt;&lt;  8<br>       | (b[2] &amp; 0xFF) &lt;&lt; 16<br>       | (b[3] &amp; 0xFF) &lt;&lt; 24;<br>}</p>
<p>18.把int分解（Unpacking）成4个字节</p>
<p>byte[] unpackBigEndian(int x) {<br>  return new byte[] {<br>    (byte)(x &gt;&gt;&gt; 24),<br>    (byte)(x &gt;&gt;&gt; 16),<br>    (byte)(x &gt;&gt;&gt;  8),<br>    (byte)(x &gt;&gt;&gt;  0)<br>  };<br>}</p>
<p>byte[] unpackLittleEndian(int x) {<br>  return new byte[] {<br>    (byte)(x &gt;&gt;&gt;  0),<br>    (byte)(x &gt;&gt;&gt;  8),<br>    (byte)(x &gt;&gt;&gt; 16),<br>    (byte)(x &gt;&gt;&gt; 24)<br>  };<br>}<br>总是使用无符号右移操作符（&gt;&gt;&gt;）对位进行包装（packing），不要使用算术右移操作符（&gt;&gt;）。</p>
<p>eg<br>public class RightDef{<br>  int num1 = num2+2;<br>  static int num2 = 0;<br>}<br>static 修饰的变量属于类，类变量会随着类初始化得到初始化，因此num2的初始化时机总是处于num1的初始化时机之前</p>
<p>使用 static 修饰的变量是类变量，没有使用 static 修饰的是实例变量<br>在同一个JVM中，每个类只对应一个Class对象，但每个类可以创建多个Java对象<br>同一个JVM内的类变量只需一块内存空间，但是该类每创建一次实例，就需要为实例变量分配内存空间<br>每个类初始化完成之后，系统都会为该类创建一个对应的Class实例，程序可以通过反射来获取某个类对应的Class实例。<br>eg: 要获取person类的Class实例。通过 Person.class 或者 Class.forName(“Person”);</p>
<p>通过实例来访问某个类变量的时候，底层依然会转换为通过类访问类变量。</p>
<p>实例变量的初始化时机：<br>1）定义实例变量时指定初始值<br>2）非静态初始化块中对实例变量指定初始值<br>3）构造器中对实例变量指定初始值<br>1和2先于3执行，1,2的顺序与他们在源程序中的排列顺序相同<br>eg:<br>public Cat(String name,int age){ … }<br>{weight=2.0}<br>double weight = 2.3<br>每次执行之后weight都是 2.3，因为非静态代码块在前面，先执行</p>
<p>类变量的初始化时机：<br>1）定义类变量时指定初始值<br>2）静态初始化块中对类变量指定初始值<br>这两种方式的执行顺序与他们在源程序中的排列顺序相同</p>
<p>final 可修饰变量，被final修饰的变量被赋值后不能重新赋值<br>final 可修饰方法，被final修饰的方法不能被重写<br>final 可修饰类  ，被final修饰的类不能派生子类</p>
<p>java<br>并发性和并行性区别：<br>并行是指在同一时刻，有多条指令在多个处理器上同事执行；并发是指在同一时刻只能有一条指令执行，<br>但多个的进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果</p>
<p>一个进程你可以拥有多个线程，一个线程必须有一个父进程。线程可以拥有自己的堆栈，自己的程序计数器和局部变量<br>但不拥有系统资源，它与父进程的其他线程共享 该进程所拥有的全部资源。<br>使用继承thread时获得当前线程对象比较简答，直接使用this就可以了；使用时限Runnable接口时要获得当前<br>对象必须使用Thread.currentThread()方法。</p>
<p>每个线程的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级<br>synchronized关键字可以i修饰方法，可以修饰代码块</p>
<p>yield让出cpu的使用权，让给同优先级的或者更高优先级的<br>join()线程等待被join的线程结束才继续运行</p>
<p>重写hashCode()方法和equals()方法<br>public int hashCode(){<br>return accountNo.hashCode();<br>}<br>public boolean equals(Object obj){<br>if(obj!=null&amp;&amp;obj.getClass()==Account.class){<br>Account target = (Account)obj;<br>return target.getAccountNo().equals(accountNo);<br>}<br>return false;<br>}</p>
<p>public synchronized void draw(){}通过synchronized关键字来声明加锁</p>
<p>Lock是控制多个线程对共享资源进行访问的工具。<br>class x{<br>private final ReentrantLock lock = new ReentrantLock();<br>public void m(){<br>lock.lock();<br>try{</p>
<p>}<br>finally}<br>lock.unlock();<br>}<br>}<br>加锁和释放锁要出现在一个块结构中，而且当获取了多个锁时，他们必须以相反的顺序释放<br>ReentrantLock锁具有重入性，也就是可以对已经加锁的ReentrantLock再次加锁。<br>Object类提供的wait(),notify()和notifyAll()三个方法，这三个方法不属于Thread类，而是属于Object<br>但这三个方法必须由同步监视器对象来调用，分为两种情况<br>1）使用synchronized修饰的同步方法，因为该类默认实例就是同步监视器，所以在同步方法中直接调用这三个方法<br>2）使用synchronized修饰的同步代码块，同步监视器是synchronized括号里的对象，必须使用该对象调用这三个方法</p>
<p>自定义线程捕获异常<br>package com.yu;<br>public class ExHandler {<br>public static void main(String[] args) {<br>Thread.currentThread().setUncaughtExceptionHandler(new MyExHandler());<br>int a = 5/0;<br>}<br>}<br>class MyExHandler implements Thread.UncaughtExceptionHandler{<br>@Overrideto<br>public void uncaughtException(Thread t, Throwable e) {<br>// TODO Auto-generated method stub<br>System.out.println(t+”线程出现问题”+e);<br>}<br>}</p>
<p>使用线程池可以很好的提高性能，尤其是当程序需要创建大量生存期很短暂的线程时，更应该考虑使用线程池<br>public class ThreadPoolTest {<br>public static void main(String[] args) {<br>ExecutorService pool = Executors.newFixedThreadPool(6);<br>pool.submit(new TestThread());<br>pool.submit(new TestThread());<br>pool.shutdown();<br>}<br>}<br>class TestThread implements Runnable{<br>@Override<br>public void run() {<br>// TODO Auto-generated method stub<br>for(int i = 0;i &lt; 100;i++){<br>System.out.println(Thread.currentThread().getName()+”的i为:”+i);<br>}<br>}<br>}</p>
<p>计算机网络协议通常由三部分组成，语义部分，用于决定给双方对话的类型；语法部分，用于决定双方对话的格式<br>变换规则，用于决定通信双方的应答关系</p>
<p>java为网络支持提供了java.net包，该包下的URL和URLConnection等类提供了以编程方式访问Web服务的功能<br>而URLDecoder和URLEncoder则提供了普通字符串和application/x-www-form-urlencoded MIME字符串相互转换的静态方法</p>
<p>多线程下载；如果要实现断点下载，则还需要额外增加一个配置文件（所有支持断点下载的工具都会在下载<br>开始生成两个文件，一个是与网络资源大小相同的文件夹，一个是配置文件），该配置文件分别记录每个线程<br>已经下载到了那个字节，当网络断开后再次开始下载时，每个线程根据配置文件里记录的位置向后下载即可</p>
<p>java使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信</p>
<p>java获取指定元素的节点<br>public static void main(String[] args) throws ParserException {<br>String url = “<a href="http://www.ttmeishi.com/CaiXi/" target="_blank" rel="external">http://www.ttmeishi.com/CaiXi/</a>“;<br>Parser parser = new Parser(url);<br>   parser.setEncoding(“utf-8”);<br>   NodeFilter filter = new TagNameFilter(“a”);<br>   NodeList list = parser.extractAllNodesThatMatch(filter);<br>System.out.println(list.toHtml());<br>= list.elementAt(1);<br>}</p>
<p>byte  -128 ~ 127<br>short -32768 ~ 32767<br>NullPointerException 空指针异常，引用数据类型，观察其是否被正确实例化<br>匿名对象 new Person(“zhang”,20).tell()<br>数组静态初始化： int[] data = new int[]{20,32,32}<br>数组动态初始化： int[] data = new int[3]<br>数组排序  Arrays.sort(data)<br>System.arrayCopy(dataB,5,dataA,2,3);<br>每一个字符串都是String的匿名对象。<br>在String类进行设计的时候采用了一种共享设计模式的概念，在每一个运行的JVM层存在一个字符串的对象池，如果用户直接赋值，会将字符串<br>放入到池中，以供其他继续使用直接赋值方式的String对象使用。</p>
<p>String str = new String(“hello”)创建了两个实例化对象，一个是String类的匿名对象hello，一个是使用关键字new实例化的String对象</p>
<p>String类的常用方法：<br>字符串与字符：<br>public String(char[] value) 将全部的字符数组 ——&gt; 字符串<br>public String(char[] value,int offset,int count)  将部分字符数组变为字符串<br>public charAt(int index)  取得指定索引位置上的字符<br>public char[] toCharArray()  将字符串—–&gt; 字符数组<br>字符串与字节<br>public String(byte[] bytes)<br>public String(byte[] bytes,int offset,int length)<br>public byte[] getBytes()<br>public Bytes[] getBytes(String charSetName)<br>字符串比较： equals(String str)   equalsIgnoreCase(String str)   compareTo(String str)<br>字符串查找<br>public boolean contains(String s)<br>public int indexOf(String s) //查找字符串的位置<br>public int indexOf(String str,int fromIndex)<br>public int lastIndexOf(String str)<br>public int lastIndexOf(String str,int fromIndex)<br>public boolean startsWith(String prefix)  //是否以指定字符串开头<br>public boolean startsWith(String prefix,int offset)<br>public boolean endsWith(String suffix)<br>字符串替换<br>public String replaceAll(String regex,String replacement)<br>public String replaceFirst(String regex,String replacement)<br>字符串截取：<br>public String subString(int beginIndex)<br>public String subString(int beginIndex,int endIndex)<br>字符串拆分：<br>public String[] split(String regex)<br>public String[] split(String regex,int limit)<br>其他方法：<br>public boolean isEmpty()<br>public int length()<br>public String trim()<br>public String toLowerCase()<br>public String toUpperCase()<br>public String concat(String str)</p>
<p>引用传递：<br>public static void main(String args[]){<br>String str = “hello”;<br>fun(str);<br>System.out.println(str);</p>
<p>}<br>public static void fun(){<br>temp = “world”;<br>}<br>结果输出  hello，因为temp改变了指向</p>
<p>static 定义的属性保存在全局数据区， 使用 类名称.static属性 的方式来完成<br>java主要存在四块内存空间<br>1.栈内存空间，保存所有的对象名称<br>2.堆内存空间 保存每个对象的具体属性内容<br>3.全局数据区 保存static类型的属性<br>4.全局代码区  保存所有的方法定义</p>
<p>private static int count = 0;<br>public Person(){<br>System.out.println(“num is:” + ++count);<br>}<br>public static void main(String[] args) {<br>new Person();<br>new Person();<br>new Person();<br>}</p>
<p>代码块有 普通代码块，构造块，静态块<br>构造块优先于构造方法执行<br>静态块优先于构造块执行，而且不管有多少个实例化对象产生，静态块只会执行一次，主要作用是为类中的static属性初始化<br>主类中的静态块的执行优先于主方法</p>
<p>内部类的用法:<br>class Outer{<br>private String msg=”hello”;<br>class Inner{<br>public void print(){<br>System.out.println(msg);<br>}<br>}<br>public void fun(){<br>Inner in = new Inner();<br>in.print();<br>}<br>}<br>public  class TestDemo{<br>public static void main(String[] args) {<br>Outer out = new Outer();<br>out.fun();<br>}<br>}</p>
<p>子类对象的实例化操作会调用父类的构造方法，super调用父类构造时一定要放在构造方法的首行上。<br>final:<br>1.final修饰的类不能有子类，无法被其他类继承。<br>2.使用final定义的方法不能被子类所重写<br>3.使用final定义的变量，就表示敞亮，常量在定义时必须设置默认值，且不能修改。</p>
<p>构造方法私有化—&gt; 隐藏构造方法，单例模式<br>eg:<br>class Singleton{<br>private final static Singleton instance = new Singleton();<br>private Singleton(){}<br>public static Singleton getInstance()<br>{return instance;}<br>public void print(){<br>System.out.println(“hello”);<br>}<br>}<br>public class Test{<br>public static void main(String args[]){<br>Singleton inst = Singleton.getInstance();<br>inst.print();<br>}<br>}</p>
<p>如果在try语句中有一个return语句，那么紧跟在try后面的finally一定会被之星，并且是在return 前执行<br>RuntimeException和Exception区别，并列举出 几个常见的RuntimeException<br>Exception定义了必须处理的异常，而RuntimeException定义的异常可以选择性的进行处理<br>RuntimeException是Exception的子类，常见的RuntimeException有： NumberFormatException ClassCastException NullPointerException<br>ArithmeticException ArrayIndexOutOfBoundException</p>
<p>断言指的是程序执行到某行后，其结果一定是预期的结果<br>自定义异常：<br>class MyException extends Exception{<br>public MyException(String msg) {<br>// TODO Auto-generated constructor stub<br>super(msg);<br>}<br>}<br>main:  throw new MyException(“it’s a exception”);<br>异常是导致程序中断运行的一种指令流<br>throws用在方法声明处，表示本方法不处理异常<br>throw表示在方法中手工抛出一个异常<br>不同包的同名类，则导入的时候要指定完整名称 eg: cn.mldn.util.Message msg = new cn.mldn.util.Message()</p>
<p>命名规范：<br>类名称  每一个单词的开头首字母大写，如TestDemo<br>变量名称 第一个单词的首字母小写，之后每个单词的首字母大写 如stuName<br>方法名称  第一个单词的首字母小写，之后每个单词的首字母大写 如 printInfo()<br>常量名称  每个字母大写 如FLAG<br>包名称  所有字母小写  如 cn.mldnjava.util</p>
<p>可变参数： 可以比较直观的传递任意多个参数<br>public static int add(int… data) {<br>int sum = 0;<br>for (int x = 0; x &lt; data.length; x++) {<br>sum += data[x];<br>}<br>return sum;<br>}</p>
<p>foreach 语句<br>for(int x:data){<br>sum+=x;<br>}</p>
<p>泛型：类中操作的属性或方法的参数类型不在定义时声明，而是在使用时动态设置<br>枚举来写多例设计模式<br>enum Color{<br>RED,GREEN,BLUE;<br>}<br>Color c = Color.RED;</p>
<p>jdk1.7之后，switch可以操作Strint数据<br>可以使用通配符？接受全部的泛型类型对象<br>通过&lt;？extend 类&gt;可以设置泛型的上限，&lt;？super 类&gt;可以设置泛型的下限<br>在java中使用enum关键字定义一个枚举类，每个枚举类都是集成Enum类<br>enum Color{<br>RED,GREEN,BLUE;<br>}<br>for(Color c:Color.values())  //取得全部的枚举值<br>System.out.println(c.ordinal()+” “ + c.name())</p>
<p>线程的命名和取得<br>public Thread(Runnable target ,String name)  //实例化线程对象，接受Runnable接口子类对象，同时设置线程名称<br>public final void setName(String name) //设置线程名称<br>public final String getName()  //取得线程名称<br>线程的休眠  在run方法中，Thread.sleep(100)   System.out.println(Thread.currentThread().getName())<br>线程优先级设置<br>public static final int MAX_PRIORITY<br>public static final int NORM_PRIORITY<br>public static final int MIN_PRIOTITY<br>public final void setPriority(int newPriority) // Runnable mt = new Runnable() ; Thread t = new Thread(mt,”线程A”)<br>public final int getPriority() //  t.setPriority(Thread.MAX_PRIORITY)  System.out.println(Thread.currentThread().getPriority())</p>
<p>同步：使用同步代码块，或者使用同步方法<br>同步代码块只需要在执行的大括号前加上 synchronized(this)<br>同步方法 public synchronized void sale()<br>static native synchronized 都不能和abstract同时声明方法</p>
<p>解决重复的问题需要等待及唤醒机制，这一机制的实现只能依靠Object类完成，Object定义了3个方法来完成线程操作<br>public final void wait() throws InterruptedException<br>public final void notify()<br>public final void nofityAll()</p>
<p>sleep()和wait()区别<br>sleep是Thread类定义的static方法，表示线程休眠，将执行机会让给其他线程，但监控状态依然保持，到时候会自动恢复<br>wati是Object类定义的方法，表示线程等待，一直到执行了notify或notifyAll方法后才结束</p>
<p>一般 通过设置一个标志位的方式停止一个线程的运行<br>String不适合被频繁修改的字符串，这种情况下可以使用StringBuffer，方便用户进行内容的修改<br>一个类是否可以继承String类？ 不能，String类使用了final定义，不能被其他类继承</p>
<p>操作一：将String变为StringBuffer<br>方法一 利用StringBuffer的构造方法   public StringBuffer(String str)  —&gt; StringBuffer bf = new StringBuffer(str);<br>方法二   StringBuffer的append()方法   buf.append(str)</p>
<p>操作二 将StringBuffer变为String  StringBuffer的toString()方法  String str = buf.toString() 方法<br>StringBuffer常用方法：<br>bf.reverse()  bf.replace(int start,int end,String str)  br.insert(int offset,数据)</p>
<p>System类提供了两个常用方法：<br>public static void arrayCopy(Object src,int srcPos,Object dest,int destPos,int length)<br>public static long currentTimeMillis()<br>eg:long start = System.currentTimeMillis();    long end = System.currentTimeMillis(); —&gt;(end - start)<br>日期操作类<br>public Date()<br>public Date(long date) //将数字变为Date类对象，long为日期时间数据<br>eg: Date date = new Date(System.currentTimeMillis());<br>public long getTime()  //将当期那日期时间变为long型<br>eg: Date date = new Date();<br>long num = date.getTime();</p>
<p>日期格式化操作类 SimpleDateformat<br>public SimpleDateFormat(String pattern)  //传入日期时间标记实例化对象<br>public final String format(Date date)   //将日期格式化为字符串数据<br>public Date parse(String source) throws ParserException  //将字符串格式化为日期数据<br>eg:<br>Date date = new Date();<br>SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);<br>String str = sdf.format(date);   —–&gt;   2015-04-28 11:13:54   //日期格式化为字符串</p>
<p>eg:<br>String str = “1991-08-20 12:12:12.122”;<br>SimpleDateFormat sdf = new SimpleDateFormat(“yy-MM-dd HH:mm:ss.SSS”);<br>Date date = sdf.parse(str);   //将字符串格式化为日期数据</p>
<p>Random类<br>Random rand = new Random();  rand.nextInt(101);<br>大数字操作类：<br>java.math.BigInteger和java.math.BigDecimal 这两个类属于Number的子类<br>数组操作类： Arrays类<br>public static boolean equals(int[] a,int[] b)  //Arrays.equals(dataA,dataB)<br>public static void fill(int[] a,int val)   //Arrays.fill(dataA,3)<br>public static void sort(int[] a)   //Arrays.sort(dataA)<br>public static int binarySearch(int[] a,int key)    //Arrays.binarySearch(dataA,key)<br>public static String toString(int[] a)  //Arrays.toString(dataA)<br>普通的对象数组是不能够进行比较的，如果要比较需要比较器（Comparable接口就是一种比较器）的支持</p>
<p>比较器：<br>欲进行比较，需要实现Comparable接口<br>public class Person implements Comparable<person><br>重写compareTo方法<br>public int compareTo(Person o){<br>if(this.age &gt; o.age){<br>return 1;<br>}else if(this.age &lt; o.age){<br>return -1;<br>}else{<br>return 0;<br>}<br>}</person></p>
<p>对象克隆<br>实现Cloneable接口，但这个接口属于标识接口，只表示一种能力。<br>class Person implements Cloneable{  }<br>@Override<br>public String toString(){return “  “;}<br>@Override<br>protected Object clone() throws CloneNotSupportedException<br> {return super.clone();}</p>
<p>正则表达式<br>所有正则匹配的符号都在  java.util.regex.Pattern  类中进行定义<br>//  \ 匹配转移字符 “\”<br>\t匹配转移字符”\t”<br>^开始<br>$结束<br>.标识任意的一位字符<br>\d  表示任意的一位数字  \D非数字<br>\w 任意的一位字母,数字，下划线      \W非字母，数字，下划线<br>？0或1次</p>
<ul>
<li>0次，1次或多次</li>
</ul>
<ul>
<li>1次或多次<br>{n} 正好n次<br>{n,} n次以上<br>{n,m} 最少n次，最多m次<br>eg: 123.1   regex = “\d+(\.\d+)”<br>String类对正则的支持<br>public boolean matches(String regex)   str.matches(regex)<br>public String replaceAll(String regex,String replacement)<br>public String[] split(String regex )<br>eg: String str = “a1bb2cc3dddd4eeeee5fff6eddd7oooo8iiiiii9”;<br>String regex=”\d”;<br>String result[] = str.split(regex);<br>public String[] split(String regex,int limit)</li>
</ul>
<p>字符串—&gt; 数字<br>int data = Integer.parseInt(str)<br>double data = Double.parseDouble(str)<br>表示任意一个用[],如[a-zA-z0-9\.]，表示或者关系的用(xx|yy)<br>判断电话号码的regex      String regex = “((\d{3,4}|\(\d{3,4}\))-?)?\d{7,8}”;<br>简单的邮箱地址验证 String regex = “[a-zA-Z][a-zA-Z0-9]*@[a-zA-Z_0-9\.]+\.(com|cn|net)”</p>
<p>反射<br>Java IO操作<br>所有的IO操作都在java.io包中进行定义，而且整个java.io包实际上就是五个类和一个接口<br>五个类：File InputStrearm OutStream Reader Writer<br>一个接口： Serializable<br>public File(String pathname)  构造方法，给定一个要操作文件的完整路径<br>File file = new File(“D:\demo.txt”);<br>file.exists()  file.createNewFile()  file.delete()<br>public boolean createNewFile() throws ArrayIndexOutOfBoundException<br>public boolean delete()<br>public boolean exists()<br>File file = new File(“D:”+File.separator+”demo.txt”);   File.separator是为了在不同平台运行</p>
<p>创建有目录的文件<br>public File getParentFile()  找到一个指定路径的父路径<br>public boolean mkdirs()   创建指定目录<br>File file = new File(“D:”+File.separator+”hello”+File.separator+”test”+File.separator+”demo.txt”);<br>if(!file.getParentFile().exists()){<br>file.getParentFile().mkdirs();            //若不存在父文件，则创建之<br>}<br>if(file.exists()){<br>file.delete();        //若文件不存在，创建之<br>}else{<br>file.createNewFile();<br>}</p>
<p>File的其他用法：<br>public String getName()   //取得文件名称<br>public boolean isDirectory()<br>public boolean isFile()  //file.isFile()<br>public boolean isHidden()<br>public long lastModified()   //文件的最后一次修改日期<br>public long length()  //取得文件大小，以字节为单位返回<br>public boolean renameTo(File dest)   //为文件重命名      file.renameTo(newName)<br>public File[] listFiles()   //将目录中所有文件以File对象数组的方式返回   File result[] = file.listFiles()<br>递归输出目录下的文件<br>public static void print(File file){<br>if(file.isDirectory()){<br>File result[] = file.listFiles();<br>if(result!=null){<br>for(int x = 0; x &lt; result.length; x++)<br>print(result[x]);<br>}<br>}<br>System.out.println(file);<br>}</p>
<p>字节操作流  OutputStream  InputStream<br>字符操作流  Writer  Reader</p>
<p>FileOutputStream类的构造方法：<br>public FileOutputStream(FIle file) throws FileNotFoundException  实例化FileOutputStream，主要用于新建数据<br>public FileOutputStream(File file,boolean append) throws FileNotFoundException   主要用于追加数据<br>OutputStream定义的方法<br>pubic FileOutpubStream(File file)throws FileNotFoundExceptin<br>public void write(byte[] b) throws IOException<br>public void write(byte[] b,int off,int len) throws IOException<br>对于OutputStream而言，它本身定义的是一个抽象类，按照抽象类的使用原则，需要定义抽象类的子类，子类要为抽象类进行对象的实例化<br>而后调用的方法以父类为主，而具体的实现是实例化这个父类的子类完成的，关心的是子类的构造方法。</p>
<p>InputStream定义方法：<br>public abstract int read() throws IOException   //读取一个字节，到结尾返回 -1<br>public int read(byte[] b)throws IOException   //读取多个字节，返回的是读取的数据个数<br>public int read(byte[] b,int off,int len) throws IOException</p>
<p>如果希望对输出的内容增加换行显示，可以使用”\r\n”来表示<br>eg：把内容输出到指定文件<br> File file = new File(“D:”+File.separator+”test.txt”);<br>OutputStream output = new FileOutputStream(file);</p>
<h2 id="OutputStream-output-new-FileOutputStream-file-true-true表示追加数据"><a href="#OutputStream-output-new-FileOutputStream-file-true-true表示追加数据" class="headerlink" title="## OutputStream output = new FileOutputStream(file,true); true表示追加数据"></a>## OutputStream output = new FileOutputStream(file,true); true表示追加数据</h2><p>String data = “hello world”;<br>output.write(data.getBytes());<br>output.close();<br>eg:从指定文件读取内容：<br> InputStream input = new FileInputStream(file);<br>byte[] data = new byte[1024];<br>int len = input.read(data);<br>input.close();<br>System.out.println(“data is:”+new String(data,0,len));</p>
<p>字节流和字符流的区别<br>字节流在IO操作时，直接针对的是操作的数据端(如文件)，而字符流操作时不是直接针对于终端，而是针对于缓存区的操作，而后由缓存区<br>操作终端，属于间接操作。<br>字节流没有使用缓冲区，而字符流使用了缓冲区<br>处理各种数据都可以通过字节流完成，而在处理中文时使用字符流会更好</p>
<p>单个字节读取：<br>while((temp=input.read())!=-1){<br>data[foot++]=(byte) temp;<br>}<br>字符输出流 Writer类本身是一个抽象类，那么要使用它依然要依靠其子类，比如FileWriter类<br>public abstract void close() throws IOException<br>public void write(String str) throws IOException<br>public void wirte(char[] buf) throws IOException<br>public abstract void flush() throws IOException<br>eg:<br>Writer out = new FileWriter(file);<br>String data = “\r\nnice to meet you .\n”;<br>out.write(data);        //直接把字符串输出到文件中<br>out.close();</p>
<p>字符输入流<br>public abstract void close() throws IOException<br>public int read() throws IOException<br>public int read(char[] cbuf) throws IOException<br>Reader in = new FileReader(file);<br>char data[] = new char[1024];<br>int len = in.read(data);<br>System.out.println(“data is:” +new String(data,0,len));<br>in.close();</p>
<p>转换流<br>将字节输出流变为字符输出流 OutputSteam -&gt; Writer   OutputStreamWriter<br>将字节输入流变为字符输入流 InputStream -&gt;Reader   InputStreamReader<br>eg:<br>OutputStream output = new FileOutputStream(file);<br>Writer out = new OutputStreamWriter(output);<br>out.write(“hello world”);<br>out.close();</p>
<p>InputStream抽象类下面 有   FileInputStream 和 ByteArrayInputStream<br>OutputStream抽象类下面有   FileOutputStream 和 ByteArrayOutputStream</p>
<p>缓冲区操作 BufferedReader de 构造方法： public BufferedReader(Reader in)<br>读取操作  public String readLine() throws IOException</p>
<p>BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));<br>String str = buf.readLine()      //利用BufferedReader进行循环判断<br>if(str.matches(“\d+”)){</p>
<p>num = Integer.parseInt(str);</p>
<p>System.out.println(num*num);</p>
<p>}<br>Scanner 方法<br>pubic Scanner(InputStream source)<br>public boolean hasNext(Pattern pattern)  //判断输入的数据是否符合指定的正则标准<br>public boolean hasNext()  //判断有输入内容<br>public boolean hasNextxxx()  //判断输入的是否为指定的数据类型<br>public String next()          //接受内容<br>public String next(Pattern pattern)  //接受内容，进行正则验证<br>public int nextXxx()   //接受指定的输入类型<br>public Scanner useDelimiter(String pattern)      sn.useDelimiter(“\n”);    //设置读取的分隔符<br>由输入验证生日：<br>eg:<br>if(sn.hasNext(“\d{4}-\d{2}-\d{2}”)){<br>String str = sn.next(“\d{4}-\d{2}-\d{2}”);<br>Date date = new SimpleDateFormat(“yyyy-MM-dd”).parse(str);</p>
<p>对象序列化<br>对象序列指的是可以将内存中保存的对象数据（主要指的是一个对象里面所包含属性内容）进行二进制数据传输的一种操作，要想<br>实现这样的二进制操作，对象所在的类就必须实现java.io.Serializable 接口（这个接口和Cloneable接口一样，都属于一种标识接口<br>表示一种能力）可以使用transient关键字定义不被序列化的属性。</p>
<p>ServerSocket类的常用操作方法<br>public ServerSocket(int port) throws IOException<br>public Socket accept() throws IOException<br>public void close() throws IOException<br>Socket的常用操作方法<br>public Socket(String host,int port)<br>public OutputStream getOutputStream()<br>public InputStream getInputStream()</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大型网站技术架构核心原理与案例分析]]></title>
      <url>http://yoursite.com/2016/05/12/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="大型网站总览"><a href="#大型网站总览" class="headerlink" title="大型网站总览"></a>大型网站总览</h3><p>大型网站目标：打造一个高可用、高性能、易扩展、可伸缩且安全的网站<br>大型网站特点：高并发大流量、高可用、海量数据、用户分布广泛网络情况复杂、需求快速变更、渐进式发展<br>大型网站发展历程：先是应用和服务分开部署，然后使用缓存改善网站性能，80%的业务访问几种在20%的数据上，把这一小部分的数据缓存在内存中，可以减少数据库的压力，提高整个网站的数据访问速度，改善数据库的写入性能。缓存分两种：应用服务器上的本地缓存和缓存在专门的分布式缓存服务器上的远程缓存，部署大内存的服务器作为专门的缓存服务器此时，数据访问压力缓解，瓶颈在于应用服务器的请求连接有限，可以通过负载均衡调度服务器，将访问请求分发到应用服务器集群中的任何一台服务器上采用缓存后，缓存访问不命中，魂村过期和全部的写操作需要访问数据库，当用户达到一定规模时，数据库因为负载压力过高成为瓶颈，目前大多数数据库提供主从热备功能，实现数据库读写分离，改善数据库负载压力。为了加速网站访问速度，使用CDN和反向代理。CDN和反向代理的原理都是缓存，区别在与CDN部署在网络提供商的机房，使用户在请求网站服务时，可以从距离最近的网络提供商机房获取数据；而反向代理则部署在网站的中心机房，当用户请求到达中心机房时，首先访问的服务器时反向代理服务器，如果反向代理服务器缓存着用户请求的资源，就将其直接返回给用户。数据库读写分离后，进一步就是拆分数据，业务分库，将不同业务的数据库部署在不同的物理服务器上，进而分布式数据库，还可以采用NoSQL和非数据库查询技术如搜索引擎。继而业务拆分，将网站业务分成不同的产品线。最后是分布式服务，既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理，商品管理，那么可以将这些共用的业务提取出来，独立部署，同构分布式服务调用共用业务服务完成具体业务操作。<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-11/20476640.jpg" alt="网站分布式服务架构图"></p>
<h4 id="分布式可能带来的问题"><a href="#分布式可能带来的问题" class="headerlink" title="分布式可能带来的问题"></a>分布式可能带来的问题</h4><ol>
<li>分布式服务调用必须通过网络，可能会对性能造成比较严重的影响</li>
<li>服务器越多，服务宕机的概率也就越大，使网站可用性降低</li>
<li>保持数据一致性也非常困难</li>
<li>分布式事务也难以保证，开发管理维护困难</li>
</ol>
<h3 id="大型网站的架构模式"><a href="#大型网站的架构模式" class="headerlink" title="大型网站的架构模式"></a>大型网站的架构模式</h3><ol>
<li>分层，分成应用层，服务层，数据层等</li>
<li>分割，业务分割，由不同团队维护</li>
<li>分布式<br>3.1 分布式应用和服务  不同应用复用共同的服务，便于业务功能扩展<br>3.2 分布式静态资源   动静分离，静态资源分布式部署可以减轻应用服务器负载压力，使用独立域名加快浏览器并发加载的速度<br>3.3 分布式数据和存储   对传统的关系数据库分布式部署，也使用NoSQL<br>3.4 分布式计算<br>还有支持网站线上服务器配置实时更新的分布式配置；分布式环境下实现并发和协同的分布式锁，支持云存储的分布式文件系统等</li>
<li>集群，提高可用性</li>
<li>缓存<br>5.1 CDN，如视频网站和门户网站会将用户访问量大的热点内容缓存在CDN<br>5.2 反向代理，缓存网站静态资源，无需将请求继续转发给应用服务器就能返回给用户<br>5.3 本地缓存<br>5.4 分布式缓存</li>
<li>异步<br>降低软件耦合性，除了分层、分割、分布还有一个重要手段就是异步，在单一服务器内部通过多线程共享内存队列的方式实现异步；在分布式系统中，多个服务器集群同构分布式消息队列实现异步，可以提高系统可用性、加快网站响应速度、消除并发访问高峰</li>
<li>冗余 冷备份、热备份</li>
<li>自动化<br>自动化代码管理、自动化测试、自动化安全检测、自动化部署、自动化监控、自动化报警、自动化失效转移、自动化失效恢复、自动化降低、自动化分配资源</li>
<li>安全<br>通过手机校验码和密码进行身份认证<br>登录、交易等操作需要对网络通信进行加密，网站服务器上存储的敏感数据也进行加密处理<br>防止机器人程序滥用网络资源攻击，使用验证码进行识别<br>对于XSS攻击，SQL注入，进行编码转换等<br>对于垃圾信息、敏感信息进行过滤<br>对交易转账等重要操作根据交易模式和交易信息进行风险控制</li>
</ol>
<p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-11/12633389.jpg" alt="微博架构"><br>在早期，用户发表微博后将这条微博插入到数据库所有粉丝的订阅列表中，当用户量比较大时，发布微博会引起大量的数据库写操作，性能急剧下降；后来微博改用异步推拉结合的模式，用户发表微博后，系统将微博写入消息放入消息队列后立即返回，用户响应迅速，消息队列消费者任务将微博推送给所有当前在线粉丝的订阅列表中，非在线用户登录后再根据关注列表拉取微博订阅列表。由于刷新频繁，采用多级缓存策略，在线用户的微博和近期微博缓存在分布式缓存急群众，对于微博中最常见的刷微博，几乎全部都是缓存访问操作，可以获得很好的性能。</p>
<h4 id="可用性-amp-amp-伸缩性-amp-amp-扩展性"><a href="#可用性-amp-amp-伸缩性-amp-amp-扩展性" class="headerlink" title="可用性 &amp;&amp; 伸缩性 &amp;&amp; 扩展性"></a>可用性 &amp;&amp; 伸缩性 &amp;&amp; 扩展性</h4><p>可用性：衡量一个系统架构设计是否满足高可用性，就是假设系统中任何一台或者多台服务器宕机时，以及出现各种不可预期的问题时，系统整体是否依然可用<br>伸缩性：是指通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。<br>扩展性：衡量架构扩展性好坏的标准就是在网站增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或很少改动既有业务功能就可以上线新产品</p>
<h3 id="网站的高性能架构"><a href="#网站的高性能架构" class="headerlink" title="网站的高性能架构"></a>网站的高性能架构</h3><p>网站性能测试主要指标有响应时间、并发数、吞吐量、性能计数器等<br>并发数： 网站系统用户数&gt;&gt;网站在线用户数&gt;&gt;网站并发用户数<br>测试程序通过多线程模拟并发用户的办法来测试系统的并发处理能力，在两次请求之间加一个随机等待时间，这个时间被称为思考时间<br>吞吐量：TPS(每秒事务数) HPS(每秒HTTP请求数)、QPS(每秒查询数)<br>性能计数器：System Load，对象与线程数、内存使用、CPU使用、磁盘与网络I/O等指标<br>性能测试方法：<br>性能是一个总称，具体细分为：性能测试、负载测试、压力测试、稳定性测试<br>为了更好的模拟生产环境，稳定性测试也应不均匀的读系统施加压力。</p>
<h4 id="Web前端性能优化"><a href="#Web前端性能优化" class="headerlink" title="Web前端性能优化"></a>Web前端性能优化</h4><ol>
<li>减少http请求<br>合并CSS,合并javascript，合并图片将浏览器一次请求需要的javascript，css合并成一个文件，图片也可以合并，多张图片合并成一张，可通过css偏移响应鼠标点击操作，构造不同的url</li>
<li>使用浏览器缓存<br>通过设置HTTP头中cache-control和expires的属性，设定浏览器缓存</li>
<li>启用压缩<br>可有效减少通信传输的数据量。文本文件的压缩效率可达80%以上</li>
<li>减少Cookie传输<br>减少Cookie中传输的数据量，可以考虑静态资源使用独立域名访问，避免请求资源时发送Cookie，减少Cookie传输的次数。<br>还有CDN加速，反向代理</li>
</ol>
<h4 id="应用服务器性能优化"><a href="#应用服务器性能优化" class="headerlink" title="应用服务器性能优化"></a>应用服务器性能优化</h4><p>可以对数据缓存，也可以对文件缓存，还可以对页面片段缓存<br>网站性能优化第一定律：优先考虑使用缓存优化性能</p>
<ol>
<li>缓存的基本原理：<br>一方面缓存访问速度快，可以减少数据访问的时间；另一方面如果缓存的数据是经过计算处理得到的，那被缓存的数据无需重复计算即可使用，减少计算量。<br>缓存本质是一个内存Hash表数据缓存以key,value形式存储在内存中，读写时间复杂度为O(1)。缓存主要用来存放那些读写比很高，很少变化的数据，如商品的类目信息，热门词的搜索列表信息，热门商品信息等，应用程序读取数据时，先到缓存中读取，读不到或数据已失效，再访问数据库，并将数据写入缓存。<br>二八定律：即80%的访问落在20%的数据上，因此利用Hash表和内存的告诉访问特性，将这20%的数据缓存起来，可很好的改善系统性能，提高数据读取速度，降低存储访问压力。</li>
<li>异步处理</li>
<li>使用集群</li>
<li>代码优化<br>4.1 多线程<br>解决线程安全的手段有：</li>
<li>将对象设计为无状态对象，java web开发中常用的Servlet对象就设计为无状态对象</li>
<li>使用局部对象</li>
<li>并发访问资源上锁<br>3.资源复用 ：单例和对象池</li>
</ol>
<h4 id="存储性能优化"><a href="#存储性能优化" class="headerlink" title="存储性能优化"></a>存储性能优化</h4><p>B+树是一种专门针对磁盘存储而优化的N叉排序树，目前NoSQL都采用LSM树作为主要数据结构，LSM树可以看做是一个N阶合并树。当数据访问以写操作为主，而读操作集中在最近写入的数据上时，使用LSM树可以极大程度减少磁盘的访问次数，加快访问速度。<br>RAID磁盘阵列 、 HDFS</p>
<h3 id="第五章-网站高可用架构"><a href="#第五章-网站高可用架构" class="headerlink" title="第五章 网站高可用架构"></a>第五章 网站高可用架构</h3><p>应用层：会通过负载均衡将一组服务器组成一个集群共同对外提供服务，当负载均衡器通过心跳检测等手段监控到某台应用服务器不可用时，就将其从集群列表中剔除，并将请求分发到集群中其他可用的服务器上。<br>服务层：分布式服务调用框架会在应用层客户端程序中实现软件负载均衡，并通过服务注册中心对提供服务的服务器进行心跳检测，发现有服务不可用，立即通知客户端程序修改服务访问列表，剔除不可用的服务。<br>数据层：主从复制</p>
<h4 id="高可用的应用"><a href="#高可用的应用" class="headerlink" title="高可用的应用"></a>高可用的应用</h4><ol>
<li>通过负载均衡进行无状态服务的失效转移</li>
<li>应用服务器集群的Session管理<br>2.1 Session复制，通信量太大，不适用<br>2.2 Session绑定，将来源于同一IP的请求分发到同一台服务器上，即Session绑定在某台服务器，会话黏滞，缺点，宕机会丢失Session<br>2.3 利用Cookie记录Session，将Session记录在客户端，每次请求服务器的时候，将Session放在请求中发送给服务器，服务器处理完请求后再将修改过的session响应给客户端。缺点：受Cookie大小限制、关闭Cookie不起作用<br>2.3 Session服务器，利用独立部署的Session服务区集群统一管理Session,应用服务器每次读写Session时，都访问Session服务器（无状态和有状态的Session服务器）</li>
</ol>
<h4 id="高可用的服务"><a href="#高可用的服务" class="headerlink" title="高可用的服务"></a>高可用的服务</h4><p>可复用的服务模块为业务产品提供基础公共服务，大型网站中这些服务通常都独立分布式部署，被具体应用远程调用。可复用的服务和应用一样，也是无状态的服务，因此可以使用类似负载均衡的失效转移策略实现高可用的服务</p>
<ol>
<li>分级管理<br>将服务器进行分级管理，核心应用和服务优先使用更好的硬件，显然，用户及时付款购物比能不能评价商品更重要，所以订单、支付服务比评价服务有更高优先级。高优先级的服务需要部署在不同的物理机上。</li>
<li>超时设置<br>由于服务端宕机、线程死锁等原因，可能导致应用程序对服务端调用失去响应，应在应用程序中设置服务调用的超时时间，一旦超时，根据服务调度策略，选择重试或失效转移</li>
<li>异步调用<br>应用对服务的调用通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。</li>
<li>服务降级<br>降级有两种：拒绝服务或关闭服务，淘宝在双十一系统最繁忙时段关闭“评价”，“确认收货”服务，保证核心交易服务的顺利完成</li>
<li>幂等性<br>幂等性就是重复多次执行结果不变，作用一样，比如设置性别为男。转账操作不符合幂等性</li>
</ol>
<h4 id="高可用的数据"><a href="#高可用的数据" class="headerlink" title="高可用的数据"></a>高可用的数据</h4><p>缓存服务器宕机引起缓存数据丢失导致服务器复杂压力过高应该通过其他手段解决，而不是提高缓存服务本身的高可用。理想情况下任何一台服务器宕机引起的缓存失效都只影响应用缓存数据的一小部分，不会对应用性能和数据库负载造成太大影响。<br>CAP理论认为，一个提供数据服务的存储系统无法同时满足数据一致性(Consistency)，数据可用性(Availibility)，分区容忍性(Partition Tolerance)，分区容忍性是必须的，一般都会保证可用性和分区容忍性，在一定程度上放弃一致性<br>数据一致性分为</p>
<ol>
<li>数据强一致<br>各个副本的数据在物理存储中总是一致的，数据更新操作结果和操作响应总是一致的，即操作响应通知更新失败，那么数据一定没有被更新，而不是处于不确定状态</li>
<li>数据用户一致<br>即数据在物理存储中的各个副本的数据可能是不一致的，但终端用户访问时，同构纠错和校验机制，可以确定一个一致的且正确的数据返回给用户</li>
<li><p>数据最终一致<br>系统经过一段时间的自我恢复和修正，数据最终达到一致。</p>
</li>
<li><p>数据备份<br>主从热备</p>
</li>
<li>失效转移<br>失效确认 - 访问转移 - 数据恢复</li>
</ol>
<h4 id="高可用的软件质量保证"><a href="#高可用的软件质量保证" class="headerlink" title="高可用的软件质量保证"></a>高可用的软件质量保证</h4><ol>
<li>网站发布<br>发布过程中，每次关闭的服务器都是集群中的一小部分，并在发布完成后立即可以访问，因此整个发布过程不影响用户使用</li>
<li>自动化测试<br>Web自动化测试，ThoughtWorks开发的Selenium，可以模拟用户操作进行测试，包括Web功能测试和浏览器兼容测试</li>
<li>预发布验证<br>预发布服务器是一种特殊用途的服务器，它和线上的正式服务器唯一的不同就是没有配置在负载均衡服务器上，外部用户u无法访问。</li>
<li>代码控制</li>
<li>灰度发布</li>
<li>监控数据采集<br>服务端日志手机、客户端浏览器日志收集、服务器性能监控、数据报告<br>监控管理： 系统报警、失效转移、自动优雅降级</li>
</ol>
<h3 id="第六章-网站的伸缩性架构"><a href="#第六章-网站的伸缩性架构" class="headerlink" title="第六章 网站的伸缩性架构"></a>第六章 网站的伸缩性架构</h3><p>通过纵向分离部署实现系统伸缩性<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-12/76643763.jpg" alt="通过纵向分离部署实现系统伸缩性"><br>通过横向分离部署实现系统伸缩性<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-12/78440186.jpg" alt="通过横向分离部署实现系统伸缩性"></p>
<h4 id="应用服务器集群的伸缩性设计"><a href="#应用服务器集群的伸缩性设计" class="headerlink" title="应用服务器集群的伸缩性设计"></a>应用服务器集群的伸缩性设计</h4><ol>
<li>HTTP重定向负载均衡<br>根据用户的HTTP请求计算一台真实的Web服务器地址，并将该Web服务器地址写入HTTP重定向响应中返回给浏览器，浏览器请求真实的Web服务器地址</li>
<li>DNS域名解析负载均衡<br>A记录中配置的多个服务器构成一个集群，可以实现负载均衡，同时DNS还支持基于地理位置的域名解析，解析成距离用户最近的一个服务器地址。缺点是当下线某台服务器后，即使修改了DNS的A记录，要使其生效也需要较长时间，这段时间，DNS依然会将域名解析到已经下线的服务器。改造：大型网站总是部分利用DNS域名解析，利用域名解析作为第一级负载均衡手段，得到的一组服务器并不是实际提供Web服务的服务器，而是同样提供负载均衡服务的内部服务器，再将请求分发到真实的Web服务器上</li>
<li>反向代理负载均衡</li>
<li>IP负载均衡<br>修改目的IP进行负载，IP负载均衡在内核进程完成数据分发，较反向代理负载均衡有更好性能。缺点：集群的最大响应数据吞吐量不得不受制于负载均衡服务器网卡带宽，能不能使真实数据从真实物理服务器直接返回给用户呢</li>
<li>数据链路层负载均衡<br>修改数据的目的mac地址，不修改目的IP地址，Web服务器集群所有服务器的虚拟IP地址都和负载服务器的IP地址相同，因此数据可以正常传输。网关服务器直接将数据包发送到用户浏览器，响应数据不需要通过负载均衡服务器。在linux平台最好的链路层负载均衡产品是LVS(Linux Virtual Server)</li>
</ol>
<h4 id="负载均衡算法："><a href="#负载均衡算法：" class="headerlink" title="负载均衡算法："></a>负载均衡算法：</h4><p>轮询：依次分发到每台应用服务器<br>加权轮询：高性能的服务分配更多请求<br>随机：随机数本身就很均衡<br>最少连接：将新到的请求分发到最少连接的服务器上<br>原地址散列：根据请求来源的IP地址进行HASH计算，这样来自同一个IP地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，实现会话黏滞</p>
<p>传统的加缓存服务器的办法是在网站访问量最少的时候扩容，然后通过模拟请求的方法逐渐预热缓存，使缓存服务器中的数据重新分布<br>分布式缓存的一致性Hash算法实现Key到缓存服务器的Hash映射，由此可能产生一个负载不均匀问题，可以增加一个虚拟层来解决。</p>
<h3 id="网站的可扩展架构"><a href="#网站的可扩展架构" class="headerlink" title="网站的可扩展架构"></a>网站的可扩展架构</h3><p>模块分布式部署以后具体聚合方式主要有分布式消息队列和分布式服务</p>
<h4 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h4><p>事件驱动架构(Event Driver Architecture EDA)<br>通过在低耦合的模块之间传输时间消息，以保持模块的松散耦合，典型的EDA就是生产消费者模式</p>
<ul>
<li>在伸缩性方面，由于消息队列服务器上的数据可以看做是被即时处理的，因此类似于无状态的服务器，伸缩性设计比较简单。将新服务器加入分布式消息队列集群中，通知生产者服务器更改消息队列服务器列表即可</li>
<li>在可用性方面，为了避免消费者进程处理缓慢，分布式消息队列服务器内存空间不足造成的问题，如果内存队列已满，会将消息写入磁盘，消息推送模块在将内存队列消息处理完以后，将磁盘内容加载到内存队列继续处理。<br>为了避免消息队列服务器宕机造成消息丢失，会将消息成功发送到消息队列的消息存储在消息生产服务器，等消息真正被消息消费者服务器处理后才删除消息。在消息服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中其他的服务器发布消息。<h4 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h4>阿里巴巴分布式开源框架Dubbo<br>Dubbo的远程服务通信模块支持多种通信协议和数据序列化协议，使用NIO通信框架，具有较高的网络通信性能。<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-12/46986723.jpg" alt="Dubbo"></li>
</ul>
<h3 id="网站的安全架构"><a href="#网站的安全架构" class="headerlink" title="网站的安全架构"></a>网站的安全架构</h3><ul>
<li>对于XSS攻击<br>跨站点攻击，指黑客通过篡改网页，注入恶意脚本，在用户浏览网页时候，控制用户浏览器进行恶意操作的一种攻击方式<br>有两种，一种是反射性，攻击者诱使用户点击一个嵌入恶意脚本的连接，达到攻击目的<br>另外一种是持久性XSS攻击，黑客提交含有恶意脚本的请求，保存在被攻击的Web站点的数据库中，用户浏览网页时，恶意脚本被包含在正常页面中，达到攻击目的。</li>
<li>SQL注入攻击和OS注入攻击一般都因为采用了开源的组件，或者黑客利用错误回显推测数据库结构。解决方案增加过滤，使用参数绑定</li>
<li>CSRF 跨站点请求伪造，攻击者通过跨站请求，以合法用户的身份进行非法操作，如转账交易，发表评论等。主要手法是利用跨站请求，在用户不知情的情况下，以用户的身份伪造请求，其核心是利用了浏览器Cookie或服务器Session策略，盗取用户身份。<br>解决方案：表单Token,验证码、Http请求头的Referer域中记录着请求来源，可通过检查请求来源，验证其是否合法，很多网站使用这个功能实现图片防盗链（如果图片访问的页面来源不是来自自己网站的网页就拒绝）</li>
</ul>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><table>
<thead>
<tr>
<th>项目名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tair</td>
<td>分布式Key/Value存储引擎，分为持久化和非持久化两种使用方式</td>
</tr>
<tr>
<td>TFS</td>
<td>一个分布式文件系统，适用于海量小文件存储</td>
</tr>
<tr>
<td>OceanBase</td>
<td>分布式数据库系统，支持千亿级别的读写事务</td>
</tr>
<tr>
<td>TDDL</td>
<td>对应用透明的分库分表层和具有众多特性的动态数据源</td>
</tr>
<tr>
<td>GeoDNS</td>
<td>基于开源域名服务器软件BIND的增强版本，域名解析到距离用户最近的服务器</td>
</tr>
<tr>
<td>LVS</td>
<td>基于Linux的开源负载均衡服务器</td>
</tr>
<tr>
<td>Squid</td>
<td>基于Linux的开源反向代理服务器</td>
</tr>
<tr>
<td>Lighttpd</td>
<td>轻量服务器，一般用来做图片服务器</td>
</tr>
<tr>
<td>Memcached</td>
<td>无中心高性能的开源分布式缓存系统</td>
</tr>
<tr>
<td>Lucene</td>
<td>Apache出品，Java开发的开源全文搜索引擎</td>
</tr>
</tbody>
</table>
<p>如果有词条信息更新，应用服务器使用Invalidation Notification服务通知使Squid缓存失效，重新访问应用服务器更新词条。</p>
<h3 id="大型网站典型故障案例"><a href="#大型网站典型故障案例" class="headerlink" title="大型网站典型故障案例"></a>大型网站典型故障案例</h3><ul>
<li>写日志也会引发故障<br>上线不久就出现服务器报警，硬盘可用空间低于警戒值，发现log文件迅速增加，不断消耗磁盘空间<br>原因分析：开发人员将log的level全局配置为Debug，这样一次简单的请求就会产生大量log内容<br>经验教训：日志输出级别至少为warn,有些开源的第三方组件也会不恰当的输出太多Error日志，需要注意</li>
<li>高并发访问数据引发的故障<br>某条SQL语句被放在了首页执行，首页是最频繁的网页，被首页调用就频繁执行了<br>经验教训：首页不应该访问数据库，首页需要的数据可以从缓存服务器或者搜索引擎服务器获取；首页最好是静态的。</li>
<li>高并发情况下锁引发的异常<br>某个单例多处使用锁，远程调用的操作也被加了锁，这个操作只是偶尔执行，但执行一次耗时过长，引起其他操作响应超时<br>经验教训：使用锁要谨慎</li>
<li>缓存引发的异常<br>原因：关闭了部分缓存服务器，导致网站全部瘫痪<br>经验教训：当缓存已不仅仅是改善性能，而是成为网站架构不可或缺的一部分时，对缓存的管理就需要提高到和其他服务器一样的级别</li>
<li>应用启动不同步引发的故障<br>某应用发布后，服务器立即崩溃<br>在发布时，Apache和JBoss同时启动个，由于JBoss启动时需要加载很多应用并初始化，花费时间较长，结果JBos还没有完全启动,Apache就已经完全启动开始接受请求，大量请求阻塞在JBoss最终导致崩溃。<br>经验教训：可以在应用程序中加入一个特定动态页面，启动脚本启动JBoss，然后在脚本中不断用curl命令访问这个页面，直到收到OK，才启动Apache</li>
<li>大文件读写独占磁盘引发故障<br>发现大部分文件只有几百KB，有几个文件非常大，有数百兆，读写这些大文件一次需要几十秒，这段时间，磁盘基本被这个文件操作独占，导致其他用户的文件操作缓慢<br>经验教训：存储的使用需要根据不同文件类型和用途进行管理，图片都是小文件，应该使用专用的存储服务器，不能和大文件共用存储。批处理用的大文件可以使用其他类型的分布式文件系统</li>
<li>不规范的流程引发的故障<br>发布该应用后出现大量数据库读操作，而这些数据本来应该从分布式缓存读取，检查缓存发现数据被缓存了。检查代码发现访问缓存的那行代码被注释掉了。<br>经验教训：提交代码前使用diff命令进行代码比较，确认没有提交不该提交的代码。</li>
</ul>
<p>###大型网站技术一览<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-12/31632202.jpg" alt="网站系统架构层次"></p>
<ul>
<li>前端架构<ol>
<li>浏览器优化</li>
<li>CDN</li>
<li>动静分离，静态资源独立部署<br>静态资源，如JS、CSS文件部署在专门的服务器集群上，和Web应用动态内容服务分离，并适用专门的二级域名。</li>
<li>图片服务<br>用户上传的图片，如产品图片、用户头像等，图片服务器同样适用独立部署的图片服务器集群，并适用独立二级域名</li>
<li>反向代理<br>部署在网站机房，在应用服务器、静态资源服务器、图片服务器前，提供页面缓存服务</li>
<li>DNS<br>域名服务，将域名解析成IP地址，利用DNS可以实现DNS负载均衡，配置CDN也需要修改DNS，使域名解析后指向CDN服务器</li>
</ol>
</li>
<li>应用层架构<ol>
<li>页面渲染<br>将分别开发维护的动态内容和静态页面模板集成，组合成最终显示给用户的完整页面</li>
<li>负载均衡<br>通过负载均衡技术将用户请求分发到不同的服务器上，以应用大量用户同时访问时产生的高并发负载压力</li>
<li>Session管理<br>需要专门的机制管理Session，使集群内甚至跨集群的应用服务可以共享Session</li>
<li>动态页面静态化<br>对于访问量特别大而更新又不很频繁的动态页面，可以将其静态化，即生成一个静态页面，利用静态页面的优化手段加速用户访问，如CDN，访问代理</li>
<li>业务拆分<br>业务拆分，降低系统耦合度，也利于数据库分库</li>
<li>虚拟化服务器<br>将一台物理服务器虚拟化为多台虚拟服务器，对于并发访问较低的业务，更容易用较少的资源构建高可用的应用服务器集群<br>*　服务层架构　</li>
<li>分布式消息<br>利用消息队列机制，实现业务和业务，业务和服务之间的异步消息发送及低耦合的业务关系</li>
<li>分布式服务<br>提供高性能、低耦合、易复用、易管理的分布式服务，在网站实现面向服务架构（SOA）</li>
<li>分布式缓存<br>通过可伸缩的服务器集群提供大规模热点数据的缓存服务，是网站性能优化的重要手段</li>
<li>分布式配置<br>系统运行需要配置许多参数，如果这些参数需要修改，比如分布式缓存集群加入新的缓存服务器，需要修改应用程序客户端的缓存服务器列表皮遏制，并重启应用程序服务器，分布式配置在系统运行期间提供配置动态推送服务，将配置修改实时推送到应用系统，无需重启服务器</li>
</ol>
</li>
<li>存储层架构<ol>
<li>分布式文件</li>
<li>关系数据库<br>在应用程序的数据访问层增加数据库访问路由功能，根据业务配置将数据库访问路由到不同的物理数据库上，可实现关系数据库的分布式访问</li>
<li>NoSQL数据局</li>
<li>数据同步<br>主从热备</li>
</ol>
</li>
<li>后台架构<ol>
<li>搜索引擎</li>
<li>数据仓库</li>
<li>推荐系统</li>
</ol>
</li>
<li>数据采集与监控<ol>
<li>浏览器数据采集<br>在网站页面中嵌入ＪＳ脚本采集用户浏览器环境与操作记录，分析用户行为　</li>
<li>服务器业务数据采集<br>采集在服务器端记录的用户请求操作日志；采集应用程序运行期业务数据，比如待处理消息数目等。</li>
</ol>
</li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>不要企图去设计一个大型网站！大型网站不是设计出来的，而是逐步演化出来的<br>垄断、牌照、行业壁垒、国有资本、行政资源，这些在传统行业呼风唤雨的魔法到了互联网领域只会被嘲笑、被捉弄。庞大只是笨拙而已，壁垒只会画地为牢<br>互联网是一种精神，一种开放、分享、自由的精神；越是付出不问汇报，越是获得丰厚的回报；越是不设边界，越是拥有整个世界。互联网是一种颠覆，打碎所有的藩篱，给所有人平等表达和获取的机会，每个人都可以发出自己的声音。互联网是一种建设，重塑人们的思维方式和社会运行方式，建设一个任何人彼此理解信任的大同世界。互联网正在并将继续改变这个世界，一切才刚刚开始，你我正生逢其时！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Guava概览]]></title>
      <url>http://yoursite.com/2016/05/12/Guava%E6%A6%82%E8%A7%88/</url>
      <content type="html"><![CDATA[<p>Guava 是一个 Google 的基于java1.6的类库集合的扩展项目，包括 collections, caching, primitives support, concurrency libraries, common annotations, string processing, I/O, 等等. 这些高质量的 API 可以使你的JAVa代码更加优雅，更加简洁，让你工作更加轻松愉悦。下面我们就开启优雅Java编程学习之旅！</p>
<p>　　项目相关信息：</p>
<p>　　官方首页：<a href="http://code.google.com/p/guava-libraries" target="_blank" rel="external">http://code.google.com/p/guava-libraries</a><br>　　官方下载：<a href="http://code.google.com/p/guava-libraries/downloads/list" target="_blank" rel="external">http://code.google.com/p/guava-libraries/downloads/list</a><br>　　官方文档：<a href="http://docs.guava-libraries.googlecode.com/git/javadoc" target="_blank" rel="external">http://docs.guava-libraries.googlecode.com/git/javadoc</a><br>                    <a href="http://www.ostools.net/apidocs/apidoc?api=guava" target="_blank" rel="external">http://www.ostools.net/apidocs/apidoc?api=guava</a></p>
<p>　　源码包的简单说明：<br>　　com.google.common.annotations：普通注解类型。<br>　　com.google.common.base：基本工具类库和接口。<br>　　com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存。<br>　　com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类，这里你会发现很多好玩的集合。<br>　　com.google.common.eventbus：发布订阅风格的事件总线。<br>　　com.google.common.hash： 哈希工具包。<br>　　com.google.common.io：I/O工具包。<br>　　com.google.common.math：原始算术类型和超大数的运算工具包。<br>　　com.google.common.net：网络工具包。<br>　　com.google.common.primitives：八种原始类型和无符号类型的静态工具包。<br>　　com.google.common.reflect：反射工具包。<br>　　com.google.common.util.concurrent：多线程工具包。</p>
<p>　　类库使用手册：</p>
<p>　　一.  基本工具类：让使用Java语言更令人愉悦。</p>
<p>　　1. 使用和避免 null：null 有语言歧义， 会产生令人费解的错误， 反正他总是让人不爽。很多 Guava 的工具类在遇到 null 时会直接拒绝或出错，而不是默默地接受他们。<br>　　2. 前提条件：更容易的对你的方法进行前提条件的测试。<br>　　3. 常见的对象方法： 简化了Object常用方法的实现， 如 hashCode() 和 toString()。<br>　　4. 排序： Guava 强大的 “fluent Comparator”比较器， 提供多关键字排序。<br>　　5. Throwable类： 简化了异常检查和错误传播。</p>
<p>　　二.  集合类：集合类库是 Guava 对 JDK 集合类的扩展， 这是 Guava 项目最完善和为人所知的部分。</p>
<p>　　1. Immutable collections（不变的集合）： 防御性编程， 不可修改的集合，并且提高了效率。<br>　　2. New collection types(新集合类型)：JDK collections 没有的一些集合类型，主要有：multisets，multimaps，tables， bidirectional maps等等<br>　　3. Powerful collection utilities（强大的集合工具类）： java.util.Collections 中未包含的常用操作工具类<br>　　4. Extension utilities（扩展工具类）: 给 Collection 对象添加一个装饰器? 实现迭代器? 我们可以更容易使用这些方法。</p>
<p>　　三.  缓存: 本地缓存，可以很方便的操作缓存对象，并且支持各种缓存失效行为模式。</p>
<p>　　四.  Functional idioms（函数式）: 简洁, Guava实现了Java的函数式编程，可以显著简化代码。</p>
<p>　　五. Concurrency（并发）：强大,简单的抽象,让我们更容易实现简单正确的并发性代码。</p>
<p>　　1. ListenableFuture（可监听的Future）: Futures,用于异步完成的回调。<br>　　2. Service: 控制事件的启动和关闭，为你管理复杂的状态逻辑。</p>
<p>　　六. Strings: 一个非常非常有用的字符串工具类: 提供 splitting，joining， padding 等操作。</p>
<p>　　七. Primitives: 扩展 JDK 中未提供的对原生类型（如int、char等）的操作， 包括某些类型的无符号的变量。</p>
<p>　　八. Ranges: Guava 一个强大的 API，提供 Comparable 类型的范围处理， 包括连续和离散的情况。</p>
<p>　　九. I/O: 简化 I/O 操作, 特别是对 I/O 流和文件的操作, for Java 5 and 6.</p>
<p>　　十. Hashing: 提供比 Object.hashCode() 更复杂的 hash 方法, 提供 Bloom filters.</p>
<p>　　十一. EventBus: 基于发布-订阅模式的组件通信，但是不需要明确地注册在委托对象中。</p>
<p>　　十二. Math: 优化的 math 工具类，经过完整测试。</p>
<p>　　十三. Reflection: Guava 的 Java 反射机制工具类。</p>
<p>null对象不是Object对象的实例。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python学习笔记]]></title>
      <url>http://yoursite.com/2016/05/12/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>You can try out the features described in the tips while this dialog stays open on the screen.</p>
<p>pyCharm Tips -&gt;<br>Open directory -&gt; Open in current window -&gt; Add to currently opended projects<br>Ctrl+shitf+T 快速打开类</p>
<p>Ctrl+空格  快速补全<br>ctrl+空格 两次，补全类名无论该类是否被引入<br>Ctrl+G find usages in the popup menu<br>ctrl+shift+空格  View | Quick Document   查看方法文档 （查看外部文档 用 Shift+F2）<br>F3    jump to declarations<br>ctrl+F3   浏览该类大致结构   Navigate  | File Structure<br>alt+shift+R     快速重命名    Refactor | Rename<br>补全的时候使用Tab<br>shift+click 或者 鼠标中键<br>alt+F1<br>ctrl+D  重复所选块<br>ctrl+p   此时，如果光标在括号中间，可以显示所需参数<br>ctrl+q   最后一次修改的地方<br>ctrl+shift+上    移动<br>alt+enter  自动导入包<br>alt+F7  查找该方法在其他地方的使用情况<br>ctrl+o  覆盖基类方法</p>
<p>pyCharm 中安装模块两种方式：</p>
<ol>
<li>FIle - Settings - Project Interpreter</li>
<li>tar.gz 包安装模块  解压 -&gt; python  setup.py install</li>
</ol>
<p>Question</p>
<ol>
<li>Non-ASCII character ‘\xe5’ in file ……<h1 id="coding-UTF-8"><a href="#coding-UTF-8" class="headerlink" title="-- coding: UTF-8 --"></a>-<em>- coding: UTF-8 -</em>-</h1>或者<br>#coding=utf-8<br>!# /usr/bin/python</li>
</ol>
<h3 id="python语法"><a href="#python语法" class="headerlink" title="python语法"></a>python语法</h3><ol>
<li>python中的类采用CapWords约定，每个单词的首字母要大写，其他字母小写。</li>
<li>类的私有属性、私有方法以两个下划线作为前缀，对象铜通过点操作符来访问类中的属性和方法。</li>
<li>self相当于Java语言中的this关键字，表示本类</li>
<li>方法名的首字母小写，其后每个单词的首字母要大写<br>行内注释应该至少用两个空格和语句分开，他们以#和单个空格开始</li>
</ol>
<p>eg:<br>class MyClass:<br>    <strong>username = ‘’<br>    password = ‘’<br>    def </strong>init<strong>(self,username,password):<br>        self.</strong>username = username<br>        self.password = password</p>
<pre><code>def getUserName(self):
    return self.__username + self.password
</code></pre><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    myclass = MyClass(‘hello’,’pass’)<br>    print myclass.getUserName()</p>
<p>python中的长整型相当于java的BigInteger类型，数字后面加上“L”,范围为正负 20亿<br>以单下划线开头的(_foo)代表不能直接访问的类属性，需通过类提供的接口进行访问<br>以双下划线开头的(<strong>foo)代表类的私有成员<br>以双下划线开头和结尾(</strong>foo<strong>)代表Python中特殊方法专用的标识，例如 </strong>init__() 代表类的构造函数<br><strong> python不支持C语言中的自增和自减操作 </strong></p>
<p>str()函数：把值转换为合理形式的字符串，以便用户理解<br>repr()函数：创建一个字符串，以合法的Python表达式形式来表示值<br>eg:<br>print repr(‘my name is max’)   ==&gt;  ‘my name is max’<br>print repr(12345L)   ==&gt;    12345L<br>print str(‘my name is max’)   ==&gt;   my name is max<br>print str(12345L)   ==&gt;    12345</p>
<p>input()函数是把读入的用户输入数据默认为Python表达式，而raw_input()函数是把读入的数据转换为字符串。</p>
<p>str1.decode(‘gb2312’)  表示将gb2312编码的字符串str1转换成Unicode编码<br>str2.encode(‘gb2312’)  表示将Unicode编码的字符串str2转换成gb2312编码</p>
<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><h1 id="for循环可以迭代字典、字符串、列表、元组"><a href="#for循环可以迭代字典、字符串、列表、元组" class="headerlink" title="for循环可以迭代字典、字符串、列表、元组"></a>for循环可以迭代字典、字符串、列表、元组</h1><p>dict= {<br>    ‘one’ : ‘1’,<br>    ‘two’ : ‘2’,<br>    ‘three’ : ‘3’<br>}<br>for key in dict:<br>    print key+’:’+dict[key]<br>zifu = ‘yang’<br>for zz in zifu:<br>    print zz</p>
<p>shuzu = [(1,2),(3,4),(5,6)]<br>for (a,b) in shuzu:<br>    print a,b</p>
<p>for a in shuzu:<br>    print a</p>
<p>读取文件<br>with open(“ceshi.txt”) as ff:<br>    for readline in ff:<br>        print readline<br>迭代：<br>mys = [‘one’,’two’,’three’,’four’]<br>my = iter(mys)<br>print my.next()<br>print my.next()<br>print my.next()<br>print my.next()</p>
<p>for my in iter(mys):<br>    print my</p>
<p>并行迭代 使用zip()或者enumerate()</p>
<h1 id="coding-utf-8-1"><a href="#coding-utf-8-1" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>names = [‘one’,’two’,’three’,’four’]<br>ages = [22,23,34,45]<br>for name,age in zip(names,ages):<br>    print name,u’年龄是’,age</p>
<p>关键字查询(使用enumerate并行迭代)</p>
<h1 id="coding-utf-8-2"><a href="#coding-utf-8-2" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>zifu = raw_input(‘please the key:’)<br>list = [‘sun flower’,’red flower’,’blue flower’,’green grass’]<br>for index, lst in enumerate(list):  #index为索引<br>    if zifu in lst:<br>        print lst</p>
<p>exec语句用来动态的创造Python代码，然后将其作为语句执行<br>eg: exec ‘print “hello world”‘<br>如果没有 <strong>init</strong>.py 文件，python不能识别对应的包。<strong>init</strong>.py文件可以为空，用于标志当前文件夹是一个包</p>
<h1 id="参数封装为元组传递"><a href="#参数封装为元组传递" class="headerlink" title="参数封装为元组传递"></a>参数封装为元组传递</h1><p>def login(* userpwds):<br>    username = userpwds[0]<br>    password = userpwds[1]<br>    if(username == ‘admin’) and (password == ‘admin’):<br>        print ‘success’<br>    else:<br>        print ‘fail’<br>login(‘admin’,’admin’)</p>
<h1 id="参数为字典传递"><a href="#参数为字典传递" class="headerlink" title="参数为字典传递"></a>参数为字典传递</h1><p>def login2(<strong> userpwds):<br>    keys = userpwds.keys()<br>    username = ‘’<br>    password = ‘’<br>    for key in keys:<br>        if ‘username’ == key:<br>            username = userpwds[key]<br>        if ‘password’ == key:<br>            password = userpwds[key]<br>    if(username == ‘admin’) and (password == ‘admin’):<br>        print ‘success’<br>    else:<br>        print ‘fail’<br>login2(username=’admin’, password=’admin’)<br>如果函数的参数类型既有元组(形式参数前加*)，又有字典(形式参数钱加</strong>),那么<em>必须写在*</em>的前面。</p>
<p>返回多个参数<br>def operate(x, y, z):<br>    x = x + 5<br>    y = y + 5<br>    z = z + 5<br>    oper = [x,y,z]<br>    numbers = tuple(oper)</p>
<pre><code># 打包到元组中
return numbers
</code></pre><p>x, y, z = operate(1, 2, 3)  # 解包元组<br>print x, y, z</p>
<p>创建一个名称为myFirstModule.py的文件，即定义了一个名称为myFirstModule的模块<br>def myFun1():<br>    print ‘myFun1’</p>
<p>def myFun2():<br>    print ‘myFun2’</p>
<p>class MyClass:<br>    def myClassFun(self):<br>        print ‘MyClass myClassFun’<br>导入该模块</p>
<h1 id="coding-utf-8-3"><a href="#coding-utf-8-3" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>import  myFirstModule<br>myFirstModule.myFun1()<br>myFirstModule.myFun2()<br>myclass = myFirstModule.MyClass()<br>myclass.myClassFun()</p>
<p>python中的from … import 语句可以将模块中的类或函数导入，从而不需要使用模块名作为前缀<br>eg: from  addPerson import  Person<br>导入一个模块下的所有类和函数，可以使用   from module_name import *<br>global 引用全局变量</p>
<p>模块内置函数</p>
<ol>
<li><p>apply()  把输入参数放入元组或列表传递给函数<br>def login(username, password):<br> msg = ‘’<br> if(username == ‘admin’) and (password == ‘admin’):</p>
<pre><code>msg = &apos;success&apos;
</code></pre><p> else:</p>
<pre><code>msg = &apos;fail&apos;
</code></pre><p> return msg<br>print apply(login,(‘admin’,’admin’))</p>
</li>
<li><p>filter()  返回符合条件的元素<br>def validate(usernames):<br> if(len(usernames) &gt; 4) and (len(usernames) &lt; 12):</p>
<pre><code>return usernames
</code></pre><p>print filter(validate,(‘admin’,’maxinaglin’,’mxl’,’adm’,’wangling’))</p>
</li>
<li><p>reduce() 实现连续处理功能<br>def operate(x, y):<br> return x*y<br>print reduce(operate,(7,8,9),0)  # 初始值为0,连乘</p>
</li>
<li><p>map()  可以对多个序列中的每个元素执行相同的操作<br>def add1(a):<br> return a + 1<br>def add2(a, b):<br> return a + b<br>def add3(a, b, c):<br> return a + b + c</p>
</li>
</ol>
<p>a1 = [1,2,3,4,5]<br>a2 = [1,2,3,4,5]<br>a3 = [1,2,3,4,5]</p>
<p>b = map(add1, a1)<br>print b<br>b = map(add2, a1, a2)<br>print b<br>b = map(add3, a1, a2, a3)<br>print b</p>
<ol>
<li>随机生成四位数并判断奇偶数<br>import random<br>allNums = []<br>for each in range(10):<br> allNums.append(random.randint(1000, 9999))<br>print u’随机从1000-9999生成的四位数’+str(allNums)<br>print u’偶数为:’+str(filter(lambda n : n%2==0, allNums))<br>print u’奇数为:’+str(filter(lambda n : n%2==1,allNums))<br>输出 ==&gt;<br>随机从1000-9999生成的四位数[1382, 7860, 5015, 6757, 7185, 2757, 1802, 8612, 2294, 8688]<br>偶数为:[1382, 7860, 1802, 8612, 2294, 8688]<br>奇数为:[5015, 6757, 7185, 2757]</li>
</ol>
<p>分片<br>userList = list(‘python’)<br>print userList<br>userList[2:] = list(‘rite’)<br>print userList<br>输出 ==&gt;<br>[‘p’, ‘y’, ‘t’, ‘h’, ‘o’, ‘n’]<br>[‘p’, ‘y’, ‘r’, ‘i’, ‘t’, ‘e’]</p>
<p>numbers = [0,6]<br>numbers[1:1] = [1,2,3,4]  # 相当于插入<br>print numbers<br>输出 ==&gt;<br>[0, 1, 2, 3, 4, 6]</p>
<p>userList = [‘001’,’002’,’003’,’004’,’005’,’006’]<br>subUser1 = userList[-3:-1]<br>subUser2 = userList[0:-2]<br>输出 ==&gt;<br>[‘004’, ‘005’]<br>[‘001’, ‘002’, ‘003’, ‘004’]</p>
<p>userList1 = [‘001’,’002’,’003’,’004’,’005’,’006’]<br>userList2 = [‘aaa’,’bbb’]<br>userList = [userList1,userList2]<br>print userList<br>print userList[0][1]<br>print userList[1][1]<br>输出 ==&gt;<br>[[‘001’, ‘002’, ‘003’, ‘004’, ‘005’, ‘006’], [‘aaa’, ‘bbb’]]<br>002<br>bbb<br>利用for遍历<br>for i in range(len(userList)):<br>    for j in range(len(userList[i])):<br>        print userList[i][j]</p>
<p>列表的连接<br>使用extend()或者+运算符<br>userList1.extend(userList2)   extend修改了被扩展的列表，并非真正连接两个列表返回一个全新的列表<br>userList1 = userList1 + userList2</p>
<p>列表去重<br>checked = []<br>def fruitFun(fruitList):<br>    global  checked<br>    for e in fruitList:<br>        if e not in checked:<br>            checked.append(e)<br>fruitList = [‘apple’,’banana’,’apple’,’strawberry’,’pear’,’banana’]<br>fruitFun(fruitList)<br>print checked</p>
<p>迭代字符串<br>zifu=’yang’<br>for zi in zifu:<br>    print zi<br>‘y’,’a’,’n’,’g’</p>
<p>ctrl+E   最近的文件<br>双击shift   搜索<br>ctrl+shift+N  找某一个文件</p>
<p>更新&amp;&amp;迭代<br>userDic = [(‘002’,’June’), (‘003’,’Tom’)]<br>dic_userDic = dict(userDic)<br>print dic_userDic<br>dic_userDic[‘004’] = ‘hello’<br>print dic_userDic<br>del(dic_userDic[‘002’])</p>
<p>print dic_userDic</p>
<p>for key in dic_userDic:<br>    print ‘userDic[%s] = ‘ % key ,dic_userDic[key]<br>for (key,value) in dic_userDic.items():<br>    print ‘userDic[%s] = ‘ %key,value<br>for key in dic_userDic.itervalues():<br>    print key<br>for (key,value) in zip(dic_userDic.iterkeys(), dic_userDic.itervalues()):<br>    print ‘userDic[%s]=’ % key,value<br>print dic_userDic.has_key(‘003’)</p>
<p>newDIc={‘003’:’new’}<br>dic_userDic.update(newDIc)<br>print dic_userDic</p>
<p>letter1 = [‘a’,’b’,’c’,’d’]<br>sep = ‘-‘<br>print sep.join(letter1)<br>print ‘/‘.join(letter1)<br>输出 ==&gt;<br>a-b-c-d<br>a/b/c/d</p>
<p>内置方法<br>class Person:<br>    def <strong>init</strong>(self, name):<br>        self.name = name<br>        self.age = 11<br>    def sayHi(self):<br>        print ‘hello,my name is ‘,self.name<br>        print ‘\nage is ‘,self.age<br>p = Person(‘yuchuan’)<br>p.sayHi()<br><strong>init</strong>方法是构造函数，在程序中起到初始化对象的作用</p>
<p>copyfile()和move()使用shutil模块</p>
<p>凡是可以序列化的对象都可以持久化<br>python中主要使用一些模块（例如dbhash、anydbm和shelve）完成持久化操作</p>
<p>2.<br>代码片段</p>
<p>#coding=utf-8</p>
<ol>
<li><p>比较文件的不同</p>
<h1 id="coding-UTF-8-1"><a href="#coding-UTF-8-1" class="headerlink" title="-- coding: UTF-8 --"></a>-<em>- coding: UTF-8 -</em>-</h1><p>import difflib<br>text1=”””text1:  ###定义字符串1<br>hello world<br>add String”””<br>text1_line = text1.splitlines()<br>text2=”””text2:  ###定义字符串2<br>hello<br>add string”””<br>text2_line = text2.splitlines()<br>d = difflib.Differ()<br>diff = d.compare(text1_line,text2_line)<br>print ‘\n’.join(list(diff))</p>
<h3 id="后面三行换成如下，可以输出html美观页面"><a href="#后面三行换成如下，可以输出html美观页面" class="headerlink" title="后面三行换成如下，可以输出html美观页面"></a>后面三行换成如下，可以输出html美观页面</h3><p>d = difflib.HtmlDiff()<br>print d.make_file(text1_line,text2_line)</p>
</li>
<li><p>根据输入的IP或子网返回网络、掩码、广播、反向解析、子网数、IP类型等信息<br>from IPy import IP<br>ip_s = raw_input(‘Please input an IP or net-range’)<br>ips=IP(ip_s)<br>if len(ips) &gt; 1:<br> print(‘net: %s’ % ips.net())<br> print(‘netmask: %s’ % ips.netmask())<br> print(‘broadcast: %s’ % ips.broadcast())<br> print(‘reverse address: %s’ % ips.reverseName())<br> print(‘subnet: %s’ % len(ips))<br>else:<br> print(‘reverse address %s’ % ips.reverseName()[0])<br>print(‘hexadecimal: %s’ % ips.strHex())<br>print(‘binary ip: %s’ % ips.strBin())<br>print(‘iptype: %s’ % ips.iptype())</p>
</li>
<li><p>发送邮件</p>
<h1 id="coding-utf-8-4"><a href="#coding-utf-8-4" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>import smtplib<br>import string<br>from smtplib import SMTP_SSL<br>HOST=”smtp.163.com”<br>SUBJECT=”Test email from Python”<br>TO=”735699812@qq.com”<br>FROM=”yuchuan512@163.com”<br>text=”Python rules them all”<br>BODY=string.join((“FROM: %s” % FROM,</p>
<pre><code>&quot;To: %s&quot; % TO,
&quot;SUBJECT: %s&quot; % SUBJECT,
&quot;&quot;,text),&quot;\r\n&quot;)
</code></pre><p>server = SMTP_SSL(HOST)<br>server.login(“yuchuan512@163.com”,”Yu**2”)<br>server.sendmail(FROM,TO,BODY)<br>server.quit()</p>
</li>
</ol>
<p>3.1 邮件发送html网页</p>
<h1 id="coding-utf-8-5"><a href="#coding-utf-8-5" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>import smtplib<br>from smtplib import SMTP_SSL<br>from email.mime.text import MIMEText<br>HOST = “smtp.163.com”<br>SUBJECT = u”流量数据报表”<br>TO = “735699812@qq.com”<br>FROM=”yuchuan512@163.com”<br>msg=MIMEText(“””<table width="800" border="0" cellspacing="0" cellpadding="4"><br>    <tr><br>        <td bgcolor="#CECFAD" height="20" style="font-size:14px">官网数据<a href=""></a></td><br>    </tr>&lt;/table”””, “html”, “utf-8”)<br>msg[‘Subject’] = SUBJECT<br>msg[‘From’] = FROM<br>msg[‘To’] = TO<br>server = SMTP_SSL(HOST)<br>server.login(“yuchuan512@163.com”, “Yu**2”)<br>server.sendmail(FROM, TO, msg.as_string())<br>server.quit()<br>3.2 发送带图片附件的邮件</table></p>
<h1 id="coding-utf-8-6"><a href="#coding-utf-8-6" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>import smtplib<br>from email.mime.image import MIMEImage<br>from email.mime.multipart import MIMEMultipart<br>from smtplib import SMTP_SSL<br>from email.mime.text import MIMEText<br>HOST = “smtp.163.com”<br>SUBJECT = u”流量数据报表”</p>
<p>##TO = “735699812@qq.com”<br>TO = “yuchuan512@163.com”<br>FROM=”yuchuan512@163.com”</p>
<p>def addimg(src, imgid):<br>    fp = open(src,’rb’)<br>    msgImage = MIMEImage(fp.read())<br>    fp.close()<br>    msgImage.add_header(‘Content-ID’, imgid)<br>    return msgImage</p>
<p>msg = MIMEMultipart(‘related’)</p>
<p>msgText=MIMEText(“””<table width="800" border="0" cellspacing="0" cellpadding="4"><br>    <tr><br>        <td bgcolor="#CECFAD" height="20" style="font-size:14px">官网数据<a href=""></a></td><br>    </tr><br>    <tr><br>        <td><img src="cid:a1"></td><br>        <td><img src="cid:a2"></td><br>    </tr><br>    <tr><br>        <td><img src="cid:a3"></td><br>        <td><img src="cid:a4"></td><br>    </tr></table></p>
<pre><code>&lt;/table&quot;&quot;&quot;, &quot;html&quot;, &quot;utf-8&quot;)
</code></pre><p>msg.attach(msgText)</p>
<p>msg.attach(addimg(“../img/a1.png”, “a1”))<br>msg.attach(addimg(“../img/a2.png”, “a2”))<br>msg.attach(addimg(“../img/a3.png”, “a3”))<br>msg.attach(addimg(“../img/a4.png”, “a4”))</p>
<p>try:<br>    msg[‘Subject’] = SUBJECT<br>    msg[‘From’] = FROM<br>    msg[‘To’] = TO<br>    server = SMTP_SSL(HOST)<br>    server.login(“yuchuan512@163.com”, “Yu**12”)<br>    server.sendmail(FROM, TO, msg.as_string())<br>    server.quit()<br>    print ‘success’<br>except Exception,  e:<br>    print ‘失败’+str(e)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mysql学习笔记]]></title>
      <url>http://yoursite.com/2016/05/12/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<ol>
<li><p>Linux平台安装Mysql失败是因为/etc/my.cnf 的设置是系统的错误路径，可以将$MySQL_HOME/support_files/目录下面的配置文件复制到/etc/my.cnf</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp ./support_files/my_medium.cnf  /etc/my.cnf</div></pre></td></tr></table></figure>
</li>
<li><p>myslq忘记登录密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqladmin -u root -p password &quot;newpwd&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>mysql丢失密码</p>
<ul>
<li><p>windows平台</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">net stop mysql</div><div class="line">mysqld --skip-grant-tables</div><div class="line">打开另一个命令行窗口</div><div class="line">mysql -u root</div><div class="line">update mysql.user set password=password(&apos;newpwd&apos;) where user=&apos;root&apos;</div><div class="line">		and host=&apos;localhost&apos;</div><div class="line">加载权限表</div><div class="line">flush privileges;</div></pre></td></tr></table></figure>
</li>
<li><p>linux平台</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysqld_safe --skip-grant-tables user=mysql</div><div class="line">mysql -u root</div><div class="line">update mysql.user set password=password(&apos;newpwd&apos;) where user=&apos;root&apos;</div><div class="line">		and host=&apos;localhost&apos;</div><div class="line">加载权限表</div><div class="line">flush privileges;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>4.InnoDB 和 MyISAM区别<br>InnoDB 支持事务安全，行锁；空间使用比较高，内存使用高，批量插入速度低<br>MyISAM不支持事务安全，表锁；空间使用比较低，内存使用低，批量插入速度高</p>
<ul>
<li><p>使用mysqldump备份数据库中的某个表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysqldump -uroot -p chuan test &gt; C:/aa.sql</div><div class="line">备份数据库chuan中的test数据表</div></pre></td></tr></table></figure>
</li>
<li><p>使用mysqldump备份多个数据库中的表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysqldump -uroot -p --databases chuan mysql &gt; C:/aa.sql</div><div class="line">备份数据库chuan 和数据库mysql</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* 还原数据库</div></pre></td></tr></table></figure></p>
<p>mysql -uroot -p [dbname] &lt; file.sql<br>指明数据库名称和sql文件位置<br>或者<br>use dbname<br>source file.sql<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">常用</div><div class="line">SHOW ENGINES</div><div class="line">SHOW VARIABLES LIKE &apos;have%&apos;</div><div class="line">ALTER TABLE account ENGINE=INNODB</div><div class="line">DESC  account</div><div class="line"></div><div class="line">USE mysql</div><div class="line">SELECT HOST,USER,PASSWORD FROM USER</div><div class="line"></div><div class="line">SELECT MD5(&apos;root&apos;)</div><div class="line"></div><div class="line">### 数据导入导出</div></pre></td></tr></table></figure></p>
<p>SELECT * FROM test INTO OUTFILE “C:/dd.txt”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; 注意： 在windows上默认换行符号为&quot;\r\n&quot;,而命令默认换行符为&quot;\n&quot;,改为</div></pre></td></tr></table></figure></p>
<p>SELECT * FROM test INTO OUTFILE “C:/dc.txt”  LINES TERMINATED BY ‘\r\n’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 使用select命令生成文本文件</div></pre></td></tr></table></figure></p>
<p>SELECT * FROM test INTO OUTFILE “C:/test.txt”<br>FIELDS<br>TERMINATED BY ‘,’     – 设置字段之间的分割符<br>ENCLOSED BY ‘\”‘      – 设置字段的包围符号<br>ESCAPED BY ‘\’’       – 设置如何写入或读取特殊字符，默认为“\”<br>LINES TERMINATED BY ‘\r\n’   – 设置每行结尾的字符，默认为”\n”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* 使用mysqldump命令同时生成sql文件和文本文件</div></pre></td></tr></table></figure></p>
<p>mysqldump -T C:/soft chuan test -uroot -p<br>–fields-terminated-by=,<br>–fields-optionally-enclosed-by=\”<br>–fields-escaped-by=?<br>–lines-terminated-by=\r\n<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">输出 ==&gt;</div></pre></td></tr></table></figure></p>
<p>“1”,”one”<br>“2”,”two”<br>“3”,”three”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 使用load命令导入文本文件</div></pre></td></tr></table></figure></p>
<p>LOAD DATA INFILE ‘C:/soft/test.txt’ INTO TABLE chuan.test<br>FIELDS<br>TERMINATED BY ‘,’<br>ENCLOSED BY ‘\”‘<br>ESCAPED BY ‘\’’<br>LINES TERMINATED BY ‘\r\n’<br>```</p>
<p>MySQL 的高级特性</p>
<ol>
<li>查询缓存<br>SET SESSION QUERY_CACHE_TYPE=  ON;   ##开启缓存功能<br>SET SESSION QUERY_CACHE_TYPE = OFF<br>SELECT @@QUERY_CACHE_TYPE AS result  ## 查看是否开启缓存功能</li>
</ol>
<p>SHOW VARIABLES LIKE ‘have_query_cache’   ## 查看缓存大小<br>SELECT @@global.query_cache_size     ## 为0 表示缓存内存大小为0，查询缓存功能不起作用，默认为0</p>
<p>SET @@global.query_cache_size = 1000000  ## 将缓存大小设为1MB<br>COMMIT;</p>
<p>SELECT @@global.query_cache_limit;   ## 查看缓存的上限</p>
<p>SHOW VARIABLES LIKE ‘%query_cache%’   ## 查看缓存的相关参数情况<br>各变量如下：<br>have_query_cache    YES    设置是否支持查询缓存区<br>query_cache_limit    1000000   可以缓存的最大结果集<br>query_cache_min_res_unit    4096   用来设置分配内存块的最小体积，单位 字节<br>query_cache_size      0    设置查询缓存使用的总内存字节数，必须是1024字节的倍数<br>query_cache_type     ON    设置是否启用查询缓存。OFF 不进行缓存；ON 表示出了SQL_NO_CACHE的查询以外，缓存所有结果；DEMAND 仅缓存SQL_CACHE<br>query_cache_wlock_invalidate     OFF  设置是否允许在其他连接处于lock状态时，使用缓存结果，默认OFF</p>
<p>SHOW STATUS LIKE ‘Qcache_hits’  查看缓存命中次数<br>增加一条记录，跟该表相关的查询缓存会被清空，然后重新查询，命中次数不发生变化，说明本次查询没有直接从缓存中取到数据</p>
<p>可以修改 /etc/my.cnf 配置文件<br>[mysqld]<br>query_cache_size = 1000000<br>query_cache_limit = 2000000</p>
<p>show  variables like ‘Qcache%’<br>Qcache_queries_in_cache   在缓存中已注册的查询数目<br>Qcache_inserts       被加入到缓存中的查询数目<br>Qcache_hits      缓存采样数的数目<br>Qcache_lowmem_pruns     因为缺少内存而被从缓存中删除的查询数目<br>Qcache_not_cached      没有被缓存的查询数目<br>Qcache_free_memory     查询缓存的空闲内存总数<br>Qcache_free_blocks     查询缓存的空闲内存块总数<br>Qcache_total_blocks   查询缓存中的块的总数目<br>如果空闲内存块总是总内存块的一半左右，表示存在严重的内部碎片，通常使用flush query cache命令整理碎片，然后 采用reset query cache清理查询缓存<br>如果碎片很少，但是缓存命中率低，说明设置的缓存内存空间小，服务器频繁删除旧的查询缓存，腾出空间，保证新的查询缓存，参数Qcache_lowmem_prunes增加，如果此值增长过快，可能 1.如果存在大量空闲块，则是因为碎片的存在引起的   2. 空闲内存较少，可以适当增加缓存大小。</p>
<p>分区表<br>SHOW VARIABLES LIKE ‘%partition%’  查看是否支持分区</p>
<ol>
<li>range分区<br>CREATE TABLE emp(<br> empNo VARCHAR(20) NOT NULL,<br> empName VARCHAR(20),<br> deptNo INT,<br> birthdate DATE,<br> salary INT<br>)<br>PARTITION BY RANGE(salary)<br>(<br> PARTITION p1 VALUES LESS THAN(1000),<br> PARTITION p2 VALUES LESS THAN(2000),<br> PARTITION p3 VALUES LESS THAN(3000)<br>)<br>INSERT INTO emp VALUES(1000,’kobe’,12,’1888-08-08’,1500);<br>INSERT INTO emp VALUES(1000,’kobe’,12,’1888-08-08’,3500);<br>第二条插入失败，因为分区找不到符合条件的表让其插入 。<br>改为如下：<br>CREATE TABLE emp(<br> empNo VARCHAR(20) NOT NULL,<br> empName VARCHAR(20),<br> deptNo INT,<br> birthdate DATE,<br> salary INT<br>)<br>PARTITION BY RANGE(salary)<br>(<br> PARTITION p1 VALUES LESS THAN(1000),<br> PARTITION p2 VALUES LESS THAN(2000),<br> PARTITION p3 VALUES LESS THAN(3000),<br> PARTITION p4 VALUES LESS THAN(4000)     //也可以使用表达式   eg: less than maxValue<br>)<br>INSERT INTO emp VALUES(1000,’kobe’,12,’1888-08-08’,1500);<br>INSERT INTO emp VALUES(1000,’kobe’,12,’1888-08-08’,3500);<br>插入成功<br>range分区常常使用在以下几种情况：</li>
<li>如果要删除某个时间段的数据，只需要删除分区即可。alter table emp drop partion p0 的效率高于 delete from emp where 子句</li>
<li>如果使用包含日期或者时间的列可以考虑使用Range分区</li>
<li><p>经常行运行直接依赖于分割表的列的查询。比如where year(birth) = 1999 group by empno 此时mysql数据库可以很迅速的确定只有分区P2需要扫描</p>
</li>
<li><p>LIST分区<br>list分区类似range分区，区别在于，list分区中每个分区的定义和选择是基于某列的值从属于一个集合，而range分区是从属于一个连续区间值的集合<br>PARTITION BY LIST(deptNo)<br>(<br>PARTITION p1 VALUES IN (10,20),<br>PARTITION p2 VALUES IN (30),<br>PARTITION p3 VALUES IN (40)<br>)<br>INSERT INTO emp VALUES(1000,’kobe’,10,’1888-08-08’,1500);<br>INSERT INTO emp VALUES(1000,’kobe’,30,’1888-08-08’,3500);<br>插入数据的部门编号不在分区值列表中时，那么执行失败<br>INSERT INTO emp VALUES(1000,’kobe’,15,’1888-08-08’,3500);</p>
</li>
<li><p>HASH分区<br>用户索要做的就是基于将要被哈希的列值指定一个列值或表达式，以及指定被分区的表将要被分割的分区数量<br>CREATE TABLE emp(<br>empNo VARCHAR(20) NOT NULL,<br>empName VARCHAR(20),<br>deptNo INT,<br>birthdate DATE,<br>salary INT<br>)<br>PARTITION BY HASH(YEAR(birthdate)) PARTITIONS  4</p>
</li>
<li><p>线性HASH分区</p>
</li>
<li>KEY分区<br>partition by key(birthdate) partitions 4</li>
<li>复合分区<br>复合分区是分区表中每个分区的再次分割，子分区既可以使用HASH分区，也可以使用KEY分区<br>CREATE TABLE emp(<br> empNo VARCHAR(20) NOT NULL,<br> empName VARCHAR(20),<br> deptNo INT,<br> birthdate DATE,<br> salary INT<br>)<br>PARTITION BY RANGE(salary)<br>SUBPARTITION BY HASH(YEAR(birthdate))<br>SUBPARTITIONS 3<br>(<br> PARTITION p1 VALUES LESS THAN(2000),<br> PARTITION p2 VALUES LESS THAN(5000)<br>)</li>
</ol>
<p>SQL性能优化<br>case 1:<br>CREATE TABLE emp(<br>    id INTEGER PRIMARY KEY AUTO_INCREMENT,<br>    deptNo INTEGER,<br>    col3 INTEGER,<br>    col4 INTEGER<br>)<br>INSERT INTO emp VALUES(1,1,2,3);<br>INSERT INTO emp VALUES(2,3,4,5);<br>INSERT INTO emp VALUES(3,4,5,6);</p>
<p>EXPLAIN SELECT id FROM emp WHERE deptno=2 AND col3 &gt; 1 ORDER BY col4 DESC<br>ALTER TABLE emp ADD INDEX index_1(deptno,col3,col4)<br>// 因为按照BTree索引的原理，先排序deptno,如果遇到相同的deptno就会进行对col3进行排序<br>// 如果遇到相同的col3就会对 col4排序<br>DROP INDEX index_1 ON emp<br>ALTER TABLE emp ADD INDEX index_1(deptno,col4)</p>
<p>case 2: 多表查询优化的例子<br>CREATE TABLE table1(<br>    id INTEGER PRIMARY KEY,<br>    tid INTEGER NOT NULL<br>);<br>CREATE TABLE table2(<br>    id INTEGER PRIMARY KEY     AUTO_INCREMENT,<br>    tid INTEGER NOT NULL<br>);<br>INSERT INTO table1 VALUES(1,1);<br>INSERT INTO table1 VALUES(2,2);<br>INSERT INTO table1 VALUES(3,3);<br>INSERT INTO table1 VALUES(4,4);</p>
<p>INSERT INTO table2 VALUES(1,5);<br>INSERT INTO table2 VALUES(2,6);<br>INSERT INTO table2 VALUES(3,7);<br>INSERT INTO table2 VALUES(4,8);<br>优化前：第二张表检索4行数据，且extra没有使用索引<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-10/38631395.jpg" alt=""><br>添加索引 alter table table2 add index(tid)<br>优化后:第二张表检索1行数据，且extra使用索引<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-10/69687340.jpg" alt=""></p>
<p>利用Profiling分析查询语句<br>set profiling = 1 开启profiling<br>show profiles<br>show profile for query 8;<br>show profile cpu for query 8;<br>show profile block io for query 8;</p>
<ul>
<li>索引<br>使用like关键词，只有”%”不在第一个位置，索引才会起作用<br>使用多列索引的查询语句，只有查询语句使用了索引的第一个字段时，索引才会被使用<br>使用OR关键词前后两个条件中的列都是索引时，查询中才使用索引，否则不使用索引。</li>
<li>优化Insert语句<ol>
<li>一次性插入多值<br>eg: insert into books values(1,’book’),(2,’book2’),(3,’book3’)</li>
<li>通常可以锁定表以加速插入数据<br>lock tables test write; insert …; unlock tables;<br>如果不加锁定表，每一次执行insert语句完成后，索引缓冲区都会被写到磁盘上，而加入锁定后索引缓冲区仅被写到磁盘上1次</li>
</ol>
</li>
<li>优化Order By<br>建立索引，使用索引字段order by</li>
<li>优化group by<br>使用order by null 的group by语句减少了文件排序的步骤</li>
<li>优化嵌套查询<br>使用连接查询不需要建立临时表，其速度比子查询要快。</li>
<li>优化数据库结构<ol>
<li>将字段很多的表分解成多个表，可以按照重要性和使用频率分开</li>
<li>增加中间表，把需要经常联合查询的数据插入到中间表中。类似于视图</li>
<li>增加冗余字段</li>
</ol>
</li>
</ul>
<p>彻底删除mysql<br>yum remove mysql mysql-server mysql-libs compat-mysql51<br>rm -rf /var/lib/mysql<br>rm /etc/my.cnf<br>查看是否还有mysql软件：<br>rpm -qa|grep mysql<br>有的话继续删除</p>
<p>MySQL源码安装</p>
<ol>
<li>首先下载mysql-5.5.24.tar.gz 和 cmake-2.8.4.tar.gz 两个源文件</li>
<li>安装MySQL源文件包是采用cmake安装的，首先安装cmake</li>
<li>tar -zxvf cmake-2.8.4.tar.gz , cd cmake-2.8.4</li>
<li>./configure -&gt; make -&gt; make install</li>
<li>mkdir -p /usr/local/mysql    mkdir -p /usr/local/mysql/data</li>
<li>tar zxvf mysql-5.5.24.tar.gz</li>
<li>cmake -DCMAKE_INSTALL_PREFIX=/usr/loca/mysql -DMYSQL_DATADIR=/usr/loca/mysql/data -DDEFAULT_CHARSET=utf8<br>-DDEFAULT_COLLATION=utf8_general_ci   -DEXTRA_CHARSET=all</li>
<li>make -&gt; make install</li>
<li>cp ./support_files/my-medium.cnf /etc/my.cnf</li>
<li>./scripts/mysql_install_db –user=mysql</li>
<li>vim .bash_profile<br>PATH=$PATH:$HOME/bin:/usr/local/mysql/bin:/usr/local/mysql/lib<br>source .bash_profile</li>
<li>echo $PATH 检查路径是否生效</li>
<li>./bin/mysqld_safe –user=mysql &amp; 启动mysql服务</li>
</ol>
<p>安装apache服务器<br>./configure –prefix=/usr/local/apache<br>make<br>make install<br>然后  cd /usr/local/apache/bin    ./apachectl -t 检查配置文件语法是否正确<br>vim /etc/profile 添加环境变量   source  profile  使之生效<br>apachetl start  启动服务</p>
<p>Sysstat软件包集成如下工具<br><a href="http://sebastien.godard.pagesperso-orange.fr/" target="_blank" rel="external">http://sebastien.godard.pagesperso-orange.fr/</a><br>iostat 提供CPU和使用率及硬盘吞吐效率的数据<br>mpstat 提供单个处理器或多个处理器相关数据<br>sar  负责收集、报告并存储系统活跃的信息<br>sar1  负责收集并存储每天系统动态信息到一个二进制的文件中<br>sar2  负责把每天的系统活跃信息写入总结性的报告中<br>sadc  系统动态数据收集工具，收集的数据被写入一个二进制的文件中<br>sadf  显示被sar工具通过多种格式收集的数据</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大数据]]></title>
      <url>http://yoursite.com/2016/05/04/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>http是比TCP更高层次的应用层协议，只有底层协议建立之后才能建立更高层协议的连接，因此需要建立TCP连接<br>Web服务器以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>
<h3 id="HTTPS和HTTP区别："><a href="#HTTPS和HTTP区别：" class="headerlink" title="HTTPS和HTTP区别："></a>HTTPS和HTTP区别：</h3><ol>
<li>HTTPS协议需要到CA申请证书，免费证书较少，一般需要交费</li>
<li>HTTP的信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议</li>
<li>HTTP和HTTPS使用完全不同的连接方式，用的端口也不一样，HTTP是80，HTTPS是443</li>
<li>HTTPS是由SSL+HTTP构建的可进行加密传输，身份认证的网络协议，比HTTP安全</li>
</ol>
<h3 id="Cookie属性"><a href="#Cookie属性" class="headerlink" title="Cookie属性"></a>Cookie属性</h3><p>String name 该Cookie的名称，一旦创建，不可更改<br>Object value 该Cookie的值，如果为Unicode字符，需要为字符编码；若为二进制，则用BASE64编码<br>int maxAge  失效时间，单位秒。如果为证书，则在maxAge秒后失效；若为负数，则为临时Cookie，关闭浏览器即失效，若为0，表示删除该Cookie<br>boolean secure  是否仅被使用安全协议传输。安全协议有HTTPS、SSL等，在网络传输前，先将数据加密，默认false<br>String domain   可以访问该Cookie的域名，如果设置为“.google.com”,则所有以“google.com”结尾的域名都可以访问该Cookie<br>String comment   该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明<br>int version   版本号</p>
<p>客户端访问服务器时，服务器吧客户端信息以某种形式记录在服务器上。客户端浏览器再次访问时只需要从该Session中查找该用户的状态<br>如果说Cookie机制是通过检查客户身上的通行证来确定客户身份的话，那么Session机制就是通过检查服务器上的客户明细表来确认客户身份的。<br>如果客户端浏览器将Cookie功能禁用或者不支持Cookie，可以通过URL地址重写来解决，将该用户Session的ID信息重写到URL地址中，服务器能够解析重写后的URL获取Session的ID，这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。</p>
<h3 id="Session属性"><a href="#Session属性" class="headerlink" title="Session属性"></a>Session属性</h3><p>void setAttribute(String attribute,Object value)<br>String getAttribute(String attribute)<br>long getCreateTime()<br>boolean isNew()<br>void invalidate() 使该Session失效</p>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP理论指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ol>
<li>一致性(Consistency,C):所有节点访问同一份最新的数据副本。在分布式系统中的所有数据备份，在同一时刻是否同样的值</li>
<li>可用性(Availability,A):对数据更新具备高可用性。在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求</li>
<li>分区容忍性(Partition  tolerance,P):当集群中的某些节点无法联系时，仍能正常提供服务。以实际效果而言，分区相当于对通信的时限要求，系统如果不能再时限内达成数据一致性，意味着发生了分区的情况，必须就当前操作在一致性和可用性之间做出选择。<br>CAP理论告诉我们，在大规模的分布式系统中，分区容忍性是基本要求，所以要对可用性和一致性有所权衡。</li>
</ol>
<h3 id="进程间通信-Interprocess-Communication-IPC"><a href="#进程间通信-Interprocess-Communication-IPC" class="headerlink" title="进程间通信(Interprocess Communication,IPC)"></a>进程间通信(Interprocess Communication,IPC)</h3><h3 id="网络服务泛型"><a href="#网络服务泛型" class="headerlink" title="网络服务泛型"></a>网络服务泛型</h3><p>java的JINI(Java Intelligent Network Infrastructure)和web service 都是属于该泛型的网络设施。Web服务使用XML和XSD标准来自我描述，用简单对象访问协议(Simple Object Access Protocol,SOAP)交换数据。使用Web服务技术，能使运行与不同机器上的不同应用无需借助其他的支持就可以相互通信。Web服务向外提供一个能够通过Web进行调用的API，即目录服务。</p>
<h3 id="java-Socket编程"><a href="#java-Socket编程" class="headerlink" title="java Socket编程"></a>java Socket编程</h3><h3 id="Web-Service优点"><a href="#Web-Service优点" class="headerlink" title="Web Service优点"></a>Web Service优点</h3><ol>
<li>良好的封装性，服务使用者只能看到对象提供的通用接口和功能列表，不用关心服务的细节</li>
<li>松耦合，只要调用接口不变，内部变更对于调用者透明</li>
<li>使用标准协议规范。基于XML的消息交换机制，其所有公共的协约都采用Internet开放标准协议进行描述、传输和交换</li>
<li>高度可继承性，屏蔽了不同软件、平台差异</li>
<li>易于构建</li>
</ol>
<p>服务描述(WSDL)位于SOAP的上一层，也是基于XML的，用以描述服务端口访问方式和使用协议的细节，通常用来辅助生成服务器和客户端代码及配置信息。<br>UDDI是一个公开的目录，服务提供中将WebService注册并发布到此目录中，而服务使用者也是通过此目录来发现能满足自己需求的服务</p>
<p>WebService角色包括服务提供者、服务注册中心和服务使用者</p>
<p>吴培君(榕舒)：peijun.wpj@alibaba-inc.com</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java反射]]></title>
      <url>http://yoursite.com/2016/05/04/java%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<p>1、Java反射的概念<br>    反射含义：可以获取正在运行的Java对象。<br>2、Java反射的功能<br>    1)可以判断运行时对象所属的类<br>    2)可以判断运行时对象所具有的成员变量和方法<br>    3)通过反射甚至可以调用到private的方法<br>    4)生成动态代理<br>3、实现Java反射的类<br>    1)Class：它表示正在运行的Java应用程序中的类和接口<br>    2)Field：提供有关类或接口的属性信息，以及对它的动态访问权限<br>    3)Constructor：提供关于类的单个构造方法的信息以及对它的访问权限<br>    4)Method：提供关于类或接口中某个方法信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">POJO</div><div class="line">public class Employee implements Cloneable&#123;</div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	private int[] arr;</div><div class="line">	public Employee()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public Employee(String name, int age, int[] arr) &#123;</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">		this.arr = arr;</div><div class="line">	&#125;</div><div class="line">	public int[] getArr() &#123;</div><div class="line">		return arr;</div><div class="line">	&#125;</div><div class="line">	public void setArr(int[] arr) &#123;</div><div class="line">		this.arr = arr;</div><div class="line">	&#125;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void display()&#123;</div><div class="line">		System.out.println(&quot;name=&quot;+name+&quot; ;age=&quot;+age);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void send(String message)&#123;</div><div class="line">		System.out.println(message);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String toString() &#123;</div><div class="line">		return &quot;Employee [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException &#123;</div><div class="line"></div><div class="line">		System.out.println(&quot;------------反射机制获取类的三种方法---------------&quot;);</div><div class="line">		Class&lt;?&gt; c1 = Class.forName(&quot;com.reflect.Employee&quot;); // 注意全类名</div><div class="line">		Class&lt;?&gt; c2 = Employee.class;</div><div class="line">		Employee e = new Employee(&quot;lisan&quot;, 18, new int[]&#123;12,13&#125;);</div><div class="line">		Class&lt;?&gt; c3 = e.getClass();</div><div class="line">		// 创建对象</div><div class="line">		Object o = c1.newInstance();</div><div class="line">		// 获取属性 ，分为所有的属性和指定的属性</div><div class="line">		System.out.println(&quot;---------------获取全部属性---------------&quot;);</div><div class="line">		Class&lt;?&gt; c = Class.forName(&quot;java.lang.Integer&quot;);</div><div class="line">		Field[] fs = c.getDeclaredFields();</div><div class="line">		StringBuffer sb = new StringBuffer();</div><div class="line">		sb.append(Modifier.toString(c.getModifiers())+&quot; class &quot;+c.getSimpleName()+&quot;&#123;\n&quot;);</div><div class="line">		for(Field field : fs)&#123;</div><div class="line">			sb.append(&quot;\t&quot;);</div><div class="line">			sb.append(Modifier.toString(field.getModifiers())+&quot; &quot;);  //获得属性的修饰符，例如public，static</div><div class="line">			sb.append(field.getType().getSimpleName()+&quot; &quot;);  //属性的类型的名字</div><div class="line">			sb.append(field.getName()+&quot;;\n&quot;);  //属性的名字+回车</div><div class="line">		&#125;</div><div class="line">		sb.append(&quot;&#125;&quot;);</div><div class="line">		System.out.println(sb);</div><div class="line">		System.out.println(&quot;---------------获取部分属性-----------------&quot;);</div><div class="line">		Field nameF = c1.getDeclaredField(&quot;name&quot;);</div><div class="line">		Field ageF = c1.getDeclaredField(&quot;age&quot;);</div><div class="line">		Object oo = c1.newInstance();</div><div class="line">		nameF.setAccessible(true); // 使用反射机制可以打破封装性，导致了java对象的属性不安全。</div><div class="line">		ageF.setAccessible(true);  // 使用反射机制可以打破封装性，导致了java对象的属性不安全。</div><div class="line">		nameF.set(oo, &quot;lisan&quot;);  // 给oo对象的name属性赋值&quot;lisan&quot;</div><div class="line">		ageF.set(oo,18);   // 给oo对象的age属性赋值&quot;11&quot;</div><div class="line">		System.out.println(nameF.get(oo));  // 得到oo对象的name属性的值</div><div class="line">		System.out.println(ageF.get(oo));   // 得到oo对象的age属性的值</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">输出--&gt;</div><div class="line">------------反射机制获取类的三种方法---------------</div><div class="line">---------------获取全部属性---------------</div><div class="line">public final class Integer&#123;</div><div class="line">	public static final int MIN_VALUE;</div><div class="line">	public static final int MAX_VALUE;</div><div class="line">	public static final Class TYPE;</div><div class="line">	static final char[] digits;</div><div class="line">	static final char[] DigitTens;</div><div class="line">	static final char[] DigitOnes;</div><div class="line">	static final int[] sizeTable;</div><div class="line">	private final int value;</div><div class="line">	public static final int SIZE;</div><div class="line">	private static final long serialVersionUID;</div><div class="line">	static final boolean $assertionsDisabled;</div><div class="line">&#125;</div><div class="line">---------------获取部分属性-----------------</div><div class="line">lisan</div><div class="line">18</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">public class TestReflect &#123;</div><div class="line">	public static void main(String[] args) throws ClassNotFoundException &#123;</div><div class="line">		Class&lt;Employee&gt; c1 = Employee.class;</div><div class="line">		Class&lt;?&gt; c2 = Class.forName(&quot;com.reflect.Employee&quot;);</div><div class="line">		// 获取类的修饰符</div><div class="line">		int mod = c1.getModifiers();</div><div class="line">		System.out.println(mod);</div><div class="line">		System.out.println(Modifier.toString(mod));</div><div class="line">		// 获得类全名</div><div class="line">		String name = c1.getName();</div><div class="line">		System.out.println(name);</div><div class="line">		// 获得父类</div><div class="line">		Class superClass = c1.getSuperclass();</div><div class="line">		System.out.println(superClass);</div><div class="line">		// 获取c1实现的接口</div><div class="line">		Class[] interfaces = c1.getInterfaces();</div><div class="line">		for (Class t : interfaces) &#123;</div><div class="line">			System.out.println(&quot;interfacesName = &quot; + t.getName());</div><div class="line">		&#125;</div><div class="line">		//获取指定类的成员变量</div><div class="line">		System.out.println(&quot;-----------获取指定类的成员变量-----------&quot;);</div><div class="line">		Field[] fields = c1.getDeclaredFields();</div><div class="line">		for (Field field : fields) &#123;</div><div class="line">			String modifier = Modifier.toString(field.getModifiers());</div><div class="line">			Class&lt;?&gt; type = field.getType();</div><div class="line">			String name2 = field.getName();</div><div class="line">			if(type.isArray())&#123;</div><div class="line">				String arrType = type.getComponentType().getName()+&quot;[]&quot;;</div><div class="line">				System.out.println(&quot;&quot;+modifier+&quot; &quot;+arrType+&quot; &quot;+name2+&quot;;&quot;);</div><div class="line">			&#125;else&#123;</div><div class="line">				System.out.println(&quot;&quot;+modifier+&quot; &quot;+type+&quot; &quot;+name2+&quot;;&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		// 获取类的构造方法</div><div class="line">		System.out.println(&quot;------------获取类的构造方法--------------&quot;);</div><div class="line">		Constructor[] constructors = c1.getDeclaredConstructors();</div><div class="line">		for (Constructor constructor : constructors) &#123;</div><div class="line">			String name3 = constructor.getName(); //构造方法名</div><div class="line">			String modi = Modifier.toString(constructor.getModifiers()); //获取访问修饰符</div><div class="line">			System.out.print(&quot;&quot; + modi +&quot; &quot; + name3 + &quot;(&quot;);</div><div class="line">			Class[] paramTypes = constructor.getParameterTypes(); //获取构造方法中的参数</div><div class="line">		for (int i = 0; i &lt; paramTypes.length; i++) &#123;</div><div class="line">			// 从第二个参数开始加符号</div><div class="line">			if (i &gt; 0) &#123;</div><div class="line">				System.out.print(&quot;,&quot;);</div><div class="line">			&#125;</div><div class="line">			if (paramTypes[i].isArray()) &#123;</div><div class="line">				System.out.print(paramTypes[i].getComponentType().getName()+&quot;[]&quot;);</div><div class="line">			&#125; else &#123;</div><div class="line">				System.out.print(paramTypes[i].getName());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;);&quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// 获取成员方法</div><div class="line">		System.out.println(&quot;---------获取成员方法----------&quot;);</div><div class="line">		Method[] methods = c1.getDeclaredMethods();</div><div class="line">		for (Method method : methods) &#123;</div><div class="line">			String modif = Modifier.toString(method.getModifiers());</div><div class="line">			Class returnType = method.getReturnType();</div><div class="line">			if(returnType.isArray())&#123;</div><div class="line">				String arrType = returnType.getComponentType().getName()+&quot;[]&quot;;</div><div class="line">				System.out.print(&quot;&quot;+modif+&quot; &quot;+arrType+&quot; &quot;+method.getName()+&quot;(&quot;);</div><div class="line">			&#125;else&#123;</div><div class="line">				System.out.print(&quot;&quot;+modif+&quot; &quot;+returnType.getName()+&quot; &quot;+method.getName()+&quot;(&quot;);</div><div class="line">			&#125;</div><div class="line">			Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</div><div class="line">			for(int i=0;i&lt;paramTypes.length;i++)&#123;</div><div class="line">				if(i&gt;0)&#123;</div><div class="line">					System.out.print(&quot;,&quot;);</div><div class="line">				&#125;</div><div class="line">				if(paramTypes[i].isArray())&#123;</div><div class="line">					System.out.print(paramTypes[i].getComponentType().getName()+&quot;[]&quot;);</div><div class="line">				&#125;else&#123;</div><div class="line">					System.out.print(paramTypes[i].getName());</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			System.out.println(&quot;);&quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// java动态绑定</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">输出---&gt;</div><div class="line">1</div><div class="line">public</div><div class="line">com.reflect.Employee</div><div class="line">class java.lang.Object</div><div class="line">interfacesName = java.lang.Cloneable</div><div class="line">-----------获取指定类的成员变量-----------</div><div class="line">private class java.lang.String name;</div><div class="line">private int age;</div><div class="line">private int[] arr;</div><div class="line">------------获取类的构造方法--------------</div><div class="line">public com.reflect.Employee();</div><div class="line">public com.reflect.Employee(java.lang.String,int,int[]);</div><div class="line">---------获取成员方法----------</div><div class="line">public java.lang.String toString();</div><div class="line">public java.lang.String getName();</div><div class="line">public void setName(java.lang.String);</div><div class="line">public int[] getArr();</div><div class="line">public void setArr(int[]);</div><div class="line">public void setAge(int);</div><div class="line">public void send(java.lang.String);</div><div class="line">public void display();</div><div class="line">public int getAge();</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux必学的60个命令]]></title>
      <url>http://yoursite.com/2016/04/29/linux%E5%BF%85%E5%AD%A6%E7%9A%8460%E4%B8%AA%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>Linux必学的60个命令<br>linux命令笔记</p>
<p>IDC(Internet Data Center)<br>mkdir nihao<br>mkdir -p 123/456/789依次创建 tree 123 以树形显示<br>mkdir a b c 同时创建三个目录</p>
<p>touch text 创建空文件<br>ll text 列出详细信息<br>touch a b c<br>若文件已经存在，则touch一下可以更新文件时间</p>
<p>ls -l<br>ls -F 目录和文件分明<br>ls -R 当前目录下文件和子目录<br>ls -a 显示隐藏文件</p>
<p>cp -r text/ test/</p>
<p>ln -s a aa 创建a的软链接</p>
<p>rm -rf a   强制删除</p>
<p>cat b<br>cat -n /etc/passwd  查看的时候显示行号</p>
<p>head /etc/passwd  默认显示前10行<br>tail /etc/passwd  默认显示后10行</p>
<p>du -sh desktop/ 统计目录或者文件大小</p>
<p>file test.txt 查看文件属性<br>whereis test.txt 文件定位命令<br>whereis ls</p>
<p>wc -l test.txt统计行数<br>wc -c text.txt统计字节数<br>wc -w text.txt统计单词数</p>
<p>history查看命令历史记录<br>！2 可执行相对应命令<br>history -c 清除命令的历史记录</p>
<p>which命令<br>which ls<br>which passwd<br>which useradd 查找命令位置</p>
<p>passwd  修改当前用户密码<br>passwd wl  修改制定用户密码<br>passwd -l wl  锁住用户<br>passwd -S wl  查看用户状态<br>passwd -u wl  给用户解锁</p>
<p>useradd user1 -g group1<br>mkdir -m 700 test<br>mddir -p test/test1/test2 递归的简历目录</p>
<p>ls -R<br>ls -t<br>ls -l –color=never<br>ls -l –full-time<br>ls -F 类型</p>
<p>rm -rif test/*</p>
<p>Linux提供了大量的命令，利用它可以有效地完成大量的工<br>作，如磁盘操作、文件存取、目录操作、进程管理、文件权限设定等。所以，在Linux系统上工作离不开使用系统提供的命令。要想真正理解Linux系统，<br>就必须从Linux命令学起，通过基础的命令学习可以进一步理解Linux系统。<br>不同Linux发行版的命令数量不一样，但Linux发行版本最少的命令也有200多个。这里笔者把比较重要和使用频率最多的命令，按照它们在系统中的作用分成下面六个部分一一介绍。<br>◆ 安装和登录命令：login、shutdown、halt、reboot、install、mount、umount、chsh、exit、last；<br>◆ 文件处理命令：file、mkdir、grep、dd、find、mv、ls、diff、cat、ln；<br>◆ 系统管理相关命令：df、top、free、quota、at、lp、adduser、groupadd、kill、crontab；<br>◆ 网络操作命令：ifconfig、ip、ping、netstat、telnet、ftp、route、rlogin、rcp、finger、mail、nslookup；<br>◆ 系统安全相关命令：passwd、su、umask、chgrp、chmod、chown、chattr、sudops、who；<br>◆ 其它命令：tar、unzip、gunzip、unarj、mtools、man、unendcode、uudecode。<br>本文以Mandrake Linux 9.1(Kenrel 2.4.21)为例，介绍Linux下的安装和登录命令。<br>immortality按：请用ctrl+f在本页中查找某一部分的内容或某一命令的用法。<br>Linux必学的60个命令(1)-安装与登陆命令<br>login<br>1.作用<br>login的作用是登录系统，它的使用权限是所有用户。<br>2.格式<br>login [name][－p ][－h 主机名称]<br>3.主要参数<br>－p:通知login保持现在的环境参数。<br>－h:用来向远程登录的之间传输用户名。<br>如果选择用命令行模式登录Linux的话，那么看到的第一个Linux命令就是login：。<br>一般界面是这样的：<br>Manddrake Linux release 9.1(Bamboo) for i586<br>renrel 2.4.21－0.13mdk on i686 / tty1<br>localhost login:root<br>password:<br>上面代码中，第一行是Linux发行版本号，第二行是内核版本号和登录的虚拟控制台，我们在第三行输入登录名，按“Enter”键在Password后输入账户密码，即可登录系统。出于安全考虑，输入账户密码时字符不会在屏幕上回显，光标也不移动。<br>登录后会看到下面这个界面（以超级用户为例）：<br>[root@localhost root]#<br>last login:Tue ,Nov 18 10:00:55 on vc/1<br>上面显示的是登录星期、月、日、时间和使用的虚拟控制台。<br>4.应用技巧<br>Linux<br>是一个真正的多用户操作系统，可以同时接受多个用户登录，还允许一个用户进行多次登录。这是因为Linux和许多版本的Unix一样，提供了虚拟控制台的<br>访问方式，允许用户在同一时间从控制台（系统的控制台是与系统直接相连的监视器和键盘）进行多次登录。每个虚拟控制台可以看作是一个独立的工作站，工作台<br>之间可以切换。虚拟控制台的切换可以通过按下Alt键和一个功能键来实现，通常使用F1-F6 。<br>例如，用户登录后，按一下“Alt+<br>F2”键，用户就可以看到上面出现的“login:”提示符，说明用户看到了第二个虚拟控制台。然后只需按“Alt+<br>F1”键，就可以回到第一个虚拟控制台。一个新安装的Linux系统允许用户使用“Alt+F1”到“Alt+F6”键来访问前六个虚拟控制台。虚拟控制<br>台最有用的是，当一个程序出错造成系统死锁时，可以切换到其它虚拟控制台工作，关闭这个程序。<br>shutdown<br>1.作用<br>shutdown命令的作用是关闭计算机，它的使用权限是超级用户。<br>2.格式<br>shutdown [－h][－i][－k][－m][－t]<br>3.重要参数<br>－t：在改变到其它运行级别之前，告诉init程序多久以后关机。<br>－k：并不真正关机，只是送警告信号给每位登录者。<br>－h：关机后关闭电源。<br>－c：cancel current process取消目前正在执行的关机程序。所以这个选项当然没有时间参数，但是可以输入一个用来解释的讯息，而这信息将会送到每位使用者。<br>－F：在重启计算机时强迫fsck。<br>－time：设定关机前的时间。<br>－m: 将系统改为单用户模式。<br>－i：关机时显示系统信息。<br>4.命令说明<br>shutdown<br>命令可以安全地将系统关机。有些用户会使用直接断掉电源的方式来关闭Linux系统，这是十分危险的。因为Linux与Windows不同，其后台运行着<br>许多进程，所以强制关机可能会导致进程的数据丢失，使系统处于不稳定的状态，甚至在有的系统中会损坏硬件设备（硬盘）。在系统关机前使用<br>shutdown命令，系统管理员会通知所有登录的用户系统将要关闭，并且login指令会被冻结，即新的用户不能再登录。<br>halt<br>1.作用<br>halt命令的作用是关闭系统，它的使用权限是超级用户。<br>2.格式<br>halt [－n] [－w] [－d] [－f][－i] [－p]<br>3.主要参数说明<br>－n：防止sync系统调用，它用在用fsck修补根分区之后，以阻止内核用老版本的超级块覆盖修补过的超级块。<br>－w：并不是真正的重启或关机,只是写wtmp（/var/log/wtmp）纪录。<br>－f：没有调用shutdown，而强制关机或重启。<br>－i：关机（或重启）前，关掉所有的网络接口。<br>－f：强迫关机，不呼叫shutdown这个指令。<br>－p: 当关机的时候顺便做关闭电源的动作。<br>－d：关闭系统，但不留下纪录。　<br>4.命令说明<br>halt<br>就是调用shutdown<br>－h。halt执行时，杀死应用进程，执行sync(将存于buffer中的资料强制写入硬盘中)系统调用，文件系统写操作完成后就会停止内核。若系统的<br>运行级别为0或6，则关闭系统；否则以shutdown指令（加上－h参数）来取代。　<br>reboot<br>1.作用<br>reboot命令的作用是重新启动计算机，它的使用权限是系统管理者。<br>2.格式<br>reboot [－n] [－w] [－d] [－f][－i]<br>3.主要参数<br>－n: 在重开机前不做将记忆体资料写回硬盘的动作。<br>－w: 并不会真的重开机，只是把记录写到/var/log/wtmp文件里。<br>－d: 不把记录写到/var/log/wtmp文件里（－n这个参数包含了－d）。<br>－i: 在重开机之前先把所有与网络相关的装置停止。<br>install<br>1.作用<br>install命令的作用是安装或升级软件或备份数据，它的使用权限是所有用户。<br>2.格式<br>(1)install [选项]… 来源 目的地<br>(2)install [选项]… 来源… 目录<br>(3)install －d [选项]… 目录…<br>在<br>前两种格式中，会将复制至或将多个文件复制至已存在的，同时设定权<br>限模式及所有者/所属组。在第三种格式中，会创建所有指定的目录及它们的主目录。长选项必须用的参数在使用短选项时也是必须的。<br>3.主要参数<br>－－backup[=CONTROL]：为每个已存在的目的地文件进行备份。<br>－b：类似 －－backup，但不接受任何参数。<br>－c：(此选项不作处理)。<br>－d，－－directory：所有参数都作为目录处理，而且会创建指定目录的所有主目录。<br>－D：创建前的所有主目录，然后将复制至 ；在第一种使用格式中有用。<br>－g，－－group=组：自行设定所属组，而不是进程目前的所属组。<br>－m，－－mode=模式：自行设定权限模式 (像chmod)，而不是rwxr－xr－x。<br>－o，－－owner=所有者：自行设定所有者 (只适用于超级用户)。<br>－p，－－preserve－timestamps：以文件的访问/修改时间作为相应的目的地文件的时间属性。<br>－s，－－strip：用strip命令删除symboltable，只适用于第一及第二种使用格式。<br>－S，－－suffix=后缀：自行指定备份文件的。<br>－v，－－verbose：处理每个文件/目录时印出名称。<br>－－help：显示此帮助信息并离开。<br>－－version：显示版本信息并离开。<br>mount<br>1.作用<br>mount命令的作用是加载文件系统，它的用权限是超级用户或/etc/fstab中允许的使用者。<br>2.格式<br>mount －a [－fv] [－t vfstype] [－n][－rw] [－F] device dir<br>3.主要参数<br>－h：显示辅助信息。<br>－v：显示信息，通常和－f用来除错。<br>－a：将/etc/fstab中定义的所有文件系统挂上。<br>－F：这个命令通常和－a一起使用，它会为每一个mount的动作产生一个行程负责执行。在系统需要挂上大量NFS文件系统时可以加快加载的速度。<br>－f：通常用于除错。它会使mount不执行实际挂上的动作，而是模拟整个挂上的过程，通常会和－v一起使用。<br>－t vfstype：显示被加载文件系统的类型。<br>－n：一般而言，mount挂上后会在/etc/mtab中写入一笔资料，在系统中没有可写入文件系统的情况下，可以用这个选项取消这个动作。<br>4.应用技巧<br>在Linux<br>和Unix系统上，所有文件都是作为一个大型树（以/为根）的一部分访问的。要访问CD-ROM上的文件，需要将CD-ROM设备挂装在文件树中的某个挂<br>装点。如果发行版安装了自动挂装包，那么这个步骤可自动进行。在Linux中，如果要使用硬盘、光驱等储存设备，就得先将它加载，当储存设备挂上了之后，<br>就可以把它当成一个目录来访问。挂上一个设备使用mount命令。在使用mount这个指令时，至少要先知道下列三种信息：要加载对象的文件系统类型、要<br>加载对象的设备名称及要将设备加载到哪个目录下。<br>（1）Linux可以识别的文件系统<br>◆ Windows 95/98常用的FAT 32文件系统：vfat ；<br>◆ Win NT/2000 的文件系统：ntfs ；<br>◆ OS/2用的文件系统：hpfs；<br>◆ Linux用的文件系统：ext2、ext3；<br>◆ CD-ROM光盘用的文件系统：iso9660。<br>虽然vfat是指FAT 32系统，但事实上它也兼容FAT 16的文件系统类型。<br>（2）确定设备的名称<br>在Linux<br>中，设备名称通常都存在/dev里。这些设备名称的命名都是有规则的，可以用“推理”的方式把设备名称找出来。例如，/dev/hda1这个<br>IDE设备，hd是Hard Disk(硬盘)的，sd是SCSIDevice，fd是Floppy Device(或是Floppy<br>Disk?)。a代表第一个设备，通常IDE接口可以接上4个IDE设备(比如4块硬盘)。所以要识别IDE硬盘的方法分别就是hda、hdb、hdc、<br>hdd。hda1中的“1”代表hda的第一个硬盘分区<br>(partition)，hda2代表hda的第二主分区，第一个逻辑分区从hda5开始，依此类推。此外，可以直接检查<br>/var/log/messages文件，在该文件中可以找到计算机开机后系统已辨认出来的设备代号。<br>（3）查找挂接点<br>在决<br>定将设备挂接之前，先要查看一下计算机是不是有个/mnt的空目录，该目录就是专门用来当作挂载点(Mount<br>Point)的目录。建议在/mnt里建几个/mnt/cdrom、/mnt/floppy、/mnt/mo等目录，当作目录的专用挂载点。举例而言，如<br>要挂载下列5个设备，其执行指令可能如下 (假设都是Linux的ext2系统，如果是WindowsXX请将ext2改成vfat)：<br>软盘 ===&gt;mount －t ext2 /dev/fd0/mnt/floppy<br>cdrom ===&gt;mount －t iso9660 /dev/hdc /mnt/cdrom<br>SCSI cdrom ===&gt;mount －t iso9660 /dev/sdb /mnt/scdrom<br>SCSI cdr ===&gt;mount －t iso9660 /dev/sdc /mnt/scdr<br>不过目前大多数较新的Linux发行版本（包括红旗 Linux、中软Linux、MandrakeLinux等）都可以自动挂装文件系统，但Red Hat Linux除外。<br>umount<br>1.作用<br>umount命令的作用是卸载一个文件系统，它的使用权限是超级用户或/etc/fstab中允许的使用者。<br>2.格式<br>unmount －a [－fFnrsvw] [－t vfstype] [－n][－rw] [－F] device dir<br>3.使用说明<br>umount<br>命令是mount命令的逆操作，它的参数和使用方法和mount命令是一样的。Linux挂装CD-ROM后，会锁定CD—ROM，这样就不能用CD-<br>ROM面板上的Eject按钮弹出它。但是，当不再需要光盘时，如果已将/cdrom作为符号链接，请使用umount/cdrom来卸装它。仅当无用户<br>正在使用光盘时，该命令才会成功。该命令包括了将带有当前工作目录当作该光盘中的目录的终端窗口。<br>chsh<br>1.作用<br>chsh命令的作用是更改使用者shell设定，它的使用权限是所有使用者。<br>2.格式<br>chsh [ －s ] [ －list] [ －－help ] [ －v ][ username ]<br>3.主要参数<br>－l：显示系统所有Shell类型。<br>－v：显示Shell版本号。<br>4.应用技巧<br>前面介绍了Linux下有多种Shell，一般缺省的是Bash，如果想更换Shell类型可以使用chsh命令。先输入账户密码，然后输入新Shell类型，如果操作正确系统会显示“Shell change”。其界面一般如下：<br>Changing fihanging shell for cao<br>Password:<br>New shell [/bin/bash]: /bin/tcsh<br>上面代码中，[ ]内是目前使用的Shell。普通用户只能修改自己的Shell，超级用户可以修改全体用户的Shell。要想查询系统提供哪些Shell，可以使用chsh-l 命令，见图1所示。<br>图1 系统可以使用的Shell类型<br>从图1中可以看到，笔者系统中可以使用的Shell有bash（缺省）、csh、sh、tcsh四种。<br>exit<br>1.作用<br>exit命令的作用是退出系统，它的使用权限是所有用户。<br>2.格式<br>exit<br>3.参数<br>exit命令没有参数，运行后退出系统进入登录界面。<br>last<br>1.作用<br>last命令的作用是显示近期用户或终端的登录情况，它的使用权限是所有用户。通过last命令查看该程序的log，管理员可以获知谁曾经或企图连接系统。<br>2.格式<br>1ast[—n][－f file][－t tty] [—h 节点][－I—IP][—1][－y][1D]<br>3.主要参数<br>－n：指定输出记录的条数。<br>－f file：指定用文件file作为查询用的log文件。<br>－t tty：只显示指定的虚拟控制台上登录情况。<br>－h 节点：只显示指定的节点上的登录情况。<br>－i IP：只显示指定的IP上登录的情况。<br>－1：用IP来显示远端地址。<br>－y：显示记录的年、月、日。<br>－ID：知道查询的用户名。<br>－x:显示系统关闭、用户登录和退出的历史。<br>动手练习<br>上面介绍了Linux安装和登录命令，下面介绍几个实例，动手练习一下刚才讲过的命令。<br>1.一次运行多个命令<br>在一个命令行中可以执行多个命令，用分号将各个命令隔开即可，例如：<br>＃last －x；halt<br>上面代码表示在显示系统关闭、用户登录和退出的历史后关闭计算机。<br>2.利用mount挂装文件系统访问Windows系统<br>许多Linux发行版本现在都可以自动加载Vfat分区来访问Windows系统，而RedHat各个版本都没有自动加载Vfat分区，因此还需要进行手工操作。<br>mount<br>可以将Windows分区作为Linux的一个“文件”挂接到Linux的一个空文件夹下，从而将Windows的分区和/mnt这个目录联系起来。因<br>此，只要访问这个文件夹就相当于访问该分区了。首先要在/mnt下建立winc文件夹，在命令提示符下输入下面命令：<br>＃mount -t vfat /dev/hda1 /mnt/winc<br>即<br>表示将Windows的C分区挂到Liunx的/mnt/winc目录下。这时，在/mnt/winc目录下就可以看到Windows中C盘的内容了。使<br>用类似的方法可以访问Windows系统的D、E盘。在Linux系统显示Windows的分区一般顺序这样的：hda1为C盘、hda5为D盘、<br>hda6为E盘……以此类推。上述方法可以查看Windows系统有一个很大的问题，就是Windows中的所有中文文件名或文件夹名全部显示为问号<br>“？”，而英文却可以正常显示。我们可以通过加入一些参数让它显示中文。还以上面的操作为例，此时输入命令：<br>＃mount -t vfat -o iocharset=cp936 /dev/hda1 /mnt/winc<br>现在它就可以正常显示中文了。<br>3.使用mount加挂闪盘上的文件系统<br>在Linux下使用闪盘非常简单。Linux对USB设备有很好的支持，当插入闪盘后，闪盘被识别为一个SCSI盘，通常输入以下命令：<br>＃ mount /dev/sda1 /usb<br>就能够加挂闪盘上的文件系统。<br>小知识<br>Linux命令与Shell<br>所<br>谓Shell，就是命令解释程序，它提供了程序设计接口，可以使用程序来编程。学习Shell对于Linux初学者理解Linux系统是非常重要的。<br>Linux系统的Shell作为操作系统的外壳，为用户提供了使用操作系统的接口。Shell是命令语言、命令解释程序及程序设计语言的统称，是用户和<br>Linux内核之间的接口程序。如果把Linux内核想象成一个球体的中心，Shell就是围绕内核的外层。当从Shell或其它程序向Linux传递命<br>令时，内核会做出相应的反应。Shell在Linux系统的作用和MSDOS下的COMMAND.COM和Windows 95/98 的<br>explorer.exe相似。Shell虽然不是系统核心的一部分，只是系统核心的一个外延，但它能够调用系统内核的大部分功能。因此，可以说<br>Shell是Unux/Linux最重要的实用程序。<br>Linux中的Shell有多种类型，其中最常用的是Bourne<br>Shell(sh)、C Shell(csh)和Korn Shell(ksh)。大多数Linux发行版本缺省的Shell是Bourne<br>Again Shell，它是Bourne Shell的扩展，简称bash，与BourneShell完全向后兼容，并且在Bourne<br>Shell的基础上增加了很多特性。bash放在/bin/bash中，可以提供如命令补全、命令编辑和命令历史表等功能。它还包含了很多C<br>Shell和Korn<br>Shell中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。Linux系统中200多个命令中有40个是bash的内部命令，主要包括<br>exit、less、lp、kill、 cd、pwd、fc、fg等。</p>
<p>Linux必学的60个命令(2)-文件处理命令<br>Linux<br>系统信息存放在文件里，文件与普通的公务文件类似。每个文件都有自己的名字、内容、存放地址及其它一些管理信息，如文件的用户、文件的大小等。文件可以是<br>一封信、一个通讯录，或者是程序的源语句、程序的数据，甚至可以包括可执行的程序和其它非正文内容。<br>Linux文件系统具有良好的结构，系统提供了很多文件处理程序。这里主要介绍常用的文件处理命令。<br>file<br>1.作用 件内容判断文件类型，使用权限是所有用户。<br>2.格式<br>file通过探测文<br>file [options] 文件名<br>3.[options]主要参数<br>-v：在标准输出后显示版本信息，并且退出。<br>-z：探测压缩过的文件类型。<br>-L：允许符合连接。<br>-f name：从文件namefile中读取要分析的文件名列表。<br>4.简单说明<br>使用file命令可以知道某个文件究竟是二进制（ELF格式）的可执行文件, 还是ShellScript文件，或者是其它的什么格式。file能识别的文件类型有目录、Shell脚本、英文文本、二进制可执行文件、C语言源文件、文本文件、DOS的可执行文件。<br>5.应用实例<br>如果我们看到一个没有后缀的文件grap，可以使用下面命令：<br>$ file grap<br>grap： English text<br>此时系统显示这是一个英文文本文件。需要说明的是，file命令不能探测包括图形、音频、视频等多媒体文件类型。<br>mkdir<br>1.作用<br>mkdir命令的作用是建立名称为dirname的子目录，与MS DOS下的md命令类似，它的使用权限是所有用户。<br>2.格式<br>mkdir [options] 目录名<br>3.[options]主要参数<br>－m, －－mode=模式：设定权限，与chmod类似。<br>－p, －－parents：需要时创建上层目录；如果目录早已存在，则不当作错误。<br>－v, －－verbose：每次创建新目录都显示信息。<br>－－version：显示版本信息后离开。<br>4.应用实例<br>在进行目录创建时可以设置目录的权限，此时使用的参数是“－m”。假设要创建的目录名是“tsk”，让所有用户都有rwx(即读、写、执行的权限)，那么可以使用以下命令：<br>$ mkdir －m 777 tsk<br>grep<br>1.作用<br>grep命令可以指定文件中搜索特定的内容，并将含有这些内容的行标准输出。grep全称是Global RegularExpression Print，表示全局正则表达式版本，它的使用权限是所有用户。<br>2.格式<br>grep [options]<br>3.主要参数<br>[options]主要参数：<br>－c：只输出匹配行的计数。<br>－I：不区分大小写（只适用于单字符）。<br>－h：查询多文件时不显示文件名。<br>－l：查询多文件时只输出包含匹配字符的文件名。<br>－n：显示匹配行及行号。<br>－s：不显示不存在或无匹配文本的错误信息。<br>－v：显示不包含匹配文本的所有行。<br>pattern正则表达式主要参数：<br>\：忽略正则表达式中特殊字符的原有含义。<br>^：匹配正则表达式的开始行。<br>$: 匹配正则表达式的结束行。<br>\：到匹配正则表达式的行结束。<br>[ ]：单个字符，如[A]即A符合要求 。<br>[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。<br>。：所有的单个字符。</p>
<ul>
<li>：有字符，长度可以为0。<br>正<br>则表达式是Linux/Unix系统中非常重要的概念。正则表达式（也称为“regex”或“regexp”）是一个可以描述一类字符串的模式<br>（Pattern）。如果一个字符串可以用某个正则表达式来描述，我们就说这个字符和该正则表达式匹配（Match）。这和DOS中用户可以使用通配符<br>“<em>”代表任意字符类似。在Linux系统上，正则表达式通常被用来查找文本的模式，以及对文本执行“搜索－替换”操作和其它功能。<br>4.应用实例<br>查<br>询DNS服务是日常工作之一，这意味着要维护覆盖不同网络的大量IP地址。有时IP地址会超过2000个。如果要查看nnn.nnn网络地址，但是却忘了<br>第二部分中的其余部分，只知到有两个句点，例如nnn nn..。要抽取其中所有nnn.nnn IP地址，使用[0－9]{3<br>}.[0－0{3}\。含义是任意数字出现3次，后跟句点，接着是任意数字出现3次，后跟句点。<br>$grep ‘[0－9 ]{3 }.[0－0{3}\’ ipfile<br>补充说明，grep家族还包括fgrep和egrep。fgrep是fixgrep，允许查找字符串而不是一个模式；egrep是扩展grep，支持基本及扩展的正则表达式，但不支持\q模式范围的应用及与之相对应的一些更加规范的模式。<br>dd<br>1.作用<br>dd命令用来复制文件，并根据参数将数据转换和格式化。<br>2.格式<br>dd [options]<br>3.[opitions]主要参数<br>bs=字节：强迫 ibs=及obs=。<br>cbs=字节：每次转换指定的。<br>conv=关键字：根据以逗号分隔的关键字表示的方式来转换文件。<br>count=块数目：只复制指定的输入数据。<br>ibs=字节：每次读取指定的。<br>if=文件：读取内容，而非标准输入的数据。<br>obs=字节：每次写入指定的。<br>of=文件：将数据写入，而不在标准输出显示。<br>seek=块数目：先略过以obs为单位的指定的输出数据。<br>skip=块数目：先略过以ibs为单位的指定的输入数据。<br>4.应用实例<br>dd命令常常用来制作Linux启动盘。先找一个可引导内核，令它的根设备指向正确的根分区，然后使用dd命令将其写入软盘：<br>$ rdev vmlinuz /dev/hda<br>$dd if＝vmlinuz of＝/dev/fd0<br>上面代码说明，使用rdev命令将可引导内核vmlinuz中的根设备指向/dev/hda，请把“hda”换成自己的根分区，接下来用dd命令将该内核写入软盘。<br>find<br>1.作用<br>find命令的作用是在目录中搜索文件，它的使用权限是所有用户。<br>2.格式<br>find [path][options][expression]<br>path指定目录路径，系统从这里开始沿着目录树向下查找文件。它是一个路径列表，相互用空格分离，如果不写path，那么默认为当前目录。<br>3.主要参数<br>[options]参数：<br>－depth：使用深度级别的查找过程方式，在某层指定目录中优先查找文件内容。<br>－maxdepth levels：表示至多查找到开始目录的第level层子目录。level是一个非负数，如果level是0的话表示仅在当前目录中查找。<br>－mindepth levels：表示至少查找到开始目录的第level层子目录。<br>－mount：不在其它文件系统（如Msdos、Vfat等）的目录和文件中查找。<br>－version：打印版本。<br>[expression]是匹配表达式，是find命令接受的表达式，find命令的所有操作都是针对表达式的。它的参数非常多，这里只介绍一些常用的参数。<br>—name：支持统配符</em>和?。<br>－atime n：搜索在过去n天读取过的文件。<br>－ctime n：搜索在过去n天修改过的文件。<br>－group grpoupname：搜索所有组为grpoupname的文件。<br>－user 用户名：搜索所有文件属主为用户名（ID或名称）的文件。<br>－size n：搜索文件大小是n个block的文件。<br>－print：输出搜索结果，并且打印。<br>4.应用技巧<br>find命令查找文件的几种方法：<br>（1）根据文件名查找<br>例如，我们想要查找一个文件名是lilo.conf的文件，可以使用如下命令：<br>find / －name lilo.conf<br>find命令后的“/”表示搜索整个硬盘。<br>（2）快速查找文件<br>根<br>据文件名查找文件会遇到一个实际问题，就是要花费相当长的一段时间，特别是大型Linux文件系统和大容量硬盘文件放在很深的子目录中时。如果我们知道了<br>这个文件存放在某个目录中，那么只要在这个目录中往下寻找就能节省很多时间。比如smb.conf文件，从它的文件后缀“.conf”可以判断这是一个配<br>置文件，那么它应该在/etc目录内，此时可以使用下面命令：<br>find /etc －name smb.conf<br>这样，使用“快速查找文件”方式可以缩短时间。<br>（3）根据部分文件名查找方法<br>有时我们知道只某个文件包含有abvd这4个字，那么要查找系统中所有包含有这4个字符的文件可以输入下面命令：<br>find / －name ‘<em>abvd</em>‘<br>输入这个命令以后，Linux系统会将在/目录中查找所有的包含有abvd这4个字符的文件（其中<em>是通配符），比如abvdrmyz等符合条件的文件都能显示出来。<br>(4) 使用混合查找方式查找文件<br>find命令可以使用混合查找的方法，例如，我们想在/etc目录中查找大于500000字节，并且在24小时内修改的某个文件，则可以使用-and (与)把两个查找参数链接起来组合成一个混合的查找方式。<br>find /etc -size +500000c -and -mtime +1<br>mv<br>1.作用<br>mv命令用来为文件或目录改名，或者将文件由一个目录移入另一个目录中，它的使用权限是所有用户。该命令如同DOS命令中的ren和move的组合。<br>2.格式<br>mv[options] 源文件或目录 目标文件或目录<br>3.[options]主要参数<br>－i：交互方式操作。如果mv操作将导致对已存在的目标文件的覆盖，此时系统询问是否重写，要求用户回答“y”或“n”，这样可以避免误覆盖文件。<br>－f：禁止交互操作。mv操作要覆盖某个已有的目标文件时不给任何指示，指定此参数后i参数将不再起作用。<br>4.应用实例<br>（1）将/usr/cbu中的所有文件移到当前目录（用“.”表示）中：<br>$ mv /usr/cbu/ </em> .<br>（2）将文件cjh.txt重命名为wjz.txt：<br>$ mv cjh.txt wjz.txt　<br>ls<br>1.作用<br>ls命令用于显示目录内容，类似DOS下的dir命令，它的使用权限是所有用户。<br>2.格式<br>ls [options][filename]<br>3.options主要参数<br>－a, －－all：不隐藏任何以“.” 字符开始的项目。<br>－A, －－almost－all：列出除了“. ”及 “.. ”以外的任何项目。<br>－－author：印出每个文件著作者。<br>－b, －－escape：以八进制溢出序列表示不可打印的字符。<br>－－block－size=大小：块以指定的字节为单位。<br>－B, －－ignore－backups：不列出任何以 ~ 字符结束的项目。<br>－f：不进行排序，－aU参数生效，－lst参数失效。<br>－F, －－classify：加上文件类型的指示符号 (<em>/=@| 其中一个)。<br>－g：like －l, but do not listowner。<br>－G, －－no－group：inhibit display ofgroup information。<br>－i, －－inode：列出每个文件的inode号。<br>－I, －－ignore=样式：不印出任何符合Shell万用字符的项目。<br>－k：即－－block－size=1K。<br>－l：使用较长格式列出信息。<br>－L, －－dereference：当显示符号链接的文件信息时，显示符号链接所指示的对象，而并非符号链接本身的信息。<br>－m：所有项目以逗号分隔，并填满整行行宽。<br>－n, －－numeric－uid－gid：类似－l，但列出UID及GID号。<br>－N, －－literal：列出未经处理的项目名称，例如不特别处理控制字符。<br>－p, －－file－type：加上文件类型的指示符号 (/=@| 其中一个)。<br>－Q, －－quote－name：将项目名称括上双引号。<br>－r, －－reverse：依相反次序排列。<br>－R, －－recursive：同时列出所有子目录层。<br>－s, －－size：以块大小为序。<br>4.应用举例<br>ls<br>命令是Linux系统使用频率最多的命令，它的参数也是Linux命令中最多的。使用ls命令时会有几种不同的颜色，其中蓝色表示是目录，绿色表示是可执<br>行文件，红色表示是压缩文件，浅蓝色表示是链接文件，加粗的黑色表示符号链接，灰色表示是其它格式文件。ls最常使用的是ls- l，见图1所示。<br>图1 使用ls-l命令<br>文<br>件类型开头是由10个字符构成的字符串。其中第一个字符表示文件类型，它可以是下述类型之一：－（普通文件）、d（目录）、l（符号链接）、b（块设备文<br>件）、c（字符设备文件）。后面的9个字符表示文件的访问权限，分为3组，每组3位。第一组表示文件属主的权限，第二组表示同组用户的权限，第三组表示其<br>他用户的权限。每一组的三个字符分别表示对文件的读（r）、写（w）和执行权限（x）。对于目录，表示进入权限。s表示当文件被执行时，把该文件的UID<br>或GID赋予执行进程的UID（用户ID）或GID（组<br>ID）。t表示设置标志位（留在内存，不被换出）。如果该文件是目录，那么在该目录中的文件只能被超级用户、目录拥有者或文件属主删除。如果它是可执行文<br>件，那么在该文件执行后，指向其正文段的指针仍留在内存。这样再次执行它时，系统就能更快地装入该文件。接着显示的是文件大小、生成时间、文件或命令名<br>称。<br>diff<br>1.作用<br>diff命令用于两个文件之间的比较，并指出两者的不同，它的使用权限是所有用户。<br>2.格式<br>diff [options] 源文件 目标文件<br>3.[options]主要参数<br>-a：将所有文件当作文本文件来处理。<br>-b：忽略空格造成的不同。<br>-B：忽略空行造成的不同。<br>-c：使用纲要输出格式。<br>-H：利用试探法加速对大文件的搜索。<br>-I：忽略大小写的变化。<br>-n –rcs：输出RCS格式。<br>cmp<br>1.作用<br>cmp（“compare”的缩写）命令用来简要指出两个文件是否存在差异，它的使用权限是所有用户。<br>2.格式<br>cmp[options] 文件名<br>3.[options]主要参数<br>-l: 将字节以十进制的方式输出，并方便将两个文件中不同的以八进制的方式输出。<br>cat<br>1.作用<br>cat（“concatenate”的缩写）命令用于连接并显示指定的一个和多个文件的有关信息，它的使用权限是所有用户。<br>2.格式<br>cat [options] 文件1 文件2……<br>3.[options]主要参数<br>－n：由第一行开始对所有输出的行数编号。<br>－b：和－n相似，只不过对于空白行不编号。<br>－s：当遇到有连续两行以上的空白行时，就代换为一行的空白行。<br>4.应用举例<br>（1）cat命令一个最简单的用处是显示文本文件的内容。例如，我们想在命令行看一下README文件的内容，可以使用命令：<br>$ cat README　<br>（2）<br>有时需要将几个文件处理成一个文件，并将这种处理的结果保存到一个单独的输出文件。cat命令在其输入上接受一个或多个文件，并将它们作为一个单独的文件<br>打印到它的输出。例如，把README和INSTALL的文件内容加上行号（空白行不加）之后，将内容附加到一个新文本文件File1 中：<br>$ cat README INSTALL File1<br>（3）cat还有一个重要的功能就是可以对行进行编号，见图2所示。这种功能对于程序文档的编制，以及法律和科学文档的编制很方便，打印在左边的行号使得参考文档的某一部分变得容易，这些在编程、科学研究、业务报告甚至是立法工作中都是非常重要的。<br>图2 使用cat命令/etc/named.conf文件进行编号<br>对行进行编号功能有-b（只能对非空白行进行编号）和-n（可以对所有行进行编号）两个参数：<br>$ cat -b /etc/named.conf<br>ln<br>1.作用<br>ln命令用来在文件之间创建链接，它的使用权限是所有用户。<br>2.格式<br>ln [options] 源文件 [链接名]<br>3.参数<br>－f：链结时先将源文件删除。<br>－d：允许系统管理者硬链结自己的目录。<br>－s：进行软链结(Symbolic Link)。<br>－b：将在链结时会被覆盖或删除的文件进行备份。<br>链接有两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（SymbolicLink）。默认情况下，ln命令产生硬链接。<br>硬<br>连接指通过索引节点来进行的连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode<br>Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户<br>就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和<br>其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件才会被真正删除。<br>与硬连接相对应，Lnux系统中还存在另一种连接，称为符号连接（SymbilcLink），也叫软连接。软链接文件有点类似于Windows的快捷方式。它实际上是特殊文件的一种。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。<br>动手练习<br>上面我们介绍了Linux文件处理命令，下面介绍几个实例，大家可以动手练习一下刚才讲过的命令。<br>1.利用符号链接快速访问关键目录<br>符<br>号链接是一个非常实用的功能。假设有一些目录或文件需要频繁使用，但由于Linux的文件和目录结构等原因，这个文件或目录在很深的子目录中。比如，<br>Apache<br>Web服务器文档位于系统的/usr/local/httpd/htdocs中，并且不想每次都要从主目录进入这样一个长的路径之中(实际上，这个路径也<br>非常不容易记忆)。<br>为了解决这个问题，可以在主目录中创建一个符号链接，这样在需要进入该目录时，只需进入这个链接即可。<br>为了能方便地进入Web服务器(/usr/local/httpd/htdocs)文档所在的目录，在主目录下可以使用以下命令：<br>$ ln -s /usr/local/httpd/htdocs gg<br>这样每次进入gg目录就可访问Web服务器的文档，以后如果不再访问Web服务器的文档时，删除gg即可，而真正的Web服务器的文档并没有删除。<br>2.使用dd命令将init.rd格式的root.ram内容导入内存<br>dd if=/dev/fd0 of=floppy.fd<br>dd if=root.ram of=/dev/ram0 #<br>3.grep命令系统调用<br>grep是Linux/Unix中使用最广泛的命令之一，许多Linux系统内部都可以调用它。<br>(1)如果要查询目录列表中的目录，方法如下：<br>$ ls -l | grep ‘∧d’<br>(2)如果在一个目录中查询不包含目录的所有文件，方法如下：<br>$ ls -l | grep ‘∧[∧d]’<br>(3)用find命令调用grep，如所有C源代码中的“Chinput”，方法如下：<br>$find /ZhXwin -name </em>.c -exec grep -q -s Chinput {} \;-print<br>Linux必学的60个命令(3)-系统管理命令<br>Linux必学的系统管理命令<br>对于Linux系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件，Linux系统管理的命令是它正常运行的核心。熟悉了Linux常用的文件处理命令以后，这一讲介绍对系统和用户进行管理的命令。<br>df<br>1.作用<br>df命令用来检查文件系统的磁盘空间占用情况，使用权限是所有用户。<br>2.格式<br>df [options]<br>3.主要参数<br>－s：对每个Names参数只给出占用的数据块总数。<br>－a：递归地显示指定目录中各文件及子目录中各文件占用的数据块数。若既不指定－s，也不指定－a，则只显示Names中的每一个目录及其中的各子目录所占的磁盘块数。<br>－k：以1024字节为单位列出磁盘空间使用情况。<br>－x：跳过在不同文件系统上的目录不予统计。<br>－l：计算所有的文件大小，对硬链接文件则计算多次。<br>－i：显示inode信息而非块使用量。<br>－h：以容易理解的格式印出文件系统大小，例如136KB、254MB、21GB。<br>－P：使用POSIX输出格式。<br>－T：显示文件系统类型。<br>4.说明<br>df命令被广泛地用来生成文件系统的使用统计数据，它能显示系统中所有的文件系统的信息，包括总容量、可用的空闲空间、目前的安装点等。<br>超<br>级权限用户使用df命令时会发现这样的情况：某个分区的容量超过了100％。这是因为Linux系统为超级用户保留了10％的空间，由其单独支配。也就是<br>说，对于超级用户而言，他所见到的硬盘容量将是110％。这样的安排对于系统管理而言是有好处的，当硬盘被使用的容量接近100％时系统管理员还可以正常<br>工作。<br>5.应用实例<br>Linux支持的文件系统非常多，包括JFS、ReiserFS、ext、ext2、ext3、ISO9660、XFS、Minx、vfat、MSDOS等。使用df-T命令查看磁盘空间时还可以得到文件系统的信息：<br>＃df －T<br>文件系统 类型 容量 已用 可用 已用% 挂载点<br>/dev/hda7 reiserfs 5.2G 1.6G 3.7G 30% /<br>/dev/hda1 vfat 2.4G 1.6G 827M 66% /windows/C<br>/dev/hda5 vfat 3.0G 1.7G 1.3G 57% /windows/D<br>/dev/hda9 vfat 3.0G 2.4G 566M 82% /windows/E<br>/dev/hda10 NTFS 3.2G 573M 2.6G 18% /windows/F<br>/dev/hda11 vfat 1.6G 1.5G 23M 99% /windows/G<br>从上面除了可以看到磁盘空间的容量、使用情况外，分区的文件系统类型、挂载点等信息也一览无遗。<br>top<br>1.作用<br>top命令用来显示执行中的程序进程，使用权限是所有用户。<br>2.格式<br>top [－] [d delay] [q] [c] [S] [s] [n]<br>3.主要参数<br>d：指定更新的间隔，以秒计算。<br>q：没有任何延迟的更新。如果使用者有超级用户，则top命令将会以最高的优先序执行。<br>c：显示进程完整的路径与名称。<br>S：累积模式，会将己完成或消失的子行程的CPU时间累积起来。<br>s：安全模式。<br>i：不显示任何闲置(Idle)或无用(Zombie)的行程。<br>n：显示更新的次数，完成后将会退出top。<br>4.说明<br>top命令是Linux系统管理的一个主要命令，通过它可以获得许多信息。这里我们结合图1来说明它给出的信息。<br>图1 top命令的显示<br>在<br>图1中，第一行表示的项目依次为当前时间、系统启动时间、当前系统登录用户数目、平均负载。第二行显示的是所有启动的进程、目前运行的、挂起<br>(Sleeping)的和无用(Zombie)的进程。第三行显示的是目前CPU的使用情况，包括系统占用的比例、用户使用比例、闲置(Idle)比例。<br>第四行显示物理内存的使用情况，包括总的可以使用的内存、已用内存、空闲内存、缓冲区占用的内存。第五行显示交换分区使用情况，包括总的交换分区、使用<br>的、空闲的和用于高速缓存的大小。第六行显示的项目最多，下面列出了详细解释。<br>PID（Process ID）：进程标示号。<br>USER：进程所有者的用户名。<br>PR：进程的优先级别。<br>NI：进程的优先级别数值。<br>VIRT：进程占用的虚拟内存值。<br>RES：进程占用的物理内存值。<br>SHR：进程使用的共享内存值。<br>S：进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值是负数。<br>%CPU：该进程占用的CPU使用率。<br>%MEM：该进程占用的物理内存和总内存的百分比。<br>TIME＋：该进程启动后占用的总的CPU时间。<br>Command：进程启动的启动命令名称，如果这一行显示不下，进程会有一个完整的命令行。<br>top命令使用过程中，还可以使用一些交互的命令来完成其它参数的功能。这些命令是通过快捷键启动的。<br>：立刻刷新。<br>P：根据CPU使用大小进行排序。<br>T：根据时间、累计时间排序。<br>q：退出top命令。<br>m：切换显示内存信息。<br>t：切换显示进程和CPU状态信息。<br>c：切换显示命令名称和完整命令行。<br>M：根据使用内存大小进行排序。<br>W：将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。<br>可以看到，top命令是一个功能十分强大的监控系统的工具，对于系统管理员而言尤其重要。但是，它的缺点是会消耗很多系统资源。<br>5.应用实例<br>使用top命令可以监视指定用户，缺省情况是监视所有用户的进程。如果想查看指定用户的情况，在终端中按“U”键，然后输入用户名，系统就会切换为指定用户的进程运行界面，见图2所示。<br>图2 使用top命令监视指定用户<br>free<br>1.作用<br>free命令用来显示内存的使用情况，使用权限是所有用户。<br>2.格式<br>free [－b|－k|－m][－o] [－s delay] [－t] [－V]<br>3.主要参数<br>－b －k －m：分别以字节（KB、MB）为单位显示内存使用情况。<br>－s delay：显示每隔多少秒数来显示一次内存使用情况。<br>－t：显示内存总和列。<br>－o：不显示缓冲区调节列。<br>4.应用实例<br>free命令是用来查看内存使用情况的主要命令。和top命令相比，它的优点是使用简单，并且只占用很少的系统资源。通过－S参数可以使用free命令不间断地监视有多少内存在使用，这样可以把它当作一个方便实时监控器。<br>＃free －b －s5<br>使用这个命令后终端会连续不断地报告内存使用情况（以字节为单位），每5秒更新一次。<br>quota<br>1.作用<br>quota命令用来显示磁盘使用情况和限制情况，使用权限超级用户。<br>2.格式<br>quota [－g][－u][－v][－p] 用户名 组名<br>3.参数<br>－g：显示用户所在组的磁盘使用限制。<br>－u：显示用户的磁盘使用限制。<br>－v：显示没有分配空间的文件系统的分配情况。<br>－p：显示简化信息。<br>4.应用实例<br>在企业应用中磁盘配额非常重要，普通用户要学会看懂自己的磁盘使用情况。要查询自己的磁盘配额可以使用下面命令（下例中用户账号是caojh)：<br>＃quota caojh<br>Disk quotas for user caojh(uid 502):<br>Filesystem blocks quota limit grace files quota limit grace<br>/dev/hda3 58 200000 400000 41 500 1000<br>以上显示ID号为502的caojh账号，文件个数设置为500～1000个，硬盘空间限制设置为200MB～400MB。一旦磁盘配额要用完时，就需要删除一些垃圾文件或向系统管理员请求追加配额。<br>at<br>1.作用<br>at命令用来在指定时刻执行指定的命令序列。<br>2.格式<br>at [－V] [－q x] [－f file] [－m]time<br>3.主要参数<br>－V：显示标准错误输出。<br>－q：许多队列输出。<br>－f：从文件中读取作业。<br>－m：执行完作业后发送电子邮件到用户。<br>time：设定作业执行的时间。time格式有严格的要求，由小时、分钟、日期和时间的偏移量组成，其中日期的格式为MM.DD.YY，MM是分钟，DD是日期，YY是指年份。偏移量的格式为时间＋偏移量，单位是minutes、hours和days。<br>4.应用实例<br>＃at －f data 15:30 +2 days<br>上面命令表示让系统在两天后的17：30执行文件data中指明的作业。<br>lp<br>1.作用<br>lp是打印文件的命令，使用权限是所有用户。<br>2.格式<br>lp [－c][－d][－m][－number][－title][-p]<br>3.主要参数<br>－c：先拷贝文件再打印。<br>－d：打印队列文件。<br>－m：打印结束后发送电子邮件到用户。<br>－number：打印份数。<br>－title：打印标题。<br>－p：设定打印的优先级别，最高为100。<br>4.应用实例<br>（1）使用lp命令打印多个文件<br>＃lp 2 3 4<br>request id is 11 (3 file(s))<br>其中2、3、4分别是文件名；“request id is 11 (3 file(s)) ”表示这是第11个打印命令，依次打印这三个文件。<br>（2）设定打印优先级别<br>＃lp lp -d LaserJet -p90 /etc/aliases<br>通过添加“-p 90”，规定了打印作业的优先级为90。它将在优先级低于90的打印作业之前打印，包括没有设置优先级的作业，缺省优先级是50<br>useradd<br>1.作用<br>useradd命令用来建立用户帐号和创建用户的起始目录，使用权限是超级用户。<br>2.格式<br>useradd [－dhome] [－s shell] [－c comment] [－m [－ktemplate]] [－finactive] [－eexpire ] [－ppasswd] [－r]name<br>3.主要参数<br>－c：加上备注文字，备注文字保存在passwd的备注栏中。　<br>－d：指定用户登入时的启始目录。<br>－D：变更预设值。<br>－e：指定账号的有效期限，缺省表示永久有效。<br>－f：指定在密码过期后多少天即关闭该账号。<br>－g：指定用户所属的群组。<br>－G：指定用户所属的附加群组。<br>－m：自动建立用户的登入目录。<br>－M：不要自动建立用户的登入目录。<br>－n：取消建立以用户名称为名的群组。<br>－r：建立系统账号。<br>－s：指定用户登入后所使用的shell。<br>－u：指定用户ID号。<br>4.说明<br>useradd可用来建立用户账号，它和adduser命令是相同的。账号建好之后，再用passwd设定账号的密码。使用useradd命令所建立的账号，实际上是保存在/etc/passwd文本文件中。<br>5.应用实例<br>建立一个新用户账户，并设置ID：<br>＃useradd caojh －u 544<br>需要说明的是，设定ID值时尽量要大于500，以免冲突。因为Linux安装后会建立一些特殊用户，一般0到499之间的值留给bin、mail这样的系统账号。<br>groupadd<br>1.作用<br>groupadd命令用于将新组加入系统。<br>2.格式<br>groupadd [－ggid] [－o]] [－r] [－f] groupname<br>3.主要参数<br>－g gid：指定组ID号。<br>－o：允许组ID号，不必惟一。<br>－r：加入组ID号，低于499系统账号。<br>－f：加入已经有的组时，发展程序退出。<br>4.应用实例<br>建立一个新组，并设置组ID加入系统：<br>＃groupadd －g 344 cjh<br>此时在/etc/passwd文件中产生一个组ID（GID）是344的项目。<br>kill<br>1.作用<br>kill命令用来中止一个进程。<br>2.格式<br>kill [ －s signal | －p ] [ －a ] pid …<br>kill －l [ signal ]<br>3.参数<br>－s：指定发送的信号。<br>－p：模拟发送信号。<br>－l：指定信号的名称列表。<br>pid：要中止进程的ID号。<br>Signal：表示信号。<br>4.说明<br>进程是Linux系统中一个非常重要的概念。Linux是一个多任务的操作系统，系统上经常同时运行着多个进程。我们不关心这些进程究竟是如何分配的，或者是内核如何管理分配时间片的，所关心的是如何去控制这些进程，让它们能够很好地为用户服务。<br>Linux<br>操作系统包括三种不同类型的进程，每种进程都有自己的特点和属性。交互进程是由一个Shell启动的进程。交互进程既可以在前台运行，也可以在后台运行。<br>批处理进程和终端没有联系，是一个进程序列。监控进程（也称系统守护进程）时Linux系统启动时启动的进程，并在后台运行。例如，httpd是著名的<br>Apache服务器的监控进程。<br>kill命令的工作原理是，向Linux系统的内核发送一个系统操作信号<br>和某个程序的进程标识号，然后系统内核就可以对进程标识号指定的进程进行操作。比如在top命令中，我们看到系统运行许多进程，有时就需要使用kill中<br>止某些进程来提高系统资源。在讲解安装和登陆命令时，曾提到系统多个虚拟控制台的作用是当一个程序出错造成系统死锁时，可以切换到其它虚拟控制台工作关闭<br>这个程序。此时使用的命令就是kill，因为kill是大多数Shell内部命令可以直接调用的。<br>5.应用实例<br>（1）强行中止（经常使用杀掉）一个进程标识号为324的进程：<br>＃kill －9 324<br>（2）解除Linux系统的死锁<br>在Linux<br>中有时会发生这样一种情况：一个程序崩溃，并且处于死锁的状态。此时一般不用重新启动计算机，只需要中止(或者说是关闭)这个有问题的程序即可。当<br>kill处于X-Window界面时，主要的程序(除了崩溃的程序之外)一般都已经正常启动了。此时打开一个终端，在那里中止有问题的程序。比如，如果<br>Mozilla浏览器程序出现了锁死的情况，可以使用kill命令来中止所有包含有Mozolla浏览器的程序。首先用top命令查处该程序的PID，然<br>后使用kill命令停止这个程序：<br>＃kill －SIGKILL XXX<br>其中，XXX是包含有Mozolla浏览器的程序的进程标识号。<br>（3）使用命令回收内存<br>我们知道内存对于系统是非常重要的，回收内存可以提高系统资源。kill命令可以及时地中止一些“越轨”的程序或很长时间没有相应的程序。例如，使用top命令发现一个无用 (Zombie) 的进程，此时可以使用下面命令：<br>＃kill －9 XXX<br>其中，XXX是无用的进程标识号。<br>然后使用下面命令：<br>＃free<br>此时会发现可用内存容量增加了。<br>（4）killall命令<br>Linux下还提供了一个killall命令，可以直接使用进程的名字而不是进程标识号，例如：<br>＃ killall -HUP inetd<br>crontab<br>1.作用<br>使用crontab命令可以修改crontab配置文件，然后该配置由cron公用程序在适当的时间执行，该命令使用权限是所有用户。<br>2.格式<br>crontab [ －u user] 文件<br>crontab [ －uuser ] { －l |－r | －e }<br>3.主要参数<br>－e：执行文字编辑器来设定时程表，内定的文字编辑器是vi。<br>－r：删除目前的时程表。<br>－l：列出目前的时程表。<br>crontab<br>文件的格式为“M H D m d<br>cmd”。其中，M代表分钟（0～59），H代表小时（0～23），D代表天（1～31），m代表月（1～12），d代表一星期内的天（0～6，0为星期<br>天）。cmd表示要运行的程序，它被送入sh执行，这个Shell只有USER、HOME、SHELL三个环境变量。<br>4.说明<br>和at命令相比，crontab命令适合完成固定周期的任务。<br>5.应用实例<br>设置一个定时、定期的系统提示：<br>[cao @www cao]#crontab －e<br>此时系统会打开一个vi编辑器。<br>如果输入以下内容：35 17 <em> </em> 5wall “Tomorrow is Saturday I will go CS”，然后存盘退出。这时在/var/spool/cron/目录下会生产一个cao的文件，内容如下：<h1 id="DO-NOT-EDIT-THIS-FILE-－edit-the-master-and-reinstall"><a href="#DO-NOT-EDIT-THIS-FILE-－edit-the-master-and-reinstall" class="headerlink" title="DO NOT EDIT THIS FILE －edit the master and reinstall."></a>DO NOT EDIT THIS FILE －edit the master and reinstall.</h1><h1 id="tmp-crontab-2707-installed-on-Thu-Jan-1-22-01-51-2004"><a href="#tmp-crontab-2707-installed-on-Thu-Jan-1-22-01-51-2004" class="headerlink" title="(/tmp/crontab.2707 installed on Thu Jan 1 22:01:51 2004)"></a>(/tmp/crontab.2707 installed on Thu Jan 1 22:01:51 2004)</h1><h1 id="Cron-version-－－-Id-crontab-c-v-2-13-1994-01-17-03-20-37-vixie-Exp"><a href="#Cron-version-－－-Id-crontab-c-v-2-13-1994-01-17-03-20-37-vixie-Exp" class="headerlink" title="(Cron version －－$Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)"></a>(Cron version －－$Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)</h1>35 17 <em> </em> 5 wall “Tomorrow is Saturday I will play CS “<br>这样每个星期五17：35系统就会弹出一个终端，提醒星期六可以打打CS了！显示结果见图3所示。<br>图3 一个定时、定期的系统提示<br>动手练习<br>1.联合使用kill和top命令观察系统性能的变化<br>首先启动一个终端运行top命令，然后再启动一个终端使用kill命令，见图4所示。<br>图4 观察kill命令对top终端的影响<br>这时利用上面介绍的kill命令来中止一些程序：<br>＃kill SIGKILL XXX<br>然后再看top命令终端的变化，包括内存容量、CPU使用率、系统负载等。注意，有些进程是不能中止的，不过学习Linux命令时可以试试，看看系统有什么反应。<br>2.使用at和halt命令定时关机<br>首先设定关机时间是17:35，输入下面代码：<br>＃at 17:35<br>warning: commands will be executed using (in order) a) $SHELL b) login shell c)/bin/sh<br>at&gt;halt `-i －p<br>at&gt;<br>job 6 at 2004－01－0117:35<br>此<br>时实际上就已经进入Linux系统的Shell，并且编写一个最简单程序：halt －i<br>－p。上面Shell中的文本结束符号表示按“Ctrl＋D”组合键关闭命令，提交任务退出Shell。“Job6 at 2004－01－01<br>17:35”表示系统接受第6个at命令，在“2004－01－0117:35”时执行命令：先把所有网络相关的装置停止，关闭系统后关闭电源。<br>3.用crontab命令实现每天定时的病毒扫描<br>前面已经介绍了一个简单的crontab命令操作，这里看一些更重要的操作。<br>（1）建立一个文件，文件名称自己设定，假设为caoproject：<br>＃crontab －e<br>（2）文件内容如下：<br>05 09 <em> </em> * antivir<br>用vi编辑后存盘退出。antivir是一个查杀Linux病毒的软件，当然需要时先安装在系统中。<br>（3）使用crontab命令添加到任务列表中：<br>＃crontab caoproject<br>这样系统内所有用户在每天的9点05分会自动进行病毒扫描。<br>4.用kill使修改的配置文件马上生效<br>Windows用户一般都知道，重要配置文件修改后往往都要重新启动计算机才能使修改生效。而Linux由于采用了模块化设计，可以自己根据需要实时设定服务。这里以网络服务inetd为例介绍一些操作技巧。<br>inetd<br>是一个监听守护进程，监听与提供互联网服务进程（如rlogin、telnet、ftp、rsh）进行连接的要求，并扩展所需的服务进程。默认情况下，<br>inetd监听的这些daemon均列于/etc<br>/inetd.conf文件中。编辑/etc/inetd.conf文件，可以改变inetd启动服务器守护进程的选项，然后驱使inetd以<br>SIGHUP（signal 1）向当前的inetd进程发送信号，使inetd重读该文件。这一过程由kill命令来实现。<br>用vi或其它编辑器修改inetd.conf后，首先使用下面命令：<br>＃ps -ef |grep inetd<br>上面代码表明查询inetd.conf的进程号(PID)，这里假设是1426，然后使用下面命令：<br>＃ kill -1426 inetd<br>这样配置文件就生效了。<br>这一讲介绍的系统管理命令都是比较重要的，特别是crontab命令和quota命令使用起来会有一定难度，需要多做一些练习。另外，使用kill命令要注意“－9“这个参数，练习时最好不要运行一些重要的程序。<br>Linux必学的60个命令(4)-网络操作命令Linux必学的60个命令：网络操作命令<br>因<br>为Linux系统是在Internet上起源和发展的，它与生俱来拥有强大的网络功能和丰富的网络应用软件，尤其是TCP/IP网络协议的实现尤为成熟。<br>Linux的网络命令比较多，其中一些命令像ping、<br>ftp、telnet、route、netstat等在其它操作系统上也能看到，但也有一些Unix/Linux系统独有的命令，如ifconfig、<br>finger、mail等。Linux网络操作命令的一个特点是，命令参数选项和功能很多，一个命令往往还可以实现其它命令的功能。<br>ifconfig<br>1.作用<br>ifconfig用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。<br>2.格式<br>ifconfig -interface [options] address<br>3.主要参数<br>-interface：指定的网络接口名，如eth0和eth1。<br>up：激活指定的网络接口卡。<br>down：关闭指定的网络接口。<br>broadcast address：设置接口的广播地址。<br>pointopoint：启用点对点方式。<br>address：设置指定接口设备的IP地址。<br>netmask address：设置接口的子网掩码。<br>4.应用说明<br>ifconfig是用来设置和配置网卡的命令行工具。为了手工配置网络，这是一个必须掌握的命令。使用该命令的好处是无须重新启动机器。要赋给eth0接口IP地址207.164.186.2，并且马上激活它，使用下面命令：<br>#fconfig eth0 210.34.6.89 netmask 255.255.255.128 broadcast 210.34.6.127<br>该<br>命令的作用是设置网卡eth0的IP地址、网络掩码和网络的本地广播地址。若运行不带任何参数的ifconfig命令，这个命令将显示机器所有激活接口的<br>信息。带有“-a”参数的命令则显示所有接口的信息，包括没有激活的接口。注意，用ifconfig命令配置的网络设备参数，机器重新启动以后将会丢失。<br>如果要暂停某个网络接口的工作，可以使用down参数：<br>#ifconfig eth0 down<br>ip<br>1.作用<br>ip是iproute2软件包里面的一个强大的网络配置工具，它能够替代一些传统的网络管理工具，例如ifconfig、route等，使用权限为超级用户。几乎所有的Linux发行版本都支持该命令。<br>2.格式<br>ip [OPTIONS] OBJECT [COMMAND [ARGUMENTS]]<br>3.主要参数<br>OPTIONS是修改ip行为或改变其输出的选项。所有的选项都是以-字符开头，分为长、短两种形式。目前，ip支持如表1所示选项。<br>OBJECT是要管理者获取信息的对象。目前ip认识的对象见表2所示。<br>表1 ip支持的选项<br>-V,-Version 打印ip的版本并退出。<br>-s,-stats,-statistics 输出更为详尽的信息。如果这个选项出现两次或多次，则输出的信息将更为详尽。<br>-f,-family 这个选项后面接协议种类，包括inet、inet6或link，强调使用的协议种类。如果没有足够的信息告诉ip使用的协议种类，ip就会使用默认值inet或any。link比较特殊，它表示不涉及任何网络协议。<br>-4 是-family inet的简写。<br>-6 是-family inet6的简写。<br>-0 是-family link的简写。<br>-o,-oneline 对每行记录都使用单行输出，回行用字符代替。如果需要使用wc、grep等工具处理ip的输出，则会用到这个选项。<br>-r,-resolve 查询域名解析系统，用获得的主机名代替主机IP地址<br>COMMAND<br>设置针对指定对象执行的操作，它和对象的类型有关。一般情况下，ip支持对象的增加(add)、删除(delete)和展示(show或list)。有些<br>对象不支持这些操作，或者有其它的一些命令。对于所有的对象，用户可以使用help命令获得帮助。这个命令会列出这个对象支持的命令和参数的语法。如果没<br>有指定对象的操作命令，ip会使用默认的命令。一般情况下，默认命令是list，如果对象不能列出，就会执行help命令。<br>ARGUMENTS<br>是命令的一些参数，它们倚赖于对象和命令。ip支持两种类型的参数：flag和parameter。flag由一个关键词组成；parameter由一个<br>关键词加一个数值组成。为了方便，每个命令都有一个可以忽略的默认参数。例如，参数dev是iplink命令的默认参数，因此ip link ls<br>eth0等于ip link ls dev eth0。我们将在后面的详细介绍每个命令的使用，命令的默认参数将使用default标出。<br>4.应用实例<br>添加IP地址192.168.2.2/24到eth0网卡上：<br>#ip addr add 192.168.1.1/24 dev eth0<br>丢弃源地址属于192.168.2.0/24网络的所有数据报：<br>#ip rule add from 192.168.2.0/24 prio 32777 reject<br>ping<br>1.作用<br>ping检测主机网络接口状态，使用权限是所有用户。<br>2.格式<br>ping [-dfnqrRv][-c][-i][-I][-l][-p][-s][-t] IP地址<br>3.主要参数<br>-d：使用Socket的SO_DEBUG功能。<br>-c：设置完成要求回应的次数。<br>-f：极限检测。<br>-i：指定收发信息的间隔秒数。<br>-I：网络界面使用指定的网络界面送出数据包。<br>-l：前置载入，设置在送出要求信息之前，先行发出的数据包。<br>-n：只输出数值。<br>-p：设置填满数据包的范本样式。<br>-q：不显示指令执行过程，开头和结尾的相关信息除外。<br>-r：忽略普通的Routing Table，直接将数据包送到远端主机上。<br>-R：记录路由过程。<br>-s：设置数据包的大小。<br>-t：设置存活数值TTL的大小。<br>-v：详细显示指令的执行过程。<br>ping<br>命令是使用最多的网络指令，通常我们使用它检测网络是否连通，它使用ICMP协议。但是有时会有这样的情况，我们可以浏览器查看一个网页，但是却无法<br>ping通，这是因为一些网站处于安全考虑安装了防火墙。另外，也可以在自己计算机上试一试，通过下面的方法使系统对ping没有反应：<h1 id="echo-1-gt-proc-sys-net-ipv4-icmp-echo-ignore-all"><a href="#echo-1-gt-proc-sys-net-ipv4-icmp-echo-ignore-all" class="headerlink" title="echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all"></a>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</h1>netstat<br>1.作用<br>检查整个Linux网络状态。<br>2.格式<br>netstat [-acCeFghilMnNoprstuvVwx][-A][–ip]<br>3.主要参数<br>-a–all：显示所有连线中的Socket。<br>-A：列出该网络类型连线中的IP相关地址和网络类型。<br>-c–continuous：持续列出网络状态。<br>-C–cache：显示路由器配置的快取信息。<br>-e–extend：显示网络其它相关信息。<br>-F–fib：显示FIB。<br>-g–groups：显示多重广播功能群组组员名单。<br>-h–help：在线帮助。<br>-i–interfaces：显示网络界面信息表单。<br>-l–listening：显示监控中的服务器的Socket。<br>-M–masquerade：显示伪装的网络连线。<br>-n–numeric：直接使用IP地址，而不通过域名服务器。<br>-N–netlink–symbolic：显示网络硬件外围设备的符号连接名称。<br>-o–timers：显示计时器。<br>-p–programs：显示正在使用Socket的程序识别码和程序名称。<br>-r–route：显示RoutingTable。<br>-s–statistice：显示网络工作信息统计表。<br>-t–tcp：显示TCP传输协议的连线状况。<br>-u–udp：显示UDP传输协议的连线状况。<br>-v–verbose：显示指令执行过程。<br>-V–version：显示版本信息。<br>-w–raw：显示RAW传输协议的连线状况。<br>-x–unix：和指定“-Aunix”参数相同。<br>–ip–inet：和指定“-Ainet”参数相同。<br>4.应用实例<br>netstat<br>主要用于Linux察看自身的网络状况，如开启的端口、在为哪些用户服务，以及服务的状态等。此外，它还显示系统路由表、网络接口状态等。可以说，它是一<br>个综合性的网络状态的察看工具。在默认情况下，netstat只显示已建立连接的端口。如果要显示处于监听状态的所有端口，使用-a参数即可：<br>#netstat -a<br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address Foreign Address State<br>tcp 0 0 <em>:32768 </em>:<em> LISTEN<br>tcp 0 0 </em>:32769 <em>:</em> LISTEN<br>tcp 0 0 <em>:nfs </em>:<em> LISTEN<br>tcp 0 0 </em>:32770 <em>:</em> LISTEN<br>tcp 0 0 <em>:868 </em>:<em> LISTEN<br>tcp 0 0 </em>:617 <em>:</em> LISTEN<br>tcp 0 0 <em>:MySQL </em>:<em> LISTEN<br>tcp 0 0 </em>:netbios-ssn <em>:</em> LISTEN<br>tcp 0 0 <em>:sunrpc </em>:<em> LISTEN<br>tcp 0 0 </em>:10000 <em>:</em> LISTEN<br>tcp 0 0 <em>:http </em>:<em> LISTEN<br>……<br>上面显示出，这台主机同时提供HTTP、FTP、NFS、MySQL等服务。<br>telnet<br>1.作用<br>telnet表示开启终端机阶段作业，并登入远端主机。telnet是一个Linux命令，同时也是一个协议（远程登陆协议）。<br>2.格式<br>telnet [-8acdEfFKLrx][-b][-e][-k][-l][-n][-S][-X][主机名称IP地址]<br>3.主要参数<br>-8：允许使用8位字符资料，包括输入与输出。<br>-a：尝试自动登入远端系统。<br>-b：使用别名指定远端主机名称。<br>-c：不读取用户专属目录里的.telnetrc文件。<br>-d：启动排错模式。<br>-e：设置脱离字符。<br>-E：滤除脱离字符。<br>-f：此参数的效果和指定“-F”参数相同。<br>-F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。<br>-k：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。<br>-K：不自动登入远端主机。<br>-l：指定要登入远端主机的用户名称。<br>-L：允许输出8位字符资料。<br>-n：指定文件记录相关信息。<br>-r：使用类似rlogin指令的用户界面。<br>-S：服务类型，设置telnet连线所需的IP TOS信息。<br>-x：假设主机有支持数据加密的功能，就使用它。<br>-X：关闭指定的认证形态。<br>4.应用说明<br>用<br>户使用telnet命令可以进行远程登录，并在远程计算机之间进行通信。用户通过网络在远程计算机上登录，就像登录到本地机上执行命令一样。为了通过<br>telnet登录到远程计算机上，必须知道远程机上的合法用户名和口令。虽然有些系统确实为远程用户提供登录功能，但出于对安全的考虑，要限制来宾的操作<br>权限，因此，这种情况下能使用的功能是很少的。<br>telnet只为普通终端提供终端仿真，而不支持X-<br>Window等图形环境。当允许远程用户登录时，系统通常把这些用户放在一个受限制的Shell中，以防系统被怀有恶意的或不小心的用户破坏。用户还可以<br>使用telnet从远程站点登录到自己的计算机上，检查电子邮件、编辑文件和运行程序，就像在本地登录一样。<br>ftp<br>1.作用<br>ftp命令进行远程文件传输。FTP是ARPANet的标准文件传输协议，该网络就是现今Internet的前身，所以ftp既是协议又是一个命令。<br>2.格式<br>ftp [-dignv][主机名称IP地址]<br>3.主要参数<br>-d：详细显示指令执行过程，便于排错分析程序执行的情形。<br>-i：关闭互动模式，不询问任何问题。<br>-g：关闭本地主机文件名称支持特殊字符的扩充特性。<br>-n：不使用自动登陆。<br>-v：显示指令执行过程。<br>4.应用说明<br>ftp<br>命令是标准的文件传输协议的用户接口，是在TCP/IP网络计算机之间传输文件简单有效的方法，它允许用户传输ASCⅡ文件和二进制文件。为了使用ftp<br>来传输文件，用户必须知道远程计算机上的合法用户名和口令。这个用户名/口令的组合用来确认ftp会话，并用来确定用户对要传输的文件进行什么样的访问。<br>另外，用户需要知道对其进行ftp会话的计算机名字的IP地址。<br>用户可以通过使用ftp客户程序，连接到另一台计算机上；可以在目录中上下移动、列出目录内容；可以把文件从远程计算机机拷贝到本地机上；还可以把文件从本地机传输到远程系统中。ftp内部命令有72个，下面列出主要几个内部命令：<br>ls：列出远程机的当前目录。<br>cd：在远程机上改变工作目录。<br>lcd：在本地机上改变工作目录。<br>close：终止当前的ftp会话。<br>hash：每次传输完数据缓冲区中的数据后就显示一个#号。<br>get（mget）：从远程机传送指定文件到本地机。<br>put（mput）：从本地机传送指定文件到远程机。<br>quit：断开与远程机的连接，并退出ftp。<br>route<br>1.作用<br>route表示手工产生、修改和查看路由表。<br>2.格式<br>#route [-add][-net|-host] targetaddress [-netmask Nm][dev]If]<br>#route [－delete][-net|-host]targetaddress [gw Gw] [-netmask Nm] [dev]If]<br>3.主要参数<br>-add：增加路由。<br>-delete：删除路由。<br>-net：路由到达的是一个网络，而不是一台主机。<br>-host：路由到达的是一台主机。<br>-netmask Nm：指定路由的子网掩码。<br>gw：指定路由的网关。<br>[dev]If：强迫路由链指定接口。<br>4.应用实例<br>route命令是用来查看和设置Linux系统的路由信息，以实现与其它网络的通信。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。<br>在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。使用下面命令可以增加一个默认路由：<br>route add 0.0.0.0 192.168.1.1<br>rlogin<br>1.作用<br>rlogin用来进行远程注册。<br>2.格式<br>rlogin [ -8EKLdx ] [ -e char ] [-k realm ] [ - l username ] host<br>3.主要参数<br>-8：此选项始终允许8位输入数据通道。该选项允许发送格式化的ANSI字符和其它的特殊代码。如果不用这个选项，除非远端的不是终止和启动字符，否则就去掉奇偶校验位。<br>-E：停止把任何字符当作转义字符。当和-8选项一起使用时，它提供一个完全的透明连接。<br>-K：关闭所有的Kerberos确认。只有与使用Kerberos 确认协议的主机连接时才使用这个选项。<br>-L：允许rlogin会话在litout模式中运行。要了解更多信息，请查阅tty联机帮助。<br>-d：打开与远程主机进行通信的TCPsockets的socket调试。要了解更多信息，请查阅setsockopt的联机帮助。<br>-e：为rlogin会话设置转义字符，默认的转义字符是“～”。<br>-k：请求rlogin获得在指定区域内远程主机的Kerberos许可，而不是获得由krb_realmofhost(3)确定的远程主机区域内的远程主机的Kerberos许可。<br>-x：为所有通过rlogin会话传送的数据打开DES加密。这会影响响应时间和CPU利用率，但是可以提高安全性。<br>4.使用说明<br>如果在网络中的不同系统上都有账号，或者可以访问别人在另一个系统上的账号，那么要访问别的系统中的账号，首先就要注册到系统中，接着通过网络远程注册到账号所在的系统中。rlogin可以远程注册到别的系统中，它的参数应是一个系统名。<br>rcp<br>1.作用<br>rcp代表远程文件拷贝，用于计算机之间文件拷贝，使用权限是所有用户。<br>2.格式<br>rcp [-px] [-k realm] file1 file2 rcp [-px] [-r] [-k realm] file<br>3.主要参数<br>-r：递归地把源目录中的所有内容拷贝到目的目录中。要使用这个选项，目的必须是一个目录。<br>-p：试图保留源文件的修改时间和模式，忽略umask。<br>-k：请求rcp获得在指定区域内的远程主机的Kerberos许可，而不是获得由krb_relmofhost(3)确定的远程主机区域内的远程主机的Kerberos许可。<br>-x：为传送的所有数据打开DES加密。<br>finger<br>1.作用<br>finger用来查询一台主机上的登录账号的信息，通常会显示用户名、主目录、停滞时间、登录时间、登录Shell等信息，使用权限为所有用户。<br>2.格式<br>finger [选项][使用者] [用户@主机]<br>3.主要参数<br>-s：显示用户注册名、实际姓名、终端名称、写状态、停滞时间、登录时间等信息。<br>-l：除了用-s选项显示的信息外，还显示用户主目录、登录Shell、邮件状态等信息，以及用户主目录下的.plan、.project和.forward文件的内容。<br>-p：除了不显示.plan文件和.project文件以外，与-l选项相同。<br>4.应用实例<br>在计算机上使用finger：<br>[root@localhost root]# Finger<br>Login Name Tty Idle Login Time Office Office Phone<br>root root tty1 2 Dec 15 11<br>root root pts/0 1 Dec 15 11<br>root root </em>pts/1 Dec 15 11<br>5.应用说明<br>如果要查询远程机上的用户信息，需要在用户名后面接“@主机名”，采用[用户名@主机名]的格式，不过要查询的网络主机需要运行finger守护进程的支持。<br>mail<br>1.作用<br>mail作用是发送电子邮件，使用权限是所有用户。此外，mail还是一个电子邮件程序。<br>2.格式<br>mail [-s subject] [-c address] [-b address]<br>mail -f [mailbox]mail [-u user]<br>3.主要参数<br>-b address：表示输出信息的匿名收信人地址清单。<br>-c address：表示输出信息的抄送（）收信人地址清单。<br>-f [mailbox]：从收件箱者指定邮箱读取邮件。<br>-s subject：指定输出信息的主体行。<br>[-u user]：端口指定优化的收件箱读取邮件。<br>nslookup<br>1.作用<br>nslookup命令的功能是查询一台机器的IP地址和其对应的域名。使用权限所有用户。它通常需要一台域名服务器来提供域名服务。如果用户已经设置好域名服务器，就可以用这个命令查看不同主机的IP地址对应的域名。<br>2.格式<br>nslookup ［IP地址/域名］<br>3.应用实例<br>（1）在本地计算机上使用nslookup命令<br>$ nslookup<br>Default Server: name.cao.com.cn<br>Address: 192.168.1.9<br>&gt;<br>在符号“&gt;”后面输入要查询的IP地址域名，并回车即可。如果要退出该命令，输入“exit”，并回车即可。<br>（2）使用nslookup命令测试named<br>输入下面命令：<br>nslookup<br>然后就进入交换式nslookup环境。如果named正常启动，则nslookup会显示当前DNS服务器的地址和域名，否则表示named没能正常启动。<br>下面简单介绍一些基本的DNS诊断。<br>◆<br>检查正向DNS解析，在nslookup提示符下输入带域名的主机名，如hp712.my.com，nslookup应能显示该主机名对应的IP地址。如<br>果只输入hp712，nslookup会根据/etc/resolv.conf的定义，自动添加my.com域名，并回答对应的IP地址。<br>◆检查反向DNS解析，在nslookup提示符下输入某个IP地址，如192.22.33.20，nslookup应能回答该IP地址所对应的主机名。<br>◆检查MX邮件地址记录在nslookup提示符下输入：<br>set q=mx<br>然后输入某个域名，输入my.com和mail.my.com，nslookup应能够回答对应的邮件服务器地址，即support.my.com和support2.my.com。<br>动手练习<br>1.危险的网络命令<br>互<br>联网的发展使安全成为一个不能忽视的问题，finger、ftp、rcp和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，嗅<br>探器可以非常容易地截获这些口令和数据。而且，这些服务程序的安全验证方式也是有弱点的，很容易受到“中间服务器”方式的攻击。这里笔者把一些不安全的命<br>令根据危险等级列出，见表3所示。<br>现在ftp、telnet可以被SSH命令代替绑定在端口22上，其连<br>接采用协商方式，使用RSA加密。身份鉴别完成之后，后面的所有流量都使用IDEA<br>进行加密。SSH（Secure　Shell）程序可以通过网络登录到远程主机，并执行命令。rcp、rlogin等远程调用命令也逐渐被VNC软件代<br>替。<br>2.在一张网卡上绑定多个IP地址<br>在Linux下，可以使用ifconfig方便地绑定多个IP地址到一张网卡。例如，eth0接口的原有IP地址为192.168.0 .254，可以执行下面命令：<br>ifconfig eth0:0 192.168.0.253 netmask 255.255.255.0<br>ifconfig eth0:1 192.168.0.252 netmask 255.255.255.0<br>……<br>3.修改网卡MAC地址<br>首先必须关闭网卡设备，命令如下：<br>/sbin/ifconfig eth0 down<br>修改MAC地址，命令如下：<br>/sbin/ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE<br>重新启用网卡：<br>/sbin/ifconfig eht0 up<br>这样网卡的MAC地址就更改完成了。每张网卡的MAC地址是惟一，但不是不能修改的，只要保证在网络中的MAC地址的惟一性就可以了。<br>4.初步部署IPv6<br>IPv4<br>技术在网络发展中起到了巨大的作用，不过随着时间的流逝它无论在网络地址的提供、服务质量、安全性等方面都越来越力不从心，IPv6呼之欲出。Linux<br>是所有操作系统中最先支持IPv6的，一般Linux基于2.4内核的Linux发行版本都可以直接使用IPv6，不过主要发行版本没有加载IPv6模<br>块，可以使用命令手工加载，需要超级用户的权限。<br>(1)加载IPv6模块<br>使用命令检测，其中inet6 addr:fe80::5054:abff:fe34:5b09/64，就是eth0网卡的IPv6地址。<h1 id="modprobe-IPv6"><a href="#modprobe-IPv6" class="headerlink" title="modprobe IPv6"></a>modprobe IPv6</h1>＃ifconfig<br>eth0 Link encap:Ethernet HWaddr 52:54:AB:34:5B:09<br>inet addr:192.168.1.2 Bcast:192.168.1.255 Mask:255.255.255.0<br>inet6 addr: fe80::5054:abff:fe34:5b09/64 Scope:Link<br>UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1<br>RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br>TX packets:21 errors:0 dropped:0 overruns:0 carrier:0<br>collisions:0 txqueuelen:100<br>RX bytes:0 (0.0 b) TX bytes:1360 (1.3 Kb)<br>Interrupt:5 Base address:0xec00<br>(2)使用ping命令检测网卡的IPv6地址是否有效<br>#ping6 -I eth0 -c 2 fe80::200:e8ff:fea0:2586<br>和IPv4不一样，使用ping6命令时必须指定一个网卡界面，否则系统不知道将数据包发送到哪个网络设备。I表示Interface、eth0是第一个网卡，－c表示回路，2表示ping6操作两次。结果见图1所示。<br>图1 IPv6网络下的ping6命令<br>(3)使用ip命令在IPv6下为eth0增加一个IP地址<br>#ip -6 addr add 3ffe:ffff:0:f101::1/64 dev eth0<br>使用ifconfig命令，查看网卡是否出现第二个IPv6地址。<br>Linux网络的主要优点是能够实现资源和信息的共享，并且用户可以远程访问信息。Linux提供了一组强有力的网络命令来为用户服务，这些工具能够帮助用户进行网络设定、检查网络状况、登录到远程计算机上、传输文件和执行远程命令等。<br>上面介绍了Linux中比较重要的网络命令，其实Linux还有许多命令需要学习。Linux网络操作命令的一个特点就是命令参数选项很多，并不要求全部记住，关键在于理解命令的主要用途和学会使用帮助信息。<br>Linux必学的60个命令(5)-网络安全命令Linux必学的60个命令：系统安全相关命令<br>虽然Linux和Windows NT/2000系统一样是一个多用户的系统，但是它们之间有不少重要的差别。对于很多习惯了Windows系统的管理员来讲，如何保证Linux操作系统安全、可靠将会面临许多新的挑战。本文将重点介绍Linux系统安全的命令。<br>passwd<br>1.作用<br>passwd命令原来修改账户的登陆密码，使用权限是所有用户。<br>2.格式<br>passwd [选项] 账户名称<br>3.主要参数<br>-l：锁定已经命名的账户名称，只有具备超级用户权限的使用者方可使用。<br>-u：解开账户锁定状态，只有具备超级用户权限的使用者方可使用。<br>-x, –maximum=DAYS：最大密码使用时间（天），只有具备超级用户权限的使用者方可使用。<br>-n, –minimum=DAYS：最小密码使用时间（天），只有具备超级用户权限的使用者方可使用。<br>-d：删除使用者的密码, 只有具备超级用户权限的使用者方可使用。<br>-S：检查指定使用者的密码认证种类, 只有具备超级用户权限的使用者方可使用。<br>4.应用实例<br>$ passwd<br>Changing password for user cao.<br>Changing password for cao<br>(current) UNIX password:<br>New UNIX password:<br>Retype new UNIX password:<br>passwd: all authentication tokens updated successfully.<br>从上面可以看到，使用passwd命令需要输入旧的密码，然后再输入两次新密码。<br>su<br>1.作用<br>su的作用是变更为其它使用者的身份，超级用户除外，需要键入该使用者的密码。<br>2.格式<br>su [选项]… [-] [USER[ARG]…]<br>3.主要参数<br>-f ， –fast：不必读启动文件（如 csh.cshrc 等），仅用于csh或tcsh两种Shell。<br>-l ， –login：加了这个参数之后，就好像是重新登陆为该使用者一样，大部分环境变量（例如HOME、SHELL和USER等）都是以该使用者（USER）为主，并且工作目录也会改变。如果没有指定USER，缺省情况是root。<br>-m， -p ，–preserve-environment：执行su时不改变环境变数。<br>-c command：变更账号为USER的使用者，并执行指令（command）后再变回原来使用者。<br>USER：欲变更的使用者账号，ARG传入新的Shell参数。<br>4.应用实例<br>变更账号为超级用户，并在执行df命令后还原使用者。 su -c df root<br>umask<br>1.作用<br>umask设置用户文件和目录的文件创建缺省屏蔽值，若将此命令放入profile文件，就可控制该用户后续所建文件的存取许可。它告诉系统在创建文件时不给谁存取许可。使用权限是所有用户。<br>2.格式<br>umask [-p] [-S] [mode]<br>3.参数<br>－S：确定当前的umask设置。<br>－p：修改umask 设置。<br>[mode]：修改数值。<br>4.说明<br>传<br>统Unix的umask值是022，这样就可以防止同属于该组的其它用户及别的组的用户修改该用户的文件。既然每个用户都拥有并属于一个自己的私有组，那<br>么这种“组保护模式”就不在需要了。严密的权限设定构成了Linux安全的基础，在权限上犯错误是致命的。需要注意的是，umask命令用来设置进程所创<br>建的文件的读写权限，最保险的值是0077，即关闭创建文件的进程以外的所有进程的读写权限，表示为-rw——-。在<br>～/.bash_profile中，加上一行命令umask 0077可以保证每次启动Shell后, 进程的umask权限都可以被正确设定。<br>5.应用实例<br>umask -S<br>u=rwx,g=rx,o=rx<br>umask -p 177<br>umask -S<br>u=rw,g=,o=<br>上述5行命令，首先显示当前状态，然后把umask值改为177，结果只有文件所有者具有读写文件的权限，其它用户不能访问该文件。这显然是一种非常安全的设置。<br>chgrp<br>1.作用<br>chgrp表示修改一个或多个文件或目录所属的组。使用权限是超级用户。<br>2.格式<br>chgrp [选项]… 组 文件…<br>或<br>chgrp [选项]… –reference=参考文件 文件…<br>将每个的所属组设定为。<br>3.参数<br>-c, –changes ：像–verbose，但只在有更改时才显示结果。<br>–dereference：会影响符号链接所指示的对象，而非符号链接本身。<br>-h, –no-dereference：会影响符号链接本身，而非符号链接所指示的目的地(当系统支持更改符号链接的所有者，此选项才有效)。<br>-f, –silent, –quiet：去除大部分的错误信息。<br>–reference=参考文件：使用的所属组，而非指定的。<br>-R, –recursive：递归处理所有的文件及子目录。<br>-v, –verbose：处理任何文件都会显示信息。<br>4.应用说明<br>该命令改变指定指定文件所属的用户组。其中group可以是用户组ID，也可以是/etc/group文件中用户组的组名。文件名是以空格分开的要改变属组的文件列表，支持通配符。如果用户不是该文件的属主或超级用户，则不能改变该文件的组。<br>5.应用实例<br>改变/opt/local /book/及其子目录下的所有文件的属组为book，命令如下：<br>$ chgrp - R book /opt/local /book<br>chmod<br>1.作用<br>chmod命令是非常重要的，用于改变文件或目录的访问权限，用户可以用它控制文件或目录的访问权限，使用权限是超级用户。<br>2.格式<br>chmod命令有两种用法。一种是包含字母和操作符表达式的字符设定法（相对权限设定）；另一种是包含数字的数字设定法（绝对权限设定）。<br>（1）字符设定法<br>chmod [who] [+ | - | =] [mode] 文件名<br>◆操作对象who可以是下述字母中的任一个或它们的组合<br>u：表示用户，即文件或目录的所有者。<br>g：表示同组用户，即与文件属主有相同组ID的所有用户。<br>o：表示其它用户。<br>a：表示所有用户，它是系统默认值。<br>◆操作符号<br>+：添加某个权限。<br>-：取消某个权限。<br>=：赋予给定权限，并取消其它所有权限（如果有的话）。<br>◆设置mode的权限可用下述字母的任意组合<br>r：可读。<br>w：可写。<br>x：可执行。<br>X：只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x属性。<br>s：文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。<br>t：保存程序的文本到交换设备上。<br>u：与文件属主拥有一样的权限。<br>g：与和文件属主同组的用户拥有一样的权限。<br>o：与其它用户拥有一样的权限。<br>文件名：以空格分开的要改变权限的文件列表，支持通配符。<br>一个命令行中可以给出多个权限方式，其间用逗号隔开。<br>（2） 数字设定法<br>数字设定法的一般形式为： chmod [mode]文件名<br>数字属性的格式应为3个0到7的八进制数，其顺序是(u)(g)(o)文件名，以空格分开的要改变权限的文件列表，支持通配符。<br>数<br>字表示的权限的含义如下：0001为所有者的执行权限；0002为所有者的写权限；0004为所有者的读权限；0010为组的执行权限；0020为组的写<br>权限；0040为组的读权限；0100为其他人的执行权限；0200为其他人的写权限；0400为其他人的读权限；1000为粘贴位置位；2000表示假<br>如这个文件是可执行文件，则为组ID为位置位，否则其中文件锁定位置位；4000表示假如这个文件是可执行文件，则为用户ID为位置位。<br>3.实例<br>如果一个系统管理员写了一个表格(tem)让所有用户填写，那么必须授权用户对这个文件有读写权限，可以使用命令：＃chmod 666 tem<br>上<br>面代码中，这个666数字是如何计算出来的呢？0002为所有者的写权限，0004为所有者的读权限，0020为组的写权限，0040为组的读权限，<br>0200为其他人的写权限，0400为其他人的读权限，这6个数字相加就是666（注以上数字都是八进制数），结果见图1所示。<br>图1 用chmod数字方法设定文件权限<br>从图1可以看出，tem文件的权限是-rw-rw-rw-，即用户对这个文件有读写权限。<br>如果用字符权限设定使用下面命令：<br>＃chmod a =wx tem<br>chown<br>1.作用<br>更改一个或多个文件或目录的属主和属组。使用权限是超级用户。<br>2.格式<br>chown [选项] 用户或组 文件<br>3.主要参数<br>–dereference：受影响的是符号链接所指示的对象，而非符号链接本身。<br>-h, –no-dereference：会影响符号链接本身，而非符号链接所指示的目的地(当系统支持更改符号链接的所有者，此选项才有效)。<br>–from=目前所有者:目前组只当每个文件的所有者和组符合选项所指定的，才会更改所有者和组。其中一个可以省略，这已省略的属性就不需要符合原有的属性。<br>-f, –silent, –quiet：去除大部分的错误信息。<br>-R, –recursive：递归处理所有的文件及子目录。<br>-v, –verbose：处理任何文件都会显示信息。<br>4.说明<br>chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或用户ID；组可以是组名或组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将文件拷贝到另一个用户的目录下以后，让用户拥有使用该文件的权限。<br>5.应用实例<br>1.把文件shiyan.c的所有者改为wan<br>$ chown wan shiyan.c<br>2.把目录/hi及其下的所有文件和子目录的属主改成wan，属组改成users。<br>$ chown - R wan.users /hi<br>chattr<br>1.作用<br>修改ext2和ext3文件系统属性(attribute)，使用权限超级用户。<br>2.格式<br>chattr [-RV] [-+=AacDdijsSu] [-v version] 文件或目录<br>3.主要参数<br>－R：递归处理所有的文件及子目录。<br>－V：详细显示修改内容，并打印输出。<br>－：失效属性。<br>＋：激活属性。<br>= ：指定属性。<br>A：Atime，告诉系统不要修改对这个文件的最后访问时间。<br>S：Sync，一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘。<br>a：Append Only，系统只允许在这个文件之后追加数据，不允许任何进程覆盖或截断这个文件。如果目录具有这个属性，系统将只允许在这个目录下建立和修改文件，而不允许删除任何文件。<br>i：Immutable，系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件。<br>D：检查压缩文件中的错误。<br>d：No dump，在进行文件系统备份时，dump程序将忽略这个文件。<br>C：Compress，系统以透明的方式压缩这个文件。从这个文件读取时，返回的是解压之后的数据；而向这个文件中写入数据时，数据首先被压缩之后才写入磁盘。<br>s：Secure Delete，让系统在删除这个文件时，使用0填充文件所在的区域。<br>u：Undelete，当一个应用程序请求删除这个文件，系统会保留其数据块以便以后能够恢复删除这个文件。<br>4.说明<br>chattr<br>命令的作用很大，其中一些功能是由Linux内核版本来支持的，如果Linux内核版本低于2.2，那么许多功能不能实现。同样－D检查压缩文件中的错误<br>的功能，需要2.5.19以上内核才能支持。另外，通过chattr命令修改属性能够提高系统的安全性，但是它并不适合所有的目录。chattr命令不能<br>保护/、/dev、/tmp、/var目录。<br>5.应用实例<br>1.恢复/root目录,即子目录的所有文件<h1 id="chattr-R-u-root"><a href="#chattr-R-u-root" class="headerlink" title="chattr -R +u/root"></a>chattr -R +u/root</h1>2.用chattr命令防止系统中某个关键文件被修改<br>在Linux下，有些配置文件(passwd ,fatab)是不允许任何人修改的，为了防止被误删除或修改，可以设定该文件的“不可修改位(immutable)”，命令如下：<h1 id="chattr-i-etc-fstab"><a href="#chattr-i-etc-fstab" class="headerlink" title="chattr +i /etc/fstab"></a>chattr +i /etc/fstab</h1>sudo<br>1.作用<br>sudo是一种以限制配置文件中的命令为基础，在有限时间内给用户使用，并且记录到日志中的命令，权限是所有用户。<br>2.格式<br>sudo [-bhHpV] [-s ] [-u ] [指令]<br>sudo [-klv]<br>3.主要参数<br>－b：在后台执行命令。<br>-h：显示帮助。<br>-H：将HOME环境变量设为新身份的HOME环境变量。<br>-k：结束密码的有效期，即下次将需要输入密码。<br>-l：列出当前用户可以使用的命令。<br>-p：改变询问密码的提示符号。<br>-s ：执行指定的Shell。<br>-u ：以指定的用户为新身份，不使用时默认为root。<br>-v：延长密码有效期5分钟。<br>4.说明<br>sudo<br>命令的配置在/etc/sudoers文件中。当用户使用sudo时，需要输入口令以验证使用者身份。随后的一段时间内可以使用定义好的命令，当使用配置<br>文件中没有的命令时，将会有报警的记录。sudo是系统管理员用来允许某些用户以root身份运行部分/全部系统命令的程序。一个明显的用途是增强了站点<br>的安全性，如果需要每天以超级用户的身份做一些日常工作，经常执行一些固定的几个只有超级用户身份才能执行的命令，那么用sudo是非常适合的。<br>ps<br>1.作用<br>ps显示瞬间进程 (process) 的动态，使用权限是所有使用者。<br>2.格式<br>ps [options] [–help]<br>3.主要参数<br>ps的参数非常多, 此出仅列出几个常用的参数。<br>-A：列出所有的进程。<br>-l：显示长列表。<br>-m：显示内存信息。<br>-w：显示加宽可以显示较多的信息。<br>-e：显示所有进程。<br>a：显示终端上的所有进程,包括其它用户的进程。<br>-au：显示较详细的信息。<br>-aux：显示所有包含其它使用者的进程。<br>4.说明<br>要<br>对进程进行监测和控制，首先要了解当前进程的情况，也就是需要查看当前进程。ps命令就是最基本、也是非常强大的进程查看命令。使用该命令可以确定有哪些<br>进程正在运行、运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等。图2给出了ps-aux命令详解。大部分信息都可以通过执行该命<br>令得到。最常用的三个参数是u、a、x。下面就结合这三个参数详细说明ps命令的作用：psaux<br>图2 ps-aux命令详解<br>图2第2行代码中，USER表示进程拥有者；PID表示进程标示符；%CPU表示占用的CPU使用率；%MEM占用的物理内存使用率；VSZ表示占用的虚拟内存大小；RSS为进程占用的物理内存值；TTY为终端的次要装置号码。<br>STAT<br>表示进程的状态，其中D为不可中断的静止（I/O动作）；R正在执行中；S静止状态；T暂停执行；Z不存在，但暂时无法消除；W没有足够的内存分页可分<br>配；高优先序的进程；N低优先序的进程；L有内存分页分配并锁在内存体内 (实时系统或<br>I/O)。START为进程开始时间。TIME为执行的时间。COMMAND是所执行的指令。<br>4.应用实例<br>在进行系统维护时，经常会出现内存使用量惊人，而又不知道是哪一个进程占用了大量进程的情况。除了可以使用top命令查看内存使用情况之外，还可以使用下面的命令：<br>ps aux | sort +5n<br>who<br>1.作用<br>who显示系统中有哪些用户登陆系统，显示的资料包含了使用者ID、使用的登陆终端、上线时间、呆滞时间、CPU占用，以及做了些什么。 使用权限为所有用户。<br>2.格式<br>who - [husfV] [user]<br>3.主要参数<br>-h：不要显示标题列。<br>-u：不要显示使用者的动作/工作。<br>-s：使用简短的格式来显示。<br>-f：不要显示使用者的上线位置。<br>-V：显示程序版本。<br>4.说明<br>该<br>命令主要用于查看当前在线上的用户情况。如果用户想和其它用户建立即时通信，比如使用talk命令，那么首先要确定的就是该用户确实在线上,不然<br>talk进程就无法建立起来。又如，系统管理员希望监视每个登录的用户此时此刻的所作所为，也要使用who命令。who命令应用起来非常简单，可以比较准<br>确地掌握用户的情况,所以使用非常广泛。<br>动手练习<br>1.使用Linux命令检测系统入侵者<br>安<br>装过Mandrake Linux和Red Hat<br>Linux的用户都会知道，Linux系统会内置三种不同级别（标准、高、更高）的防火墙，当进行了Linux服务器的安装和一些基本的设置后，服务器应<br>该说是比较安全的，但是也会有黑客通过各种方法利用系统管理员的疏忽侵入系统。如何快速查找黑客非常重要。一般来说，可以使用命令查询黑客是否入侵，见表<br>1。<br>表1 查询黑客入侵现象的命令对应表<br>举例说明，如果黑客嗅探网络，那么它必须使网卡接口处于混杂模式，使用下面命令进行查询：<br>＃ifconfig -a<br>eth0 Link encap:Ethernet HWaddr 00:00:E8:A0:25:86<br>inet addr:192.168.1.7 Bcast:192.168.1.255 Mask:255.255.255.0<br>UP BROADCAST RUNNING PROMISCUOUS MTU:1500 Metric:1<br>……<br>从<br>这个命令的输出中，可以看到上面讲到的这些概念。第一行的00:00:E8:A0:25:86是mac地址，第二行的192.168.1.7是IP地址，<br>第四行讲的是接收数据状态，这时正在被黑客嗅探。一般而言，网卡有几种接收数据帧的状态，如Broadcast、Multicast、<br>Promiscuous等。Broadcast是指接收所有类型为广播报文的数据帧；Multicast是指接收特定的组播报文；Promiscuous<br>则是通常说的混杂模式，是指对报文中的目的硬件地址不加任何检查、全部接收的工作模式。<br>2.限制su命令的滥用<br>我<br>们知道，超级用户在Linux中有最大的权利，几乎所有黑客都想得到这个目标。Linux可以增加对切换到超级用户的限制。使用PAM<br>（PluggableAuthentication<br>Modules）可以禁止除在wheel组以外的任何人su成root，修改/etc/pam.d/su文件，除去屏蔽标识#。使用<br>/usr/sbin/usermod G10 bjecadm将bjecadm这个账号加入gid为10的组，就是wheel组。命令如下：<br>/etc/pam.d/su # 使用密码验证＃<br>auth sufficient /lib/security/pam_wheel.so debug<h1 id="限制只有wheel组用户才可以切换到root＃"><a href="#限制只有wheel组用户才可以切换到root＃" class="headerlink" title="限制只有wheel组用户才可以切换到root＃"></a>限制只有wheel组用户才可以切换到root＃</h1>auth required /lib/security/pam_wheel.so use_uid<br>chmod -G10 bjecadm<br>另外，每当用户试图使用su命令进入系统用户时,命令将在/usr/adm/sulog文件中写一条信息,若该文件记录了大量试图用su进入root的无效操作信息,则表明了可能有人企图破译root口令。<br>Linux命令有着强大的功能。对于Linux系统管理员来说，往往只需要通过各种安全命令技巧，组合构成安全防线。从计算机安全的角度看，世界上没有绝对安全的计算机系统，Linux系统也不例外。<br>Linux必学的60个命令(6)-其他命令<br>Linux必学的60个命令：其它命令<br>在前面几讲中，我们把Linux命令按照在系统中的作用分成几个部分分别予以介绍。但是，还有一些命令不好划分，然而学习它们同样是比较重要的。<br>tar<br>1.作用<br>tar命令是Unix/Linux系统中备份文件的可靠方法，几乎可以工作于任何环境中，它的使用权限是所有用户。<br>2.格式<br>tar [主选项+辅选项] 文件或目录<br>3.主要参数<br>使用该命令时，主选项是必须要有的，它告诉tar要做什么事情，辅选项是辅助使用的，可以选用。<br>主选项：<br>-c 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。<br>-r 把要存档的文件追加到档案文件的未尾。例如用户已经做好备份文件，又发现还有一个目录或是一些文件忘记备份了，这时可以使用该选项，将忘记的目录或文件追加到备份文件中。<br>-t 列出档案文件的内容，查看已经备份了哪些文件。<br>-u 更新文件。就是说，用新增的文件取代原备份文件，如果在备份文件中找不到要更新的文件，则把它追加到备份文件的最后。<br>-x 从档案文件中释放文件。<br>辅助选项：<br>-b 该选项是为磁带机设定的，其后跟一数字，用来说明区块的大小，系统预设值为20（20×512bytes）。<br>-f 使用档案文件或设备，这个选项通常是必选的。<br>-k 保存已经存在的文件。例如把某个文件还原，在还原的过程中遇到相同的文件，不会进行覆盖。<br>-m 在还原文件时，把所有文件的修改时间设定为现在。<br>-M 创建多卷的档案文件，以便在几个磁盘中存放。<br>-v 详细报告tar处理的文件信息。如无此选项，tar不报告文件信息。<br>-w 每一步都要求确认。<br>-z 用gzip来压缩/解压缩文件，加上该选项后可以将档案文件进行压缩，但还原时也一定要使用该选项进行解压缩。<br>4.应用说明<br>tar 是Tape Archive（磁带归档）的缩写，最初设计用于将文件打包到磁带上。如果下载过Linux的源代码，或许已经碰到过tar文件<br>请注意，不要忘了Linux是区分大小写的。例如，tar命令应该总是以小写的形式执行。命令行开关可以是大写、小写或大小写的混合。例如，-t和-T执行不同的功能。文件或目录名称可以混合使用大小写，而且就像命令和命令行开关一样是区分大小写的。<br>5.应用实例<br>tar是一个命令行的工具，没有图形界面。使用Konsole打开一个终端窗口，接下来是一个简单的备份命令（在/temp目录中创建一个back.tar的文件，/usr目录中所有内容都包含在其中。）：<br>$tar cvf - /usr &gt; /temp/back.tar<br>另<br>外，tar命令支持前面第三讲中讲过的crontab命令，可以用crontab工具设置成基于时间的有规律地运行。例如，每晚6点把/usr目录备份到<br>hda—第一个IDE接口的主驱动器 (总是位于第一个硬盘)中，只要将下面语句添加到root的crontab中即可：<br>$00 06 <em> </em> <em> tar cvf /dev/hda1/usrfiles.tar - /usr<br>一般情况下，以下这些目录是需要备份的：<br>◆/etc 包含所有核心配置文件，其中包括网络配置、系统名称、防火墙规则、用户、组，以及其它全局系统项。<br>◆ /var 包含系统守护进程（服务）所使用的信息，包括DNS配置、DHCP租期、邮件缓冲文件、HTTP服务器文件、dB2实例配置等。<br>◆/home 包含所有默认用户的主目录，包括个人设置、已下载的文件和用户不希望失去的其它信息。<br>◆/root 根（root）用户的主目录。<br>◆/opt 是安装许多非系统文件的地方。IBM软件就安装在这里。OpenOffice、JDK和其它软件在默认情况下也安装在这里。<br>有些目录是可以不备份的：<br>◆ /proc 应该永远不要备份这个目录。它不是一个真实的文件系统，而是运行内核和环境的虚拟化视图，包括诸如/proc/kcore这样的文件，这个文件是整个运行内存的虚拟视图。备份这些文件只是在浪费资源。<br>◆/dev 包含硬件设备的文件表示。如果计划还原到一个空白的系统，就可以备份/dev。然而，如果计划还原到一个已安装的Linux 系统，那么备份/dev是没有必要的。<br>unzip<br>1.作用<br>unzip<br>命令位于/usr/bin目录中，它们和MS DOS下的pkzip、pkunzip及MS<br>Windows中的Winzip软件功能一样，将文件压缩成.zip文件，以节省硬盘空间，当需要的时候再将压缩文件用unzip命令解开。该命令使用权<br>限是所有用户。<br>2.格式<br>unzip [-cflptuvz][-agCjLMnoqsVX][-P ][.zip文件][文件][-d][-x ]<br>3.主要参数<br>-c：将解压缩的结果显示到屏幕上，并对字符做适当的转换。<br>-f：更新现有的文件。<br>-l：显示压缩文件内所包含的文件。<br>-p：与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。<br>-t：检查压缩文件是否正确。<br>-u：与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其它文件解压缩到目录中。<br>-v：执行是时显示详细的信息。<br>-z：仅显示压缩文件的备注文字。<br>-a：对文本文件进行必要的字符转换。<br>-b：不要对文本文件进行字符转换。<br>-C：压缩文件中的文件名称区分大小写。<br>-j：不处理压缩文件中原有的目录路径。<br>-L：将压缩文件中的全部文件名改为小写。<br>-M：将输出结果送到more程序处理。<br>-n：解压缩时不要覆盖原有的文件。<br>-o：不必先询问用户，unzip执行后覆盖原有文件。<br>-P：使用zip的密码选项。<br>-q：执行时不显示任何信息。<br>-s：将文件名中的空白字符转换为底线字符。<br>-V：保留VMS的文件版本信息。<br>-X：解压缩时同时回存文件原来的UID/GID。<br>[.zip文件]：指定.zip压缩文件。<br>[文件]：指定要处理.zip压缩文件中的哪些文件。<br>-d：指定文件解压缩后所要存储的目录。<br>-x：指定不要处理.zip压缩文件中的哪些文件。<br>-Z unzip：-Z等于执行zipinfo指令。在Linux中，还提供了一个叫zipinfo的工具，能够察看zip压缩文件的详细信息。unzip最新版本是5.50。<br>gunzip<br>1.作用<br>gunzip命令作用是解压文件，使用权限是所有用户。<br>2.格式<br>gunzip [-acfhlLnNqrtvV][-s ][文件…]<br>或者<br>gunzip [-acfhlLnNqrtvV][-s ][目录]<br>3.主要参数<br>-a或–ascii：使用ASCII文字模式。<br>-c或–stdout或–to-stdout：把解压后的文件输出到标准输出设备。<br>-f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在，以及该文件是否为符号连接。<br>-h或–help：在线帮助。<br>-l或–list：列出压缩文件的相关信息。<br>-L或–license：显示版本与版权信息。<br>-n或–no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理。<br>-N或–name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上。<br>-q或–quiet：不显示警告信息。<br>-r或–recursive：递归处理，将指定目录下的所有文件及子目录一并处理。<br>-S或–suffix：更改压缩字尾字符串。<br>-t或–test：测试压缩文件是否正确无误。<br>-v或–verbose：显示指令执行过程。<br>-V或–version：显示版本信息。<br>4.说明<br>gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为“.gz”。事实上，gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。gunzip最新版本是1.3.3。<br>unarj<br>1.作用<br>unarj解压缩格式为.arj格式的文件，使用权限是所有用户。<br>2.格式<br>unarj [eltx][.arj压缩文件]<br>3.主要参数<br>e：解压缩.arj文件。<br>l：显示压缩文件内所包含的文件。<br>t：检查压缩文件是否正确。<br>x：解压缩时保留原有的路径。<br>4.说明<br>带有.arj扩展名的文件是由用于MS DOS和Windows的ARJ实用程序创建的。因为ARJ是一种不能免费获得源代码的共享件程序，所以在<br>mtools<br>1.作用<br>mtools<br>实际上是一个命令集合，是DOS文件系统的工具程序，它可以模拟许多DOS命令，使用起来非常方便。使用权限是所有用户。Linux系统提供了一组称为<br>mtools的可移植工具，可以让用户轻松地从标准的DOS软盘上读、写文件和目录。它们对DOS和Linux环境之间交换文件非常有用。mtools的<br>使用非常简单，如果想把软盘里所有的文件都拷贝到硬盘上，那么就可以执行以下命令：<br>mcopy a:</em>.*<br>也就是说，只需要在相应的DOS命令之前加上一个字母“m”，就可以完成对应的功能了。一般Linux发行版本中都有这个软件，可以使用下面命令检查一下。<br>rpm -qa|grep mtools<br>如果没有安装，也没有关系，可以从网上下载(<a href="http://mtools.linux.lu/)一个最新版本来安装。目前可供下载的最新mtools版本是" target="_blank" rel="external">http://mtools.linux.lu/)一个最新版本来安装。目前可供下载的最新mtools版本是</a><br>2.包括的命令<br>mcd 目录名：改变MS DOS下的目录。<br>mcopy 源文件 目标文件：在MS DOS和Unix之间复制文件。<br>mdel 文件名：删除MS DOS下的文件。<br>mdir 目录名：显示MS DOS下的目录。<br>mformat 驱动器号：在低级格式化的软盘上创建MS DOS文件系统。<br>rnlabel 驱动器号：产生MS DOS下的卷标。<br>mmd 目录名：建立MS DOS下的目录。<br>mrd 目录名：删除MS DOS下的目录。<br>mren 源文件 目标文件：重新命名已存在的MS DOS文件。<br>mtype 文件名：显示MS DOS文件的内容。<br>请注意，这些命令和对应的MS DOS命令非常相似。在mtools命令中，“/”和“\”是可以混用的。因为文件列表的是DOS系统下的文档，对大小写并不敏感，所以“CDE”和“cde”在这里是一样的。<br>3.应用实例<br>(1)如果把软盘进行快速格式化，可以使用命令mformat：<br>mformat A：<br>mtools<br>当初发展的目的是用来处理DOS文件系统的，所以只能用在FAT文件格式的分区上。需要注意的是，如果用mount命令来挂载了FAT16/32分区，那<br>么就不能使用mtools的指令来处理这些分区上的文件。这是因为一旦FAT16/32分区挂到了Linux文件目录下，Linux就会将其视为文件系统<br>本身的一部分，这时如果要对其操作就必须使用Linux本身所附带的指令集。<br>(2)将DOS盘上的文件htca.c复制到当前目录下，并用ls命令进行验证。<br>$ mcopy a:\htca.c<br>$ ls -l htca.c<br>-rw-r- -r- - 1 xxq xxq 27136 Jan 1 01:80 htca.c<br>man<br>1.作用<br>man命令用来提供在线帮助，使用权限是所有用户。在Linux系统中存储着一部联机使用的手册，以供用户在终端上查找。使用man命令可以调阅其中的帮助信息，非常方便和实用。<br>2.格式<br>man 命令名称<br>man [-acdfhkKtwW] [-m system] [-p string] [-C config_file] [-M path] [-P pager][-S section_list] [section] name …<br>3.参数<br>-C config_file：指定设定文件man.conf，缺省值是/etc/man.conf。<br>-M path：指定了联机手册的搜寻路径, 如果没有指定则使用环境变数MANPATH的设定；如果没有使用MANPATH， 则会使用/usr/lib/man.conf内的设定；如果MANPATH是空字串，则表示使用缺省值。<br>-P pager：指定使用何种pager.man会优先使用此选项设定，然后是依环境变数MANPAGER设定，然后是环境变数PAGER；man缺省使用/usr/bin/less -is。<br>-S section_list man：所搜寻的章节列表(以冒号分隔)，此选项会覆盖环境变数MANSECT的设定。<br>-a man：缺省情况是在显示第一个找到的手册之后，就会停止搜寻，使用此选项会强迫man继续显示所有符合name的联机手册。<br>-c：即使有最新的cat page，也继续对联机手册重新作排版，本选项在屏幕的行列数改变时或已排版的联机手册损坏时特别有意义。<br>-d：不要真的显示联机手册，只显示除错讯息。<br>-D：同时显示联机手册与除错讯息。<br>-h：显示求助讯息然后结束程式 。<br>-K：对所有的联机手册搜寻所指定的字串。请注意，本功能回应速度可能很慢，如果指定section（区域）会对速度有帮助。<br>-m system：依所指定的system名称而指定另一组的联机手册。<br>man：是manual（手册）的缩写。在输入命令有困难时，可以立刻得到这个文档。例如, 如果使用ps命令时遇到困难，可以输入man ps得到帮助信息，此时会显示出ps的手册页（manpage）。<br>由于手册页man page是用less程序来看的(可以方便地使屏幕上翻和下翻), 所以在manpage里可以使用less的所有选项。<br>less中比较重要的功能键有:<br>[q] 退出；<br>[Enter] 一行行地下翻；<br>[Space] 一页页地下翻；<br>上翻一页；<br>[/] 后跟一个字符串和[Enter]来查找字符串；<br>[n] 发现上一次查找的下一个匹配。<br>4.阅读手册页<br>手册页在很少的空间里提供了很多的信息， 这里简单介绍一下大多数手册页中都有的部分内容。Linux手册页主要有九个部分：用户指令、系统调用、程序库、设备说明、文件格式、游戏、杂项、系统指令、内核，手册页快照见图1所示。<br>图1 ps命令手册页快照<br>Linux手册页布局见表1。<br>5.应用实例<br>Linux<br>命令中有一些基础的、重要的命令，例如ps、find、cat和ls等。下面来举一个综合应用的例子，由此可以看出man的地位在Linux中可谓至关重<br>要。但是，man所显示的信息却不是普通的文本，如果直接将这些文字重定向到一个文本文件，就会发现在man中高亮显示的文字就变成了两个，而且有不计其<br>数的制表符，使打印、编辑都变得非常不便。不过，使用下面这样一条语句就能得到ps命令打印。<h1 id="man-ps-col-b-lpr"><a href="#man-ps-col-b-lpr" class="headerlink" title="man ps | col -b | lpr"></a>man ps | col -b | lpr</h1>这条命令同时运用了输出重定向和管道两种技巧，作用是将ps命令的帮助信息可以直接打印出来。更多的Man文件可以查看LinuxMan<br>unencode<br>1.作用<br>unencode命令可以把一个二进制文件表编码为一个文本文件，使用权限是所有用户。<br>2.格式<br>uuencode [-hv] [源文件] 目标文件<br>3.主要参数<br>－h：列出指令使用格式(help) 。<br>－v：列出版本信息。<br>4.应用说明<br>uuencode指令可以将二进制文件转化成可使用电子邮件发送的ASCII编码形式。uuencode编码后的资料都以 begin开始，以end作为结束，且通常其中的每一行的开始均为“M”，中间部分是编码过的文件，编码后的文件比源文件要大一些。<br>uudecode<br>1.作用<br>uudecode命令用来将uuencode编码后的档案还原，uudecode只会将begin与end标记之间的编码资料还原，程序会跳过标记以外的资料。它的使用权限为所有用户。<br>2.格式<br>uuencode [-hv] [file1 …]<br>3.主要参数<br>－h：列出指令使用格式(help)。<br>－v：列出版本信息。<br>4.应用实例<br>使用下面命令一次还原几个文件：<br>uuencode file1.uud file2.uud file3.uud<br>动手练习<br>1.在Linux命令行下发送邮件<br>虽然Linux桌面应用发展很快，但是命令行（Shell）在Linux中依然有很强的生命力。如果能确认电子邮件服务器支持8bit的字节，就可以直接使用下面命令：<br>cat ＜附件文件名＞ | mail ＜邮件地址＞<br>cat（cat是concatenate的缩写）命令是将几个文件处理成一个文件，并将这种处理的结果保存到一个单独的输出文件，这里我们用它来合并邮件的文本。<br>写好邮件名称，比如叫cjkmail，然后使用下面命令：<br>$uuencode ＜附件文件名＞ ＜附件文件名＞ &gt;&gt;cjkmail<br>这样就可以用vi编辑器写cjkmail文件，并在前面写上信的正文，然后寄出。<br>对方收到信后，把信中属于cjkmail中的内容拷贝出来，存为themail.uue。如果对方是在Windows下，就可以用WinRAR或WinZip解压，这样就可以看到附件。<br>如果对方也使用Linux，可以用undecode命令还原：<br>$ uudencode -o＜附件文件名＞ themail.uue<br>2.实现tar的分卷<br>笔者想把一个378MB的文件压缩成多个63MB的文件（笔者的USB为64MB），使用下面命令：<br>$tar czvf - dir | split -d -b 63m<br>然后合并命令：<br>$cat x* &gt; dir.tgz<br>以上例子实际是由三个命令组合完成的，即用tar打包，用split分割，用cat合并。“tarczvf - dir”的意思是把dir目录打包，并输出到标准输出（argv），这样就可以直接用管道输出给split。<br>3.连续执行一个命令<br>使用watch命令，可以反复执行命令。如果和ls配合，可以达到观察某文件大小变化的效果。<br>$watch ls －l file.name<br>4.用tar命令导出一个文件<br>有一个tar格式的DVD文件GLvPro6.4_linux.tar，因为该文件非常大（4.7GB），如果全部解压比较麻烦，可以用下面命令先导出readme.txt看看。<br>tar xvf GLvPro6.4_linux.tar readme.txt<br>这样readme.txt就单独被导出了。<br>5.用tar打包一个目录时只备份其中的几个子目录<br>tar cf –exclude home/cjh home/cao<br>这样home目录下只有cjh和cao两个子目录备份。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式二]]></title>
      <url>http://yoursite.com/2016/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造模式是将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心。<br>在Java的应用中JavaMail使用到了该模式。<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/21783106.jpg" alt="建造者模式"></p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/* 浅复制 */</div><div class="line">public Object clone() throws CloneNotSupportedException &#123;</div><div class="line">	Prototype proto = (Prototype) super.clone();</div><div class="line">	return proto;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 深复制 */</div><div class="line">public Object deepClone() throws IOException, ClassNotFoundException &#123;</div><div class="line">	/* 写入当前对象的二进制流 */</div><div class="line">	ByteArrayOutputStream bos = new ByteArrayOutputStream();</div><div class="line">	ObjectOutputStream oos = new ObjectOutputStream(bos);</div><div class="line">	oos.writeObject(this);</div><div class="line">	/* 读出二进制流产生的新对象 */</div><div class="line">	ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());</div><div class="line">	ObjectInputStream ois = new ObjectInputStream(bis);</div><div class="line">	return ois.readObject();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/52927626-640.webp" alt="类的适配器模式"><br>核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Source &#123;</div><div class="line">	public void method1()&#123;</div><div class="line">		System.out.println(&quot;method1&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface Targetable &#123;</div><div class="line">	public void method1();</div><div class="line">	public void method2();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Adapter extends Source implements Targetable&#123;</div><div class="line">	@Override</div><div class="line">	public void method2() &#123;</div><div class="line">		System.out.println(&quot;method2&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class AdapterTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Targetable target = new Adapter();</div><div class="line">		target.method1();</div><div class="line">		target.method2();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/25514382-640.webp" alt="对象的适配器模式"><br>基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Wrapper implements Targetable &#123;</div><div class="line">	private Source source;</div><div class="line">	public Wrapper(Source source)&#123;</div><div class="line">	super();</div><div class="line">	this.source = source;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void method2() &#123;</div><div class="line">		System.out.println(&quot;this is the targetable method!&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void method1() &#123;</div><div class="line">		source.method1();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/25514382-640.webp" alt="接口的适配器模式"><br>接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public interface Sourceable &#123;</div><div class="line">	public void method1();</div><div class="line">	public void method2();</div><div class="line">	public void method3();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class Wrapper implements Sourceable &#123;</div><div class="line">	public void method1()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public void method2()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SourceSub1 extends Wrapper&#123;</div><div class="line">	@Override</div><div class="line">	public void method3() &#123;</div><div class="line">		System.out.println(&quot;SourceSub1&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SourceSub2 extends Wrapper&#123;</div><div class="line">	@Override</div><div class="line">	public void method3() &#123;</div><div class="line">		System.out.println(&quot;SourceSub3&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Sourceable source1 = new SourceSub1();</div><div class="line">		Sourceable source2 = new SourceSub2();</div><div class="line">		source1.method1();</div><div class="line">		source1.method2();</div><div class="line">		source1.method3();</div><div class="line"></div><div class="line">		source2.method1();</div><div class="line">		source2.method2();</div><div class="line">		source2.method3();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>适配器模式总结</p>
<ul>
<li>类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</li>
<li>对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</li>
<li>接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</li>
</ul>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例<br>简单的装饰模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public interface IComponent &#123;</div><div class="line">	public void operation();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteComponent implements IComponent &#123;</div><div class="line">	@Override</div><div class="line">	public void operation() &#123;</div><div class="line">		System.out.println(&quot;开车&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Decorator implements IComponent &#123;</div><div class="line">	private IComponent component;</div><div class="line"></div><div class="line">	public Decorator(IComponent component) &#123;</div><div class="line">		this.component = component;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void operation() &#123;</div><div class="line">		component.operation();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteDecorator extends Decorator &#123;</div><div class="line">	public ConcreteDecorator(IComponent component) &#123;</div><div class="line">		super(component);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void operation() &#123;</div><div class="line">		this.addOperation();</div><div class="line">		super.operation();</div><div class="line">	&#125;</div><div class="line">	private void addOperation() &#123;</div><div class="line">		System.out.print(&quot;晚上&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ConcreteComponent component = new ConcreteComponent();</div><div class="line">		ConcreteDecorator decorator = new ConcreteDecorator(component);</div><div class="line">		decorator.operation();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>复杂的装饰模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">public interface IComponent &#123;</div><div class="line">	void showCoffee();</div><div class="line">	double showPrice();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Coffee implements IComponent &#123;</div><div class="line">	private String name;</div><div class="line">	private double price;</div><div class="line">	public Coffee(String name,double price)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.price = price;</div><div class="line">	&#125;</div><div class="line">	...get...set</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void showCoffee() &#123;</div><div class="line">		System.out.println(&quot;的&quot;+this.getName()+&quot;咖啡&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public double showPrice() &#123;</div><div class="line">		return this.getPrice();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">// 装饰类</div><div class="line">public class Decorator implements IComponent &#123;</div><div class="line">	private IComponent componet;</div><div class="line"></div><div class="line">	public void setComponent(IComponent component) &#123;</div><div class="line">		this.componet = component;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void showCoffee() &#123;</div><div class="line">		componet.showCoffee();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public double showPrice() &#123;</div><div class="line">		return componet.showPrice();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Milk extends Decorator&#123;</div><div class="line">	@Override</div><div class="line">	public void showCoffee() &#123;</div><div class="line">		System.out.print(&quot;加奶&quot;);</div><div class="line">		super.showCoffee();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public double showPrice() &#123;</div><div class="line">		return 15.0+super.showPrice();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Sugar extends Decorator &#123;</div><div class="line">	@Override</div><div class="line">	public void showCoffee() &#123;</div><div class="line">		System.out.print(&quot;加糖&quot;);</div><div class="line">		super.showCoffee();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public double showPrice() &#123;</div><div class="line">		return 10+super.showPrice();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Coffee coffee = new Coffee(&quot;拿铁&quot;,55.0);</div><div class="line">		Decorator sugar = new Sugar();</div><div class="line">		Decorator milk = new Milk();</div><div class="line">		sugar.setComponent(coffee);</div><div class="line">		milk.setComponent(sugar);</div><div class="line">		milk.showCoffee();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>装饰器模式的应用场景：<br>1、需要扩展一个类的功能。<br>2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）<br>缺点：产生过多相似的对象，不易排错！</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理持有一个真实实现类的引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public interface Sourceable &#123;</div><div class="line">    public void method();</div><div class="line">&#125;</div><div class="line">public class Source implements Sourceable &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void method() &#123;</div><div class="line">        System.out.println(&quot;the original method!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class Proxy implements Sourceable &#123;</div><div class="line"></div><div class="line">    private Source source;</div><div class="line">    public Proxy()&#123;</div><div class="line">        super();</div><div class="line">        this.source = new Source();</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void method() &#123;</div><div class="line">        before();</div><div class="line">        source.method();</div><div class="line">        atfer();</div><div class="line">    &#125;</div><div class="line">    private void atfer() &#123;</div><div class="line">        System.out.println(&quot;after proxy!&quot;);</div><div class="line">    &#125;</div><div class="line">    private void before() &#123;</div><div class="line">        System.out.println(&quot;before proxy!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/70870796-640.webp" alt="外观模式"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Computer &#123;</div><div class="line">	private CPU cpu;</div><div class="line">	private Memory memory;</div><div class="line">	private Disk disk;</div><div class="line">	public Computer()&#123;</div><div class="line">		cpu = new CPU();</div><div class="line">		memory = new Memory();</div><div class="line">		disk = new Disk();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void startUp()&#123;</div><div class="line">		cpu.startUp();</div><div class="line">		memory.startUp();</div><div class="line">		disk.startUp();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void shutDown()&#123;</div><div class="line">		cpu.shutDown();</div><div class="line">		memory.shutDown();</div><div class="line">		disk.shutDown();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/95852650.jpg" alt="策略模式"></p>
<ol>
<li><p>加减法计算表达式-策略模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public interface ICalculator &#123;</div><div class="line">	public int calculate(String exp);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class AbstractCalculator &#123;</div><div class="line">	public int[] split(String exp,String delimeter)&#123;</div><div class="line">		String[] arr = exp.split(delimeter);</div><div class="line">		int[] result = new int[2];</div><div class="line">		result[0] = Integer.parseInt(arr[0]);</div><div class="line">		result[1] = Integer.parseInt(arr[1]);</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Minus extends AbstractCalculator implements ICalculator&#123;</div><div class="line">	@Override</div><div class="line">	public int calculate(String exp) &#123;</div><div class="line">		int[] arr = split(exp, &quot;-&quot;);</div><div class="line">		return arr[0]-arr[1];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Plus extends AbstractCalculator implements ICalculator&#123;</div><div class="line">	@Override</div><div class="line">	public int calculate(String exp) &#123;</div><div class="line">		int[] arr = split(exp, &quot;\\+&quot;);</div><div class="line">		return arr[0]+arr[1];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Multiply extends AbstractCalculator implements ICalculator&#123;</div><div class="line">	@Override</div><div class="line">	public int calculate(String exp) &#123;</div><div class="line">		int[] arr = split(exp, &quot;\\*&quot;);</div><div class="line">		return arr[0]*arr[1];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ICalculator cal = new Plus();</div><div class="line">		int res = cal.calculate(&quot;8+2&quot;);</div><div class="line">		System.out.println(res);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>客户打折-策略模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public interface Strategy &#123;</div><div class="line">	public double calcPrice(double goodsPrice);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class LargeCustomerStrategy implements Strategy&#123;</div><div class="line">	@Override</div><div class="line">	public double calcPrice(double goodsPrice) &#123;</div><div class="line">		System.out.println(&quot;大客户10%&quot;);</div><div class="line">		return goodsPrice*(1-0.1);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class OldCustomerStrategy implements Strategy&#123;</div><div class="line">	@Override</div><div class="line">	public double calcPrice(double goodsPrice) &#123;</div><div class="line">		System.out.println(&quot;老客户5%&quot;);</div><div class="line">		return goodsPrice*(1-0.05);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class NormalCustomerStrategy implements Strategy&#123;</div><div class="line">	@Override</div><div class="line">	public double calcPrice(double goodsPrice) &#123;</div><div class="line">		System.out.println(&quot;新客户或普通客户没有折扣&quot;);</div><div class="line">		return goodsPrice;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Price &#123;</div><div class="line">	private Strategy strategy = null;</div><div class="line"></div><div class="line">	public Price(Strategy strategy)&#123;</div><div class="line">		this.strategy = strategy;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public double quote(double goodsPrice)&#123;</div><div class="line">		return this.strategy.calcPrice(goodsPrice);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Strategy strategy = new LargeCustomerStrategy();</div><div class="line">		Price ctx = new Price(strategy);</div><div class="line">		double quote = ctx.quote(1000);</div><div class="line">		System.out.println(&quot;报价:&quot;+quote);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>保存日志到数据库/文件-策略模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public interface LogStrategy &#123;</div><div class="line">	public void log(String msg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class DbLog implements LogStrategy&#123;</div><div class="line">	@Override</div><div class="line">	public void log(String msg) &#123;</div><div class="line">		if(msg!=null &amp;&amp; msg.trim().length()&gt;5)&#123;</div><div class="line">			int a = 5/0;</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;现在把&apos;&quot;+msg+&quot;&apos;记录到数据库中&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class FileLog implements LogStrategy&#123;</div><div class="line">	@Override</div><div class="line">	public void log(String msg) &#123;</div><div class="line">		System.out.println(&quot;现在把&apos;&quot;+msg+&quot;&apos;记录到文件中&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class LogContext &#123;</div><div class="line">	public void log(String msg)&#123;</div><div class="line">		LogStrategy strategy = new DbLog();</div><div class="line">		try &#123;</div><div class="line">			strategy.log(msg);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			strategy = new FileLog();</div><div class="line">			strategy.log(msg);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		LogContext log = new LogContext();</div><div class="line">		// 正常记录到数据库中</div><div class="line">		log.log(&quot;记录日志&quot;);</div><div class="line">		// 发生异常，此时策略切换为文件记录日志</div><div class="line">		log.log(&quot;再次记录日志&quot;);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">结果：</div><div class="line">现在把&apos;记录日志&apos;记录到数据库中</div><div class="line">现在把&apos;再次记录日志&apos;记录到文件中</div></pre></td></tr></table></figure>
</li>
<li><p>给某个动作前面加上一个动作-策略模式结合模板模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public interface LogStrategy &#123;</div><div class="line">	public void log(String msg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class LogStrategyTemplate implements LogStrategy&#123;</div><div class="line">	//给各个策略前面加上时间，可以通过结合模板模式，在父类中设定好执行顺序，由子类执行</div><div class="line">	@Override</div><div class="line">	public void log(String msg) &#123;</div><div class="line">		SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div class="line">		msg = sdf.format(new Date())+&quot;内容是&quot;+msg;</div><div class="line">		doLog(msg);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	protected abstract void doLog(String msg);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class DbLog extends LogStrategyTemplate&#123;</div><div class="line">	@Override</div><div class="line">	protected void doLog(String msg) &#123;</div><div class="line">		if(msg!=null &amp;&amp; msg.trim().length()&gt;5)&#123;</div><div class="line">			int a = 5/0;</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;记录到数据库中：&quot;+msg);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class FileLog extends LogStrategyTemplate&#123;</div><div class="line">	@Override</div><div class="line">	protected void doLog(String msg) &#123;</div><div class="line">		System.out.println(&quot;现在把&quot;+msg+&quot;记录到数据库中&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class LogContext &#123;</div><div class="line">	public void log(String msg)&#123;</div><div class="line">		LogStrategy strategy = new DbLog();</div><div class="line">		try &#123;</div><div class="line">			strategy.log(msg);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			strategy = new FileLog();</div><div class="line">			strategy.log(msg);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		LogContext log = new LogContext();</div><div class="line">		log.log(&quot;记录日志&quot;);</div><div class="line">		log.log(&quot;再次记录日志&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出</div><div class="line">现在把2016-04-26 18:11:32内容是  记录日志  记录到数据库中</div><div class="line">现在把2016-04-26 18:11:32内容是  再次记录日志  记录到数据库中</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-26/65731774.jpg" alt="模板方式模式"><br>就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractCalculator &#123;</div><div class="line">	public final int calculate(String exp,String delimeter)&#123;</div><div class="line">		int array[] = split(exp, delimeter);</div><div class="line">		return calculate(array[0],array[1]);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public abstract int calculate(int num1,int num2);</div><div class="line"></div><div class="line">	public int[] split(String exp,String delimeter)&#123;</div><div class="line">		String[] arr = exp.split(delimeter);</div><div class="line">		int[] result = new int[2];</div><div class="line">		result[0] = Integer.parseInt(arr[0]);</div><div class="line">		result[1] = Integer.parseInt(arr[1]);</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Plus extends AbstractCalculator&#123;</div><div class="line">	@Override</div><div class="line">	public int calculate(int num1, int num2) &#123;</div><div class="line">		return num1+num2;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		AbstractCalculator cal = new Plus();</div><div class="line">		int res = cal.calculate(&quot;8+2&quot;,&quot;\\+&quot;);</div><div class="line">		System.out.println(res);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class Watcher implements Observer &#123;</div><div class="line">	public Watcher(Watched w) &#123;</div><div class="line">		w.addObserver(this);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void update(Observable o, Object arg) &#123;</div><div class="line">		System.out.println(((Watched)o).retriveData());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Watched extends Observable &#123;</div><div class="line">	private String data=&quot;&quot;;</div><div class="line"></div><div class="line">	public String retriveData()&#123;</div><div class="line">		return data;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void changeData(String data)&#123;</div><div class="line">		if(!this.data.equals(data))&#123;</div><div class="line">			this.data = data;</div><div class="line">			setChanged();</div><div class="line">			notifyObservers();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Watched watched = new Watched();</div><div class="line">		Watcher watcher = new Watcher(watched);</div><div class="line">		watched.changeData(&quot;A&quot;);</div><div class="line">		watched.changeData(&quot;B&quot;);</div><div class="line">		watched.changeData(&quot;C&quot;);</div><div class="line">		watched.changeData(&quot;D&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>又被称为游标模式。这种模式提供一种方法访问一个容器对象中的各个元素，而又不需要暴露该对象的内部细节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public interface IIterator &#123;</div><div class="line">	public Object previous();</div><div class="line">	public Object next();</div><div class="line">	public boolean hasNext();</div><div class="line">	public Object first();</div><div class="line">&#125;</div><div class="line">// 持有一个迭代器对象的引用</div><div class="line">public interface Collection &#123;</div><div class="line">	public IIterator iterator();</div><div class="line">	public Object get(int i);</div><div class="line">	public int size();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MyCollection implements Collection&#123;</div><div class="line">	public String[] string = null;</div><div class="line">	public MyCollection(String[] str)&#123;</div><div class="line">		string = str;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public IIterator iterator() &#123;</div><div class="line">		return new MyIterator(this);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Object get(int i) &#123;</div><div class="line">		return string[i];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public int size() &#123;</div><div class="line">		return string.length;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MyIterator implements IIterator&#123;</div><div class="line"></div><div class="line">	private Collection collection;</div><div class="line">	private int pos=-1;</div><div class="line"></div><div class="line">	public MyIterator(Collection collection)&#123;</div><div class="line">		this.collection = collection;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Object previous() &#123;</div><div class="line">		if(pos&gt;0)</div><div class="line">			pos--;</div><div class="line">		return collection.get(pos);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Object next() &#123;</div><div class="line">		if(pos&lt;collection.size()-1)</div><div class="line">			pos++;</div><div class="line">		return collection.get(pos);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public boolean hasNext() &#123;</div><div class="line">		if(pos&lt;collection.size()-1)</div><div class="line">			return true;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Object first() &#123;</div><div class="line">		pos=0;</div><div class="line">		return collection.get(pos);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String[] str = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;&#125;;</div><div class="line">		Collection myCollection = new MyCollection(str);</div><div class="line">		IIterator it = myCollection.iterator();</div><div class="line">		while(it.hasNext())&#123;</div><div class="line">			System.out.println(it.next());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// 责任链上各个对象执行的方法</div><div class="line">public interface Handler &#123;</div><div class="line">	public void operator();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class AbstractHandler &#123;</div><div class="line">	private Handler handler;</div><div class="line"></div><div class="line">	public Handler getHandler()&#123;</div><div class="line">		return handler;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setHandler(Handler handler)&#123;</div><div class="line">		this.handler = handler;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MyHandler extends AbstractHandler implements Handler&#123;</div><div class="line">	private String name;</div><div class="line"></div><div class="line">	public MyHandler(String name)&#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void operator() &#123;</div><div class="line">		System.out.println(name+&quot; deal!&quot;);</div><div class="line">		if(getHandler()!=null)&#123;</div><div class="line">			getHandler().operator();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 此处只能用具体类，不能用抽象类，因为后面需要设置实现了接口的对象为下一个handler</div><div class="line">		MyHandler h1 = new MyHandler(&quot;h1&quot;);</div><div class="line">		MyHandler h2 = new MyHandler(&quot;h2&quot;);</div><div class="line">		MyHandler h3 = new MyHandler(&quot;h3&quot;);</div><div class="line"></div><div class="line">		h1.setHandler(h2);</div><div class="line">		h2.setHandler(h3);</div><div class="line">		h1.operator();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>命令模式的目的就是达到命令的发出者和执行者之间解耦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public interface Command &#123;</div><div class="line">	public void execute();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class OpenCommand implements Command &#123;</div><div class="line">	private MainBoard mainBoard;</div><div class="line"></div><div class="line">	public OpenCommand(MainBoard mainBoard) &#123;</div><div class="line">		this.mainBoard = mainBoard;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void execute() &#123;</div><div class="line">		mainBoard.open();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface MainBoard &#123;</div><div class="line">	public void open();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class GigaMainBoard implements MainBoard &#123;</div><div class="line">	@Override</div><div class="line">	public void open() &#123;</div><div class="line">		System.out.println(&quot;华硕主板开机&quot;);</div><div class="line">		System.out.println(&quot;接通电源&quot;);</div><div class="line">		System.out.println(&quot;正常运转&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Box &#123;</div><div class="line">	private Command openCommand;</div><div class="line"></div><div class="line">	public void setOpenCommand(Command command) &#123;</div><div class="line">		this.openCommand = command;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void openButtonPressed() &#123;</div><div class="line">		openCommand.execute();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		MainBoard mainBoard = new GigaMainBoard();</div><div class="line">		Command openCommand = new OpenCommand(mainBoard);</div><div class="line">		Box box = new Box();</div><div class="line">		box.setOpenCommand(openCommand);</div><div class="line">		box.openButtonPressed();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public abstract class Order &#123;</div><div class="line">	public abstract void sell();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class FlavorOrder extends Order&#123;</div><div class="line">	public String flavor;</div><div class="line">	public FlavorOrder(String flavor) &#123;</div><div class="line">		this.flavor = flavor;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void sell() &#123;</div><div class="line">		System.out.println(&quot;卖出&quot;+flavor+&quot;一份&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 枚举写出的单例，利用HashMap来实现享元模式</div><div class="line">public enum FlavorFactory &#123;</div><div class="line">	instance;</div><div class="line">	private Map&lt;String,Order&gt; flavorPool = new HashMap&lt;String,Order&gt;();</div><div class="line">	public Order getOrder(String flavor)&#123;</div><div class="line">		Order order = null;</div><div class="line">		if(flavorPool.containsKey(flavor))&#123;</div><div class="line">			order = flavorPool.get(flavor);</div><div class="line">		&#125;else&#123;</div><div class="line">			order = new FlavorOrder(flavor);</div><div class="line">			flavorPool.put(flavor, order);</div><div class="line">		&#125;</div><div class="line">		return order;</div><div class="line">	&#125;</div><div class="line">	public int getTotalSize()&#123;</div><div class="line">		return flavorPool.size();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	static ArrayList&lt;Order&gt; orders = new ArrayList&lt;Order&gt;();</div><div class="line">	public static void addOrder(String flavor) &#123;</div><div class="line">		orders.add(FlavorFactory.instance.getOrder(flavor));</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		FlavorFactory factory = FlavorFactory.instance;</div><div class="line">		addOrder(&quot;one&quot;);</div><div class="line">		addOrder(&quot;two&quot;);</div><div class="line">		addOrder(&quot;three&quot;);</div><div class="line">		addOrder(&quot;three&quot;);</div><div class="line">		addOrder(&quot;three&quot;);</div><div class="line">		addOrder(&quot;one&quot;);</div><div class="line">		addOrder(&quot;two&quot;);</div><div class="line">		addOrder(&quot;three&quot;);</div><div class="line">		addOrder(&quot;two&quot;);</div><div class="line">		addOrder(&quot;two&quot;);</div><div class="line">		for (Order order : orders) &#123;</div><div class="line">			order.sell();</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;一共&quot; + orders.size());</div><div class="line">		System.out.println(&quot;生成&quot; + factory.instance.getTotalSize() + &quot;个对象&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。<br>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式一]]></title>
      <url>http://yoursite.com/2016/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80/</url>
      <content type="html"><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>应用：使用单例模式去读取配置文件。如果在系统运行过程中有很多都需要使用配置文件的内容，也就是说很多地方都需要创建AppConfig对象的实例，这样每一个AppConfig实例对象里面都封装着配置文件的内容，系统中会同时存在多份配置文件的内容，浪费内存资源。此时应该使用单例，系统中保存一份对象。</p>
<h5 id="单例模式特点"><a href="#单例模式特点" class="headerlink" title="单例模式特点"></a>单例模式特点</h5><p>1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。<br>2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。<br>3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private static class SingletonFactory&#123;</div><div class="line">	private static Singleton instance = new Singleton();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static Singleton getInstance()&#123;</div><div class="line">	return SingletonFactory.instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class SingletonReadConfig &#123;</div><div class="line">	private static SingletonReadConfig instance = null;</div><div class="line">	private SingletonReadConfig()&#123;&#125;</div><div class="line">	public static SingletonReadConfig getInstance()&#123;</div><div class="line">		if(instance == null)&#123;</div><div class="line">			synchronized (SingletonReadConfig.class) &#123;</div><div class="line">				if(instance == null)&#123;</div><div class="line">					instance = new SingletonReadConfig();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">	public void readConfig()&#123;</div><div class="line">		Properties p = new Properties();</div><div class="line">		try &#123;</div><div class="line">			p.load(new InputStreamReader(SingletonReadConfig.class.getResourceAsStream(&quot;test.properties&quot;), &quot;utf8&quot;));</div><div class="line">		&#125; catch (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		String newUrlkey = &quot;xxxx.db.url&quot;;</div><div class="line">		String newUserkey = &quot;xxxx.db.username&quot;;</div><div class="line">		String newPasswordkey = &quot;xxxx.db.password&quot;;</div><div class="line"></div><div class="line">		String url = p.getProperty(newUrlkey);</div><div class="line">		String user = p.getProperty(newUserkey);</div><div class="line">		String password = p.getProperty(newPasswordkey);</div><div class="line">		System.out.println(url+&quot;\t&quot;+user+&quot;\t&quot;+password+&quot;\t&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>静态内部类实现单例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class SingletonReadConfig &#123;</div><div class="line">	static  class SingletonHolder&#123;</div><div class="line">		private static SingletonReadConfig instance = new SingletonReadConfig();</div><div class="line">	&#125;</div><div class="line">	private SingletonReadConfig()&#123;&#125;</div><div class="line"></div><div class="line">	public static SingletonReadConfig getInstance()&#123;</div><div class="line">		return SingletonHolder.instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当getInstance第一次被调用时，第一次读取 SingletonHolder.instance,导致SingletonHolder类得到初始化，这个类在初始化的时候，会初始化它的静态域，从而创建SingletonReadConfig的实例，静态域只会在虚拟机装在类的时候初始化一次，并由虚拟机来保证它的线程安全性。</p>
<p>枚举类实现单例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public enum SingletonReadConfig &#123;</div><div class="line">	instance;</div><div class="line">	public void readConfig()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>单例模式优点：<ol>
<li>在内存中只有一个实例，减少了内存消耗，特别是一个对象如果要频繁的被创建、销毁时，单例优势明显</li>
<li>当一个兑现共产生需要较多资源，读取配置、产生其他依赖对象时</li>
<li>避免对资源的多重占用，如一个写文件动作，由于只有一个实例存在内存，避免了对同一个资源文件的同时写操作</li>
<li>可以在系统设置全局的访问点，优化共享资源的访问，比如可以设计一个单例类，负责所有数据表的映射处理。</li>
</ol>
</li>
<li>单例模式缺点：<ol>
<li>扩展困难，若要扩展，只能修改源码，与单一职责冲突</li>
</ol>
</li>
<li>使用场景<ol>
<li>要求生成唯一序列号的环境</li>
<li>在整个项目中需要有访问一个共享访问点或共享数据，例如web页面上的计数器，可以不用每次刷新都记录到数据库中，使用单例保持计数器的值</li>
<li>创建一个对象需要消耗的资源过多，如要访问I/O，访问数据库等资源</li>
<li>需要定义大量的静态常量和静态方法。当然，也可以直接声明为static方式。</li>
</ol>
</li>
<li>单例适用场景<br>控制资源的使用，通过线程同步来控制资源的并发访问<br>控制实例的产生，以达到节约资源的目的<br>控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li>
</ul>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>指挥者类中可以注入一个抽象建造者类型的对象，核心在与提供一个建造方法，该方法调用了builder对象构造部件的方法，最后返回一个产品对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">// 要生产的产品</div><div class="line">public class Car &#123;</div><div class="line">	private String head;</div><div class="line">	private String body;</div><div class="line">	private String tail;</div><div class="line">&#125;</div><div class="line">// 抽象的建造者</div><div class="line">public abstract class CarBuilder &#123;</div><div class="line">	public abstract void makeHead();</div><div class="line">	public abstract void makeBody();</div><div class="line">	public abstract void makeTail();</div><div class="line">	public abstract Car getCar();</div><div class="line">&#125;</div><div class="line">// 具体建造者</div><div class="line">public class JeepBuilder extends CarBuilder &#123;</div><div class="line">	Car car = new Car();</div><div class="line">	@Override</div><div class="line">	public void makeHead() &#123;</div><div class="line">		car.setHead(&quot;head&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void makeBody() &#123;</div><div class="line">		car.setBody(&quot;body&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void makeTail() &#123;</div><div class="line">		car.setTail(&quot;tail&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public Car getCar() &#123;</div><div class="line">		return car;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 指挥类</div><div class="line">public class CarDirector &#123;</div><div class="line">	public void makeCar(CarBuilder builder)&#123;</div><div class="line">		builder.makeHead();</div><div class="line">		builder.makeBody();</div><div class="line">		builder.makeTail();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 测试</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">		CarDirector director = new CarDirector();</div><div class="line">		CarBuilder jeepBuilder = new JeepBuilder();</div><div class="line">		director.makeCar(jeepBuilder);</div><div class="line">		Car car = jeepBuilder.getCar();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>建造者模式与工厂模式的区别：工厂模式只关心你要的是什么，不关心这个东西的具体细节是什么。而建造者关心的是这个东西的具体细节的创建。<br>note:若要返回调用链式的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public RaceBuilder setSkin(String skinColor)&#123;</div><div class="line">	this.skinColor = skinColor;</div><div class="line">	return this; // 返回一个可以继续操作的该类对象</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>建造者模式的优点</p>
<ol>
<li>封装性，客户端不必知道产品内部组成的细节，不需要关心模型内部是如何实现的</li>
<li>建造者独立，容易扩展</li>
<li>便于控制细节和风险，建造者独立，因此可以对建造过程进行细化，而不对其他的模块产生任何影响</li>
</ol>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式能够将一个原型对象传给那个要发动创建的兑对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。<br>能够实现拷贝的java类必须实现一个标志接口 Cloneable，表示java类支持被复制。<br>java中的clone方法满足下列关系：</p>
<ol>
<li>对于任何对象，都有x.clone()!=x</li>
<li>对于任何对象，都有x.clone.getClass()==x.getClass(),即拷贝对象与原型对象的类型一样</li>
<li>如果对x的equals方法定义恰当，x.clone.equals(x)应该成立。</li>
</ol>
<p>为了获取一份对象的拷贝，可以直接利用Object类的clone方法</p>
<ol>
<li>在派生类中覆盖基类的clone()方法，并声明为public</li>
<li>在派生类的clone()方法中，调用super.clone()</li>
<li>派生类需要实现Cloneable接口<ul>
<li>深拷贝与浅拷贝<br>浅拷贝是指背靠背对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。<br>深拷贝是指拷贝对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量，那些引用其他对象的变量将指向被拷贝的新对象，而不再是原有的那些被引用的对象。深拷贝把重复的对象所引用的对象都拷贝了一遍。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Thing implements Cloneable&#123;</div><div class="line">	private ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">	public Thing clone()&#123;</div><div class="line">		Thing thing = null;</div><div class="line">		try &#123;</div><div class="line">			thing = (Thing) super.clone();</div><div class="line">			// 加上这一句为深拷贝，复制链表</div><div class="line">			thing.list = (ArrayList&lt;String&gt;) this.list.clone();</div><div class="line">		&#125; catch (CloneNotSupportedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		return thing;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>Object类的clone方法的原理是从内存中（具体的说是堆内存）以二进制流的方式进行拷贝，重新分配一个内存块，所以构造函数没有被执行<br>深拷贝的实现： 可以通过序列化等方式来实现深拷贝。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而源对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制器引用的成员对象，因此通过序列化将对象写到流中，再从流里将其读出来，可以实现深拷贝。<br>注意：能够实现序列化的对象必须实现Serializable接口，否则无法进行序列化操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public YueLog deepClone() throws IOException, ClassNotFoundException&#123;</div><div class="line">		ByteArrayOutputStream bao = new ByteArrayOutputStream();</div><div class="line">		ObjectOutputStream oos = new ObjectOutputStream(bao);</div><div class="line">		oos.writeObject(this);</div><div class="line">		ByteArrayInputStream bis = new ByteArrayInputStream(bao.toByteArray());</div><div class="line">		ObjectInputStream ois = new ObjectInputStream(bis);</div><div class="line">		return (YueLog) ois.readObject();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>原型模式的优点</p>
<ol>
<li>性能优良，原型模式是内存二进制流的拷贝，要比直接new一个对象性能好得多，特别是要在一个循环体内产生大量的对象时，原型模式性能更好</li>
<li>避免构造函数约束。直接在内存中拷贝，构造函数不会被执行。<ul>
<li>使用场景</li>
</ul>
</li>
<li>资源优化场景，类初始化需要消耗非常多的资源，包括数据、硬件资源等。</li>
<li>性能和安全要求的场景<br>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</li>
<li>一个对象多个修改者的场景<br>各个调用者可能都需要修改其值时考虑使用原型模式拷贝多个对象供调用者使用。</li>
</ol>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器的角色用于u扩展源角色，实现目标角色</p>
<ul>
<li><p>类的适配器模式，采用继承实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Adaptee &#123;</div><div class="line">	public int get220V()&#123;</div><div class="line">		return 220;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface Target &#123;</div><div class="line">	int get110V();</div><div class="line">	int get220V();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Adapter extends Adaptee implements Target&#123;</div><div class="line">	@Override</div><div class="line">	public int get110V() &#123;</div><div class="line">		return 110;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Client().test();</div><div class="line">	&#125;</div><div class="line">	public void test()&#123;</div><div class="line">		Target target = new Adapter();</div><div class="line">		int v1 = target.get110V();</div><div class="line">		int v2 = target.get220V();</div><div class="line">		System.out.println(&quot;v1=&quot;+v1+&quot;,v2=&quot;+v2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对象适配器，采用对象组合方式<br>把“源”作为一个对象聚合到适配器类中,把“源”作为一个构造参数传入适配器，执行接口所要求的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Adapter implements Job&#123;</div><div class="line">	Person person;</div><div class="line">	public Adapter(Person person)&#123;</div><div class="line">		this.person = person;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void speekJapanese() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		person.speekJapanese();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void speekEnglish() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		person.speekEnglish();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void speekFrench() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		System.out.println(&quot;person French&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>默认适配器模式<br>当我们想实现一个接口，但又不想实现所有接口方法，而只想去实现一部分方法时，就使用默认的适配器模式。它的方式是在接口和具体实现类中添加一个抽象类，而用抽象类去实现目标接口的所有方法，而具体的类只需要覆盖其需要完成的方法即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public interface Job&#123;</div><div class="line">	public abstract void speekJapanese();</div><div class="line">	public abstract void speekEnglish();</div><div class="line">	public abstract void speekFrench();</div><div class="line">	public abstract void speekChinese();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class JobDefault implements Job&#123;</div><div class="line">	public void speekChinese()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public void speekEnglish()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public void speekFrench()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public void speekJapanese()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class JobImpl extends JobDefault&#123;</div><div class="line">	public void speekChinese()&#123;</div><div class="line">		System.out.println(&quot;I can speek Chinese&quot;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>各个设计模式之间的关系总览<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-29/69394885.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大数据相关]]></title>
      <url>http://yoursite.com/2016/04/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h3 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h3><p>对于时间问题，可以采用巧妙的算法搭配合适的数据结构（如布隆  ，使同一个元素只出现在单独的一台电脑中，然后按照1)求解</p>
<h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map/Reduce"></a>Map/Reduce</h3><p>MapReduce借鉴了函数式程序设计语言的思想，通过Map函数将数据映射到不同的区块，分配给计算机集群处理，以达到分布式计算的效果，再通过Reduce函数的程序将结果汇总，从而输出需要的结果。软件实现是指定一个Map函数，把键值对映射成新的键值对，形成一系列中间结果构成的键值对，然后把他们传给Reduce函数，把具有相同中间形式的键值对合并在一起。Map函数和Reduce函数具有一定的关联性。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>实际上是一个很长的二进制向量和一系列随机映射函数。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率<br>就是使用多个 Hash，如果它们有一个说元素不在集合中，那肯定就不在。如果它们都说在，虽然也有一定可能性它们在说谎，不过直觉上判断这种事情的概率是比较低的。<br>优点：相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数。另外, Hash 函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。<br><strong> Bloom Filter 用例 </strong><br>Google 著名的分布式数据库 Bigtable 使用了布隆过滤器来查找不存在的行或列，以减少磁盘查找的IO次数<br>Squid 网页代理缓存服务器在 cache digests 中使用了也布隆过滤器<br>Venti 文档存储系统也采用布隆过滤器来检测先前存储的数据<br>SPIN 模型检测器也使用布隆过滤器在大规模验证问题时跟踪可达状态空间<br>Google Chrome浏览器使用了布隆过滤器加速安全浏览服<br><strong> 布隆过滤器的典型使用 </strong><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-19/56196771.jpg" alt="布隆过滤器"></p>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>Trie树的核心思想是以空间换时间，利用字符串的公共前缀来降低查询时间的开销，以达到提高效率的目的。</p>
<ol>
<li>根节点不包含字符，除根节点以外每一个节点都只包含一个字符</li>
<li>从根节点到某一节点的路径上经过的字符连接起来，即为该节点对应的字符串<br>3.每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>InnoDB存储引擎的B树索引使用的存储结构就是B+树。B+树在B树的基础上做了改造，在每一个叶节点上除了存放索引键的相关信息外，还存储了指向与该叶节点相邻的后一个叶节点的指针，可以加快检索多个相邻叶节点的效率。</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>正向索引是文档指向了它包含的那些单词；反向索引则是单词指向了包含它的文档。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[排序算法的稳定性]]></title>
      <url>http://yoursite.com/2016/04/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>稳定排序和不稳定排序</p>
<blockquote>
<p>这几天笔试了好几次了，连续碰到一个关于常见排序算法稳定性判别的问题，往往还是多选，对于我以及和我一样拿不准的同学可不是一个能轻易下结论的题目，当然如果你笔试之前已经记住了数据结构书上哪些是稳定的，哪些不是稳定的，做起来应该可以轻松搞定。本文是针对老是记不住这个或者想真正明白到底为什么是稳定或者不稳定的人准备的。<br>首先，排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。<br>其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，对基于比较的排序算法而言，元素交换的次数可能会少一些（个人感觉，没有证实）。</p>
</blockquote>
<p>回到主题，现在分析一下常见的排序算法的稳定性，每个都给出简单的理由。</p>
<p>(1)冒泡排序</p>
<p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p>
<p>(2)选择排序</p>
<p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<p>(3)插入排序<br>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<p>(4)快速排序<br>快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j，交换a[i]和a[j],重复上面的过程，直到i &gt; j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p>
<p>(5)归并排序<br>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p>
<p>(6)基数排序<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。</p>
<p>(7)希尔排序(shell)<br>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
<p>(8)堆排序<br>我们知道堆的结构是节点i的孩子为2 <em> i和2 </em> i + 1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， … 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p>
<p>综上，得出结论: 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法<br>PS: 快[快速排序]些[希尔排序]选[选择排序]一堆[堆排序]不稳定排序</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[六大原则]]></title>
      <url>http://yoursite.com/2016/04/16/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>高内聚，低耦合。每一个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个。将不同的职责分别进行封装，不要将其组合在一个勒种，要使这个类只有一个可能会以前它变化的原因。</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>在里氏替换原则中，所有引用基类的地方必须能够透明的使用其子类对象，也就是说只要父类出现的地方，子类就能出现，而且替换为子类不会产生任何错误或异常。但是反过来，子类出现的地方，替换为父类就可能出现问题了。<br>四层含义：</p>
<ol>
<li>子类必须完全实现父类的方法</li>
<li>子类可以有自己的特性</li>
<li>覆盖或者实现父类的方法时输入参数可以被放大</li>
<li>覆写或者实现父类的方法时输出结果可以被缩小<h3 id="依赖注入原则"><a href="#依赖注入原则" class="headerlink" title="依赖注入原则"></a>依赖注入原则</h3>要依赖于抽象，不要依赖于具体的实现（依赖反转原则）<br>三点说明：</li>
<li>高层模块不应该依赖底层模块，两者都应该依赖于抽象（抽象类或接口）</li>
<li>抽象（抽象类或接口）不应该依赖于细节（具体实现类）</li>
<li>细节（具体实现类）应该依赖抽象<br>依赖注入原则用如下三种方式来实现：</li>
<li>通过构造函数传递依赖对象</li>
<li>通过setter方法传递依赖对象</li>
<li>接口声明实现依赖对象<h3 id="接口分离原则"><a href="#接口分离原则" class="headerlink" title="接口分离原则"></a>接口分离原则</h3>不应该强迫客户端程序依赖他们不需要使用的方法，一个接口不需要提供太多的方法，应该只提供一种对外的功能</li>
<li>接口尽量小，保证一个接口只服务于一个子模块或业务逻辑</li>
<li>接口高内聚：接口高内聚是对内高度依赖，对外尽可能隔离。<h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3>降低各个对象之间的耦合，提高系统的可维护性，在模块之间，应该只通过接口来通信，不用理会模块的内部工作原理，降低耦合度，促进复用。<h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4>一个对象对扩展开放，对修改关闭。<br>一旦写出了可以运行的代码，就不应该去改变它，而是要保证它能一直运行下去，如何保证这一点？ 这就需要借助抽象和多态，把科恩给你变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现层则是可以改变和扩展的。<br>eg:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public interface IFindGirl &#123;</div><div class="line">	public int getAge();</div><div class="line">	public String getName();</div><div class="line">	public String getFace();</div><div class="line">	public String getFigure();</div><div class="line">&#125;</div><div class="line">public class FindGirl implements IFindGirl&#123;</div><div class="line"></div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	private String face;</div><div class="line">	private String figure;</div><div class="line">	public FindGirl(String name,int age,String face,String figure)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">		this.face = face;</div><div class="line">		this.figure = figure;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String getFace() &#123;</div><div class="line">		return face;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String getFigure() &#123;</div><div class="line">		return figure;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong> 现在想要增加一个country的属性 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">接口继承接口</div><div class="line">public interface IForeignGirl extends IFindGirl&#123;</div><div class="line">	public String getCountry();</div><div class="line">&#125;</div><div class="line">public class ForeignGirl implements IForeignGirl &#123;</div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	private String face;</div><div class="line">	private String figure;</div><div class="line">	private String country;</div><div class="line">	public ForeignGirl(String name,int age,String face,String figure,String country)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">		this.face = face;</div><div class="line">		this.figure = figure;</div><div class="line">		this.country = country;</div><div class="line">	&#125;</div><div class="line">	get...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>抽象类可以有构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class AMan &#123;</div><div class="line">	protected IPrettyGirl prettyGirl;</div><div class="line">	public AMan(IPrettyGirl prettyGirl)&#123;</div><div class="line">		this.prettyGirl = prettyGirl;</div><div class="line">	&#125;</div><div class="line">	public abstract void findGirl();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java面试问题总结]]></title>
      <url>http://yoursite.com/2016/04/16/java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h4 id="java锁类型"><a href="#java锁类型" class="headerlink" title="java锁类型"></a>java锁类型</h4><ul>
<li>自旋锁，为解决由用户态和内核态的频繁切换以及线程上下文切换开销比较大引入自旋锁。问题：ABA,单核无效。解决：AtomicStampedReference将更新一个“对象 —-引用”二元组，通过在引用上加上“版本号”，从而避免ABA问题。</li>
<li>可重入锁，可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。<br>在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁。可重入锁最大的作用是避免死锁。</li>
<li>阻塞锁，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字，ReentrantLock，Object.wait()\notify(),LockSupport.park()/unpark()。阻塞锁的优势在于，阻塞的线程不会占用cpu时间， 不会导致 CPU占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。</li>
</ul>
<h4 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h4><p>(主内存、工作内存、交互、八种操作lock,unlock、重排序三类)</p>
<ol>
<li>从主存复制变量到当前工作内存 (read and load)</li>
<li>执行代码，改变共享变量 (use and assign)</li>
<li>用工作内存数据刷新主存相关的内容 (store and write)</li>
</ol>
<h4 id="进程线程管程区别"><a href="#进程线程管程区别" class="headerlink" title="进程线程管程区别"></a>进程线程管程区别</h4><ul>
<li>进程 ：一个程序在一个数据集合上的一次运行过程，是资源分配的最小单位，进程无法突破进程边界存取其他进程内的存储空间</li>
<li>线程 ：线程是进程中的一个实体，是被系统独立调度和执行的最小单位，同一进程所产生的线程共享同一内存空间。</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>产生死锁的条件：互斥、请求与保持、不剥夺条件、循环等待条件<br><em>解除与预防</em><br>1.采用资源静态分配策略，破坏”部分分配”条件<br>2.允许进程剥夺使用其他进程占有的资源，破坏不可剥夺条件<br>3.采用资源有序分配法，破坏环路条件</p>
<h4 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><p>1.聚集索引的顺序就是数据的物理存储顺序，非聚集索引的索引顺序与物理顺序无关。<br>2.一个表只能包含一个聚集索引，可以有多个非聚集索引<br>3.聚集索引对于那些经常要搜索范围值的列有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻<br>4.非索引存储中的项目按索引键值的顺序存储，而表中信息按另一种顺序存储。</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>1.为避免其他程序创建该类对象，将构造函数私有化<br>2.为了其他程序访问到该类对象，须在本类中创建一个该类私有对象<br>3.为了方便其他程序访问该类对象，可对外提供一个公共访问方式<br>比如API中的Runtime类就是单例设计模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Singleton&#123;</div><div class="line">	private static Singleton instance;</div><div class="line">	private static byte[] lock = new byte[1];</div><div class="line">	private Singleton&#123; &#125;</div><div class="line">	public static Singleton getInstance()&#123;</div><div class="line">		if(instance == null)&#123;</div><div class="line">			synchronized(lock)&#123;</div><div class="line">				if(instance == null) &#123;</div><div class="line">					instance = new Singleton();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><ol>
<li>final修饰变量：final修饰的变量只能被赋值一次，可以是在声明的时候进行初始化，也可以是在初始化函数中进行初始化，基本数据类型在赋值后它的值无法改变，如果是一个对象的引用则不能再指向其它对象，但是这个对象的值是可以改变的。比如一个指向StringBuilder的对象A，A不能再被赋值，但是这个StringBuilder对象的值是可以改变的。</li>
<li>final修饰的方法：final修饰的方法不能被子类重写</li>
<li>final修饰的类：final修饰的类不能被继承，也就是说它所有的实现都不能被改变，方法不能被重写。常用于设计一些不想让使用者改变的类。</li>
</ol>
<h4 id="fail-fast-amp-amp-fail-safe"><a href="#fail-fast-amp-amp-fail-safe" class="headerlink" title="fail-fast &amp;&amp; fail-safe"></a>fail-fast &amp;&amp; fail-safe</h4><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：<br>注意到modCount声明为volatile，保证线程之间修改的可见性。</p>
<h4 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h4><ul>
<li>新生代，新生区是类的诞生、成长、消亡的区域，一个类在这里产生、应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区和幸存者区，所有的类都是在伊甸区被创建的，幸存区有两个：0区（Survivor 0）和1区(Survivor 1)。当伊甸区的空间用完，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收，将伊甸区中的不再被其他对象所引用的对象进行销毁。然后将伊甸区中的剩余对象移动到幸存0区，若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区，如果1区也满了，就移动到老年区。</li>
<li>老年代，用于保存从新生区筛选出来的java对象，一般池对象都在这个区域活跃。</li>
<li>永久代 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class Interface 的元数据，也就是说，它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被回收器回收的，关闭JVM才会释放此区域所占用的内存。</li>
</ul>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul>
<li>标记-清除算法<br>首先标记出所有需要回收的对象，在标完成后统一回收掉所有被标记的对象。缺点：效率不高，且标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致运行过程中需要分配大对象的时候无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
<li>复制算法<br>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清理掉，内存使用率不高，现在商业虚拟机比如HotSpot都采用8:1的比例（Eden:Survivor）</li>
<li>标记-整理算法<br>把存活对象往内存的一端移动，然后直接回收边界以外的内存，提高了内存利用率，适合在收集对象存活时间较长的老年代。</li>
<li>分代收集算法<br>根据对象的存活时间把内存分为新生代和老年代，根据各代对象的存活特点，每个代采用不同的垃圾回收算法，新生代采用标记-复制算法，老年代采用标记-整理算法。</li>
</ul>
<h4 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h4><p>transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。</p>
<h4 id="重写equals方法"><a href="#重写equals方法" class="headerlink" title="重写equals方法"></a>重写equals方法</h4><p>1.使用==符号检查“参数是否为这个对象的引用”。如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。<br>2.使用instanceof操作符检查“参数是否为正确的类型”。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。<br>3.把参数转换成正确的类型。因为转换之前进行过instanceof测试，所以确保会成功。<br>4.对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回true;否则返回false。<br>5.当编写完成了equals方法之后，检查“对称性”、“传递性”、“一致性”。</p>
<h4 id="重写hashCode的意义"><a href="#重写hashCode的意义" class="headerlink" title="重写hashCode的意义"></a>重写hashCode的意义</h4><ol>
<li>在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。</li>
<li>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li>
<li>如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。</li>
<li>如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。</li>
</ol>
<h4 id="JVM-运行时数据区-JVM-Runtime-Area"><a href="#JVM-运行时数据区-JVM-Runtime-Area" class="headerlink" title="JVM 运行时数据区 (JVM Runtime Area)"></a>JVM 运行时数据区 (JVM Runtime Area)</h4><p>6个区域：<br>1、PC程序计数器：一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器, NAMELY存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。Java 的多线程机制离不开程序计数器，每个线程都有一个自己的PC，以便完成不同线程上下文环境的切换。<br>2、java虚拟机栈：与 PC 一样，java 虚拟机栈也是线程私有的。每一个 JVM 线程都有自己的 java 虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈<br>帧在虚拟机栈中从入栈到出栈的过程。<br>3、本地方法栈：与虚拟机栈的作用相似，虚拟机栈为虚拟机执行执行java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务。<br>4、Java堆：被所有线程共享的一块存储区域，在虚拟机启动时创建，它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。<br>Java堆在JVM启动的时候就被创建，堆中储存了各种对象，这些对象被自动管理内存系统（Automatic Storage Management System，也即是常说的 “Garbage Collector（垃圾回收器）”）所管理。这些对象无需、也无法显示地被销毁。<br>JVM将Heap分为两块：新生代New Generation和旧生代Old Generation<br><strong> 堆在JVM是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是new开销比较大的原因 </strong><br>5、方法区<br>方法区和堆区域一样，是各个线程共享的内存区域，它用于存储每一个类的结构信息，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。当开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。<br>方法区也是全局共享的，在虚拟机启动时候创建。在一定条件下它也会被GC。这块区域对应Permanent Generation 持久代。<br>6、运行时常量池其空间从方法区中分配，存放的为类中固定的常量信息、方法和域的引用信息。</p>
<h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><p>1.降低资源消耗，重用已经创建好的线程，降低创建和销毁的开销<br>2.提高响应速度，不用等待创建线程就能立即执行<br>3.提高线程的可管理性，统一分配、调优和监控<br>4.防止服务器过载，防止内存溢出或者CPU耗尽</p>
<h4 id="简单工厂-工厂方法-抽象工厂"><a href="#简单工厂-工厂方法-抽象工厂" class="headerlink" title="简单工厂 工厂方法 抽象工厂"></a>简单工厂 工厂方法 抽象工厂</h4><ul>
<li>简单工厂: 抽象了同一类型(比如不同品牌的笔记本电脑)产品的生产过程,通过工厂类来实现对不同产品生产过程的选择</li>
<li>工厂方法: 不仅抽象了产品类的生产过程,还抽象了工厂类本身. 将特定的产品的生产过程和特定的工厂相对应. 将原先工厂类中的选择提升到工程类以上的层级—即客户层级. 通过选择特定的工厂,来选择生产特定的产品.</li>
<li>抽象工厂: 在工厂方法的基础上,将特定的产品生产过程和特定的工厂类之间的对应关系解除,使得工厂类和产品类之间能够产生更多灵活的组合方式.</li>
</ul>
<h4 id="对象引用的类型"><a href="#对象引用的类型" class="headerlink" title="对象引用的类型"></a>对象引用的类型</h4><ul>
<li>Reference(or named Strong Reference)（ 强引用）：普通类型的引用。</li>
<li>SoftReference（ 软引用）：被这种引用指向的对象，如果此对象没要再被其他Strong Reference引用的话，可能在任何时候被GC。虽然是可能在任何时候被GC，但是通常是在可用内存数比较低的时候，并且在程序抛出OutOfMemoryError之前才发生对此对象的GC。SoftReference通常被用作实现Cache的对象引用，如果这个对象被GC了，那么他可以在任何时候再重新被创建。另外，根据JDK文档中介绍，实际JVM的实现是鼓励不回收最近创建和最近使用的对象。SoftReference 类的一个典型用途就是用于内存敏感的高速缓存。</li>
<li>WeakReference（弱引用）：如果一个被WeakReference引用的对象，当没要任何SoftReference和StrongReference引用时，立即会被GC。和SoftReference的区别是：WeakReference对象是被eagerly collected，即一旦没要任何SoftReference和StrongReference引用，立即被清楚；而只被SoftReference引用的对象，不回立即被清楚，只有当内存不够，即将发生OutOfMemoryError时才被清除，而且是先清除不常用的。SoftReference适合实现Cache用。WeakReference 类的一个典型用途就是规范化映射（ canonicalized mapping ）</li>
<li>PhantomReference（虚引用）：当没有StrongReference，SoftReference和WeakReference引用时，随时可被GC。通常和ReferenceQueue联合使用，管理和清除与被引用对象（没有finalize方法）相关的本地资源。</li>
</ul>
<h4 id="五层协议的网络体系结构"><a href="#五层协议的网络体系结构" class="headerlink" title="五层协议的网络体系结构"></a>五层协议的网络体系结构</h4><ol>
<li>物理层，物理层任务是透明传输比特流。</li>
<li>数据链路层，将网络层交下来的IP数据包组装成帧，在两个相邻节点间的链路上透明的传输帧中的数据，每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）</li>
<li>网络层，把运输层产生的报文段封装成分组或包进行传送</li>
<li>运输层，负责向两个主机中进程之间的通信提供服务，运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务，分用则是运输层把收到的信息分别交付上面应用层中的相应进程。</li>
<li>应用层，直接为用户的应用进程提供服务。</li>
</ol>
<p>title: java面试问题总结<br>date: 2016-04-16 12:09:00<br>categories: [java,面试]</p>
<h2 id="tags-java-面试"><a href="#tags-java-面试" class="headerlink" title="tags: [java,面试]"></a>tags: [java,面试]</h2><h4 id="java锁类型-1"><a href="#java锁类型-1" class="headerlink" title="java锁类型"></a>java锁类型</h4><ul>
<li>自旋锁，为解决由用户态和内核态的频繁切换以及线程上下文切换开销比较大引入自旋锁。问题：ABA,单核无效。解决：AtomicStampedReference将更新一个“对象 —-引用”二元组，通过在引用上加上“版本号”，从而避免ABA问题。</li>
<li>可重入锁，可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。<br>在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁。可重入锁最大的作用是避免死锁。</li>
<li>阻塞锁，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字，ReentrantLock，Object.wait()\notify(),LockSupport.park()/unpark()。阻塞锁的优势在于，阻塞的线程不会占用cpu时间， 不会导致 CPU占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。</li>
</ul>
<h4 id="java内存模型-1"><a href="#java内存模型-1" class="headerlink" title="java内存模型"></a>java内存模型</h4><p>(主内存、工作内存、交互、八种操作lock,unlock、重排序三类)</p>
<ol>
<li>从主存复制变量到当前工作内存 (read and load)</li>
<li>执行代码，改变共享变量 (use and assign)</li>
<li>用工作内存数据刷新主存相关的内容 (store and write)</li>
</ol>
<h4 id="进程线程管程区别-1"><a href="#进程线程管程区别-1" class="headerlink" title="进程线程管程区别"></a>进程线程管程区别</h4><ul>
<li>进程 ：一个程序在一个数据集合上的一次运行过程，是资源分配的最小单位，进程无法突破进程边界存取其他进程内的存储空间</li>
<li>线程 ：线程是进程中的一个实体，是被系统独立调度和执行的最小单位，同一进程所产生的线程共享同一内存空间。</li>
</ul>
<h4 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h4><p>产生死锁的条件：互斥、请求与保持、不剥夺条件、循环等待条件<br><em>解除与预防</em><br>1.采用资源静态分配策略，破坏”部分分配”条件<br>2.允许进程剥夺使用其他进程占有的资源，破坏不可剥夺条件<br>3.采用资源有序分配法，破坏环路条件</p>
<h4 id="聚集索引和非聚集索引-1"><a href="#聚集索引和非聚集索引-1" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><p>1.聚集索引的顺序就是数据的物理存储顺序，非聚集索引的索引顺序与物理顺序无关。<br>2.一个表只能包含一个聚集索引，可以有多个非聚集索引<br>3.聚集索引对于那些经常要搜索范围值的列有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻<br>4.非索引存储中的项目按索引键值的顺序存储，而表中信息按另一种顺序存储。</p>
<h4 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h4><p>1.为避免其他程序创建该类对象，将构造函数私有化<br>2.为了其他程序访问到该类对象，须在本类中创建一个该类私有对象<br>3.为了方便其他程序访问该类对象，可对外提供一个公共访问方式<br>比如API中的Runtime类就是单例设计模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Singleton&#123;</div><div class="line">	private static Singleton instance;</div><div class="line">	private static byte[] lock = new byte[1];</div><div class="line">	private Singleton&#123; &#125;</div><div class="line">	public static Singleton getInstance()&#123;</div><div class="line">		if(instance == null)&#123;</div><div class="line">			synchronized(lock)&#123;</div><div class="line">				if(instance == null) &#123;</div><div class="line">					instance = new Singleton();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="单例适用场景"><a href="#单例适用场景" class="headerlink" title="单例适用场景"></a>单例适用场景</h4><p>控制资源的使用，通过线程同步来控制资源的并发访问<br>控制实例的产生，以达到节约资源的目的<br>控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</p>
<h4 id="final关键字-1"><a href="#final关键字-1" class="headerlink" title="final关键字"></a>final关键字</h4><ol>
<li>final修饰变量：final修饰的变量只能被赋值一次，可以是在声明的时候进行初始化，也可以是在初始化函数中进行初始化，基本数据类型在赋值后它的值无法改变，如果是一个对象的引用则不能再指向其它对象，但是这个对象的值是可以改变的。比如一个指向StringBuilder的对象A，A不能再被赋值，但是这个StringBuilder对象的值是可以改变的。</li>
<li>final修饰的方法：final修饰的方法不能被子类重写</li>
<li>final修饰的类：final修饰的类不能被继承，也就是说它所有的实现都不能被改变，方法不能被重写。常用于设计一些不想让使用者改变的类。</li>
</ol>
<h4 id="fail-fast-amp-amp-fail-safe-1"><a href="#fail-fast-amp-amp-fail-safe-1" class="headerlink" title="fail-fast &amp;&amp; fail-safe"></a>fail-fast &amp;&amp; fail-safe</h4><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：<br>注意到modCount声明为volatile，保证线程之间修改的可见性。</p>
<h4 id="堆内存-1"><a href="#堆内存-1" class="headerlink" title="堆内存"></a>堆内存</h4><ul>
<li>新生代，新生区是类的诞生、成长、消亡的区域，一个类在这里产生、应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区和幸存者区，所有的类都是在伊甸区被创建的，幸存区有两个：0区（Survivor 0）和1区(Survivor 1)。当伊甸区的空间用完，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收，将伊甸区中的不再被其他对象所引用的对象进行销毁。然后将伊甸区中的剩余对象移动到幸存0区，若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区，如果1区也满了，就移动到老年区。</li>
<li>老年代，用于保存从新生区筛选出来的java对象，一般池对象都在这个区域活跃。</li>
<li>永久代 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class Interface 的元数据，也就是说，它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被回收器回收的，关闭JVM才会释放此区域所占用的内存。</li>
</ul>
<h4 id="垃圾收集算法-1"><a href="#垃圾收集算法-1" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul>
<li>标记-清除算法<br>首先标记出所有需要回收的对象，在标完成后统一回收掉所有被标记的对象。缺点：效率不高，且标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致运行过程中需要分配大对象的时候无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
<li>复制算法<br>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清理掉，内存使用率不高，现在商业虚拟机比如HotSpot都采用8:1的比例（Eden:Survivor）</li>
<li>标记-整理算法<br>把存活对象往内存的一端移动，然后直接回收边界以外的内存，提高了内存利用率，适合在收集对象存活时间较长的老年代。</li>
<li>分代收集算法<br>根据对象的存活时间把内存分为新生代和老年代，根据各代对象的存活特点，每个代采用不同的垃圾回收算法，新生代采用标记-复制算法，老年代采用标记-整理算法。</li>
</ul>
<h4 id="transient-1"><a href="#transient-1" class="headerlink" title="transient"></a>transient</h4><p>transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。</p>
<h4 id="重写equals方法-1"><a href="#重写equals方法-1" class="headerlink" title="重写equals方法"></a>重写equals方法</h4><p>1.使用==符号检查“参数是否为这个对象的引用”。如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。<br>2.使用instanceof操作符检查“参数是否为正确的类型”。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。<br>3.把参数转换成正确的类型。因为转换之前进行过instanceof测试，所以确保会成功。<br>4.对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回true;否则返回false。<br>5.当编写完成了equals方法之后，检查“对称性”、“传递性”、“一致性”。</p>
<h4 id="重写hashCode的意义-1"><a href="#重写hashCode的意义-1" class="headerlink" title="重写hashCode的意义"></a>重写hashCode的意义</h4><ol>
<li>在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。</li>
<li>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li>
<li>如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。</li>
<li>如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。</li>
</ol>
<h4 id="JVM-运行时数据区-JVM-Runtime-Area-1"><a href="#JVM-运行时数据区-JVM-Runtime-Area-1" class="headerlink" title="JVM 运行时数据区 (JVM Runtime Area)"></a>JVM 运行时数据区 (JVM Runtime Area)</h4><p>6个区域：<br>1、PC程序计数器：一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器, NAMELY存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。Java 的多线程机制离不开程序计数器，每个线程都有一个自己的PC，以便完成不同线程上下文环境的切换。<br>2、java虚拟机栈：与 PC 一样，java 虚拟机栈也是线程私有的。每一个 JVM 线程都有自己的 java 虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈<br>帧在虚拟机栈中从入栈到出栈的过程。<br>3、本地方法栈：与虚拟机栈的作用相似，虚拟机栈为虚拟机执行执行java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务。<br>4、Java堆：被所有线程共享的一块存储区域，在虚拟机启动时创建，它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。<br>Java堆在JVM启动的时候就被创建，堆中储存了各种对象，这些对象被自动管理内存系统（Automatic Storage Management System，也即是常说的 “Garbage Collector（垃圾回收器）”）所管理。这些对象无需、也无法显示地被销毁。<br>JVM将Heap分为两块：新生代New Generation和旧生代Old Generation<br><strong> 堆在JVM是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是new开销比较大的原因 </strong><br>5、方法区<br>方法区和堆区域一样，是各个线程共享的内存区域，它用于存储每一个类的结构信息，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。当开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。<br>方法区也是全局共享的，在虚拟机启动时候创建。在一定条件下它也会被GC。这块区域对应Permanent Generation 持久代。<br>6、运行时常量池其空间从方法区中分配，存放的为类中固定的常量信息、方法和域的引用信息。</p>
<h4 id="线程池的好处-1"><a href="#线程池的好处-1" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><p>1.降低资源消耗，重用已经创建好的线程，降低创建和销毁的开销<br>2.提高响应速度，不用等待创建线程就能立即执行<br>3.提高线程的可管理性，统一分配、调优和监控<br>4.防止服务器过载，防止内存溢出或者CPU耗尽</p>
<h4 id="简单工厂-工厂方法-抽象工厂-1"><a href="#简单工厂-工厂方法-抽象工厂-1" class="headerlink" title="简单工厂 工厂方法 抽象工厂"></a>简单工厂 工厂方法 抽象工厂</h4><ul>
<li>简单工厂: 抽象了同一类型(比如不同品牌的笔记本电脑)产品的生产过程,通过工厂类来实现对不同产品生产过程的选择</li>
<li>工厂方法: 不仅抽象了产品类的生产过程,还抽象了工厂类本身. 将特定的产品的生产过程和特定的工厂相对应. 将原先工厂类中的选择提升到工程类以上的层级—即客户层级. 通过选择特定的工厂,来选择生产特定的产品.</li>
<li>抽象工厂: 在工厂方法的基础上,将特定的产品生产过程和特定的工厂类之间的对应关系解除,使得工厂类和产品类之间能够产生更多灵活的组合方式.</li>
</ul>
<h4 id="对象引用的类型-1"><a href="#对象引用的类型-1" class="headerlink" title="对象引用的类型"></a>对象引用的类型</h4><ul>
<li>Reference(or named Strong Reference)（ 强引用）：普通类型的引用。</li>
<li>SoftReference（ 软引用）：被这种引用指向的对象，如果此对象没要再被其他Strong Reference引用的话，可能在任何时候被GC。虽然是可能在任何时候被GC，但是通常是在可用内存数比较低的时候，并且在程序抛出OutOfMemoryError之前才发生对此对象的GC。SoftReference通常被用作实现Cache的对象引用，如果这个对象被GC了，那么他可以在任何时候再重新被创建。另外，根据JDK文档中介绍，实际JVM的实现是鼓励不回收最近创建和最近使用的对象。SoftReference 类的一个典型用途就是用于内存敏感的高速缓存。</li>
<li>WeakReference（弱引用）：如果一个被WeakReference引用的对象，当没要任何SoftReference和StrongReference引用时，立即会被GC。和SoftReference的区别是：WeakReference对象是被eagerly collected，即一旦没要任何SoftReference和StrongReference引用，立即被清楚；而只被SoftReference引用的对象，不回立即被清楚，只有当内存不够，即将发生OutOfMemoryError时才被清除，而且是先清除不常用的。SoftReference适合实现Cache用。WeakReference 类的一个典型用途就是规范化映射（ canonicalized mapping ）</li>
<li>PhantomReference（虚引用）：当没有StrongReference，SoftReference和WeakReference引用时，随时可被GC。通常和ReferenceQueue联合使用，管理和清除与被引用对象（没有finalize方法）相关的本地资源。</li>
</ul>
<h4 id="五层协议的网络体系结构-1"><a href="#五层协议的网络体系结构-1" class="headerlink" title="五层协议的网络体系结构"></a>五层协议的网络体系结构</h4><ol>
<li>物理层，物理层任务是透明传输比特流。</li>
<li>数据链路层，将网络层交下来的IP数据包组装成帧，在两个相邻节点间的链路上透明的传输帧中的数据，每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）</li>
<li>网络层，把运输层产生的报文段封装成分组或包进行传送</li>
<li>运输层，负责向两个主机中进程之间的通信提供服务，运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务，分用则是运输层把收到的信息分别交付上面应用层中的相应进程。</li>
<li>应用层，直接为用户的应用进程提供服务。</li>
</ol>
<h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><ol>
<li>select 尽量少用*，只查询需要的列</li>
<li>多表连接时使用别名，提高sql解释效率，减少重名错误</li>
<li>where中把限制条件最大的放前面，利用数据库查询优化器优化</li>
<li>时分秒不必要时，选择Date类型而不是DateTime类型</li>
<li><blockquote>
<p>=比&gt;更容易定位索引</p>
</blockquote>
</li>
<li>like “R%”使用索引，like “%R”不使用索引</li>
<li>在where中尽量使用被索引的列</li>
</ol>
<h4 id="SQL和NoSQL区别"><a href="#SQL和NoSQL区别" class="headerlink" title="SQL和NoSQL区别"></a>SQL和NoSQL区别</h4><blockquote>
<ul>
<li>非关系型数据库的优势：</li>
</ul>
<ol>
<li>性能<br>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li>
<li>可扩展性<br>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li>
</ol>
<ul>
<li>关系型数据库的优势：</li>
</ul>
<ol>
<li>复杂查询<br>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li>
<li>事务支持<br>使得对于安全性能很高的数据访问要求得以实现。</li>
</ol>
</blockquote>
<h4 id="Cookie-amp-amp-Session"><a href="#Cookie-amp-amp-Session" class="headerlink" title="Cookie &amp;&amp; Session"></a>Cookie &amp;&amp; Session</h4><h4 id="Get-amp-amp-Post"><a href="#Get-amp-amp-Post" class="headerlink" title="Get &amp;&amp; Post"></a>Get &amp;&amp; Post</h4><h4 id="事务的四个特点ACID"><a href="#事务的四个特点ACID" class="headerlink" title="事务的四个特点ACID:"></a>事务的四个特点ACID:</h4><p>A:原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。它是一个整体，不能再拆分<br>C：一致性：事务在完成时，必须使所有的数据都保持一致状态。。某种程度的一致<br>I:隔离性：事务中隔离，每一个事务是单独的请求将单独的处理，与其它事务没有关系，互不影响<br>D：持久性：如果事务一旦提交，就对数据的修改永久保留</p>
<h4 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h4><ol>
<li>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li>
<li>类可以实现很多个接口，但是只能继承一个抽象类</li>
<li>类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不4. 实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li>
<li>抽象类可以在不提供接口方法实现的情况下实现接口。</li>
<li>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</li>
<li>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java锁类型]]></title>
      <url>http://yoursite.com/2016/04/15/java%E9%94%81%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁适用于锁竞争不那么激烈的情况，和同步块比较小的情况，由于线程的阻塞和释放都是基于信号量（操作系统课本的汇编示例代码还记得不），并且<br>有用户态和内核态的频繁切换以及线程上下文切换开销比较大，对于前述的两种情况阻塞和释放竞争锁的线程显得没那么的必要，所以引入了自旋锁，但是<br>自旋锁也有不好的地方，ABA问题，单核无效（依赖环境），太依赖于当前线程的执行环境。<br>ABA 问题：在CAS操作中将判断“V的值是否仍然为A？”，并且如果是的话就继续执行更新操作。在大多数情况下，这种判断是足够的。然而，有时候还需要<br>知道 “自从上次看到V的值为A以来，这个值是否发生了变化？”在某些算法中，如果V值首先由A编程B,在由B编程A，那么仍然被认为发生了变化，并需要重新<br>执 行算法中的某些步骤。<br>解决方法： 使用原子工具类 AtomicStampedReference以 及AtomicMarkableReference支持在两个变量上执行原子的条件更新。AtomicStampedReference将<br>更新一个“对象 —-引用”二元组，通过在引用上加上“版本号”，从而避免ABA问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class SpinLock &#123;</div><div class="line">    private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;();</div><div class="line"></div><div class="line">    public void lock()&#123;</div><div class="line">        Thread currentThread = Thread.currentThread();</div><div class="line">        //循环cas来判断锁是否被占用，第一个为期望值，如果为null说明锁未被占用，设置当前线程占用</div><div class="line">        while(owner.compareAndSet(null,currentThread))&#123;</div><div class="line">            //这里一般会调用java.util.concurrent.locks.AbstractOwnableSynchronizer的setExclusiveOwnerThread(Thread t)方法来设置独占锁</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void unlock()&#123;</div><div class="line">        Thread currentThread = Thread.currentThread();</div><div class="line"></div><div class="line">        owner.compareAndSet(currentThread,null);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。<br>在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁<br>可重入锁最大的作用是避免死锁<br>Test1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Test implements Runnable&#123;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		get();</div><div class="line">	&#125;</div><div class="line">	public synchronized void get()&#123;</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">		set();</div><div class="line">	&#125;</div><div class="line">	public synchronized void set()&#123;</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Test test = new Test();</div><div class="line">		new Thread(test).start();</div><div class="line">		new Thread(test).start();</div><div class="line">		new Thread(test).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Test2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class Test implements Runnable&#123;</div><div class="line">	ReentrantLock lock = new ReentrantLock();</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		get();</div><div class="line">	&#125;</div><div class="line">	public void get()&#123;</div><div class="line">		lock.lock();</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">		set();</div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line">	public void set()&#123;</div><div class="line">		lock.lock();</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Test test = new Test();</div><div class="line">		new Thread(test).start();</div><div class="line">		new Thread(test).start();</div><div class="line">		new Thread(test).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">两次输出结果一样，即同一个线程id被连续输出两次</div></pre></td></tr></table></figure></p>
<h3 id="阻塞锁"><a href="#阻塞锁" class="headerlink" title="阻塞锁"></a>阻塞锁</h3><p>能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字，ReentrantLock，Object.wait()\notify(),LockSupport.park()/unpart()<br>阻塞锁的优势在于，阻塞的线程不会占用cpu时间， 不会导致 CPu占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。<br>在竞争激烈的情况下 阻塞锁的性能要明显高于 自旋锁。<br>理想的情况则是; 在线程竞争不激烈的情况下，使用自旋锁，竞争激烈的情况下使用，阻塞锁。</p>
<h3 id="ThreadLocal-用法"><a href="#ThreadLocal-用法" class="headerlink" title="ThreadLocal 用法"></a>ThreadLocal 用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static ThreadLocal&lt;Long&gt; TIME_THRE = new ThreadLocal&lt;Long&gt;()&#123;</div><div class="line">		protected Long initialValue() &#123;</div><div class="line">			return System.currentTimeMillis();</div><div class="line">		&#125;;</div><div class="line">	&#125;;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java开发常用程序库]]></title>
      <url>http://yoursite.com/2016/04/15/java%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>摘自：<a href="http://www.blogbus.com/dreamhead-logs/226738702.html" target="_blank" rel="external">http://www.blogbus.com/dreamhead-logs/226738702.html</a></p>
<p>在很多人眼中，Java已经是一门垂垂老矣的语言，但并不妨碍Java世界依然在前进。如果你曾离开Java，云游于其它世界，或是每日只在遗留代码中挣扎，或许是时候抬起头，看看老Java中的新东西。</p>
<h4 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h4><p>一句话，只要你做Java项目，就应该用Guava。<br>guava是Google出品的一套Java核心库，在我看来，它甚至应该是JDK的一部分。作为一个Java程序员，如果你没抱怨过JDK的设计，只能说明一点，你写得程序还是太少。正是JDK设计不彰，才有了一些项目来补充JDK的不足。如果说老Java程序员应该听说过Apache Commons Lang，那新Java程序员该知道的就是Guava了。<br>下面以一个统计单词出现个数的小程序作为这个段落的结尾，虽然无法与许多其它语言的实现相提并论，但作为一个Java程序员，你不妨想一下按照传统方式，这段代码应该是什么样子。<br>  String content = Files.toString(new File(args[0]), Charset.defaultCharset());<br>  Iterable texts = Splitter.on(CharMatcher.WHITESPACE)<br>                                                 .omitEmptyStrings()<br>                                                 .trimResults()<br>                                                 .split(content);<br>  Multiset collection = HashMultiset.create(texts);</p>
<h4 id="Joda-Time"><a href="#Joda-Time" class="headerlink" title="Joda Time"></a>Joda Time</h4><p>Date firstDayOf2013 = new Date(113, 0, 1);<br>如果你是个Java新手，你能猜出113是从哪来的吗？（好吧，它是2013-1900，至于为什么是1900，这真得问API的设计者了）。<br>Joda Time就是人们实在无法忍受这样东西的产物。同样的代码用Joda Time实现：<br>  DateTime firstDayOf2013 = new DateTime().withDate(2013, 1, 1);<br>无论如何，你知道这能看出这些参数的含义了。不只如此，你还可以计算两天后是什么日子：<br>  firstDate.plusDays(2);<br>日期格式化，也是JDK Date系列API里一大特色，你必须把代码写成下面这样：<br>  new SimpleDateFormat(“yyyy.MM.dd”).format(firstDayOf2013)<br>作为一个初始化很慢的构造函数，你还必须每次调用，因为它不是线程安全的。同样的代码，在Joda Time里，我们可以用DateTimeFormatter：</p>
<p>  DateTimeFormatter formatter = DateTimeFormat.forPattern(“yyyy.MM.dd”);</p>
<p>  …</p>
<p>  formatter.print(dateTime);</p>
<p>请尽管放心大胆把formatter声明成一个字段，因为它是线程安全的。</p>
<p>当然，Joda Time的强大远不止于此。当然，JDK也并不是那么完全的自暴自弃，于是，有了一个JSR 310专门设计新的Date API。JSR 310的spec lead是Steven Colebourne，此人正是Joda Time的作者。不过，虽然JSR 310为我们描绘了Date的全新景象，但Java 8出来之前就先别打它的主意了，乖乖地用Joda Time吧。</p>
<h4 id="Hamcrest"><a href="#Hamcrest" class="headerlink" title="Hamcrest"></a>Hamcrest</h4><p>一句话，如果你写单元测试，就应该用Hamcrest。<br>如今不写单元测试，你都不好意思说自己在做工程项目了。但你一般这么写断言呢？如果你还写成下面这样，我只能说你落伍了：</p>
<p>  assertEquals(a, b);</p>
<p>请告诉我，哪个是执行结果，哪个是预期结果，不管你是怎样，反正大多数情况下，我是记不住的。所以，这个在只重功能不重可读性年代产生的API该更新了。于是，Hamcrest就是为了解决这样的问题而生的。</p>
<p>  assertThat(a, is(b));</p>
<p>很明显，前面一个是执行结果，后面一个是预期结果，当然这只是一个简单的例子。由于Hamcrest引入了matcher的概念（就是你看到的is部分），我们可以进行更多的组合：</p>
<p>  assertThat(number, greaterThan(5));<br>  assertThat(text, startsWith(“Hello”));<br>  assertThat(array, hasItem(“World”));</p>
<p>Hamcrest如此好用，以至于JUnit已经将其吸纳进去。如果你现在用的JUnit是4.4之后的版本，那你已经有了Hamcrest。无需额外的配置，就可以拿过来用。</p>
<h4 id="Mockito"><a href="#Mockito" class="headerlink" title="Mockito"></a>Mockito</h4><p>写单元测试不用Mock框架几乎是一件不可能的事，我是说Mock框架，不是Mock模式哦！对于老Java程序员来说，提起Mock框架，率先在脑海中撞线的多半是JMock或EasyMock。</p>
<p>使用Mockito，只要有一个理由就够了，简单。相比于JMock，它不用写checking，相比于EasyMock，它省去了replay。下面是个例子：</p>
<p>  List mockedList = mock(List.class);<br>  when(mockedList.get(0)).thenReturn(“first”);<br>  System.out.println(mockedList.get(0));</p>
<p>当然，Mockito还是非常强大的。<br>最后再强调一遍，无论使用哪个框架，请尽量不要使用verify，也就是传说中的Mock模式，那是把代码拉入泥潭的开始。</p>
<h4 id="SLF4J和Logback"><a href="#SLF4J和Logback" class="headerlink" title="SLF4J和Logback"></a>SLF4J和Logback</h4><p>日志几乎是稍微有点规模的项目躲不开的一个东西，如果你是个老Java程序员，你必然知道Log4J，多半也知道Commons Logging。是时候把它们扔掉了，因为有SLF4J和Logback了。SLF4J要替代Commons Logging，而Logback的目标是Log4J。<br>只凭一点就足以让我们对SLF4J义无反顾了，你还记得用Commons Logging写出这样的代码吗？</p>
<p>  if (logger.debugEnable()) {<br>    logger.debug(“Hello, “, name);<br>  }</p>
<p>而SLF4J的写法只有一句话：</p>
<p>  logger.debug(“Hello, {}”, name);</p>
<p>从根源来说，这是时代造成的，Commons Logging是Java 5之前产生的，那时候还没有变参，所以，我们不得不说，它老了。</p>
<p>至于Logback，性能是最重要的噱头，当然，还有一些其它的理由。理由里有一点并未提及，但对于开发人员很贴心的改进，就是日志模式的改进，还记得Log4J那密码一样的日志模式吗？</p>
<p>  %d{dd MMM yyyy HH:mm:ss} [%t] %-5p %m%n</p>
<p>下面是Logback的版本，不用查文档，我也看出每段表示的都是什么：</p>
<p>  %d{dd MMM yyyy HH:mm:ss} [%thread] %-5level %msg%n</p>
<p>这里介绍的几个程序库都是很通用的，无论是你做怎样的开发，应该都或多或少给你一些帮助。时间未曾停步，Java开发也未曾停留，如果你是个老Java程序员，是时候更新一下自己的知识了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java里面的设计模式]]></title>
      <url>http://yoursite.com/2016/04/15/java%E9%87%8C%E9%9D%A2%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>###Structural（结构模式）</p>
<h4 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter:"></a>Adapter:</h4><p>把一个接口或是类变成另外一种。<br>java.util.Arrays#asList()<br>javax.swing.JTable(TableModel)<br>java.io.InputStreamReader(InputStream)<br>java.io.OutputStreamWriter(OutputStream)<br>javax.xml.bind.annotation.adapters.XmlAdapter#marshal()<br>javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()</p>
<h4 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge:"></a>Bridge:</h4><p>把抽象和实现解藕，于是接口和实现可在完全独立开来。<br>AWT (提供了抽象层映射于实际的操作系统)<br>JDBC</p>
<h4 id="Composite"><a href="#Composite" class="headerlink" title="Composite:"></a>Composite:</h4><p>让使用者把单独的对象和组合对象混用。<br>javax.swing.JComponent#add(Component)<br>java.awt.Container#add(Component)<br>java.util.Map#putAll(Map)<br>java.util.List#addAll(Collection)<br>java.util.Set#addAll(Collection)</p>
<h4 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator:"></a>Decorator:</h4><p>为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。这个模式在JDK中几乎无处不在，所以，下面的列表只是一些典型的。<br>java.io.BufferedInputStream(InputStream)<br>java.io.DataInputStream(InputStream)<br>java.io.BufferedOutputStream(OutputStream)<br>java.util.zip.ZipOutputStream(OutputStream)<br>java.util.Collections#checked<a href="">List|Map|Set|SortedSet|SortedMap</a></p>
<h4 id="Facade"><a href="#Facade" class="headerlink" title="Facade:"></a>Facade:</h4><p>用一个简单的接口包状一组组件，接口，抽象或是子系统。<br>java.lang.Class<br>javax.faces.webapp.FacesServlet<br>Flyweight:<br>有效率地存储大量的小的对象。<br>java.lang.Integer#valueOf(int)<br>java.lang.Boolean#valueOf(boolean)<br>java.lang.Byte#valueOf(byte)<br>java.lang.Character#valueOf(char)</p>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy:"></a>Proxy:</h4><p>用一个简单的对象来代替一个复杂的对象。<br>java.lang.reflect.Proxy<br>RMI</p>
<h3 id="Creational（创建模式）"><a href="#Creational（创建模式）" class="headerlink" title="Creational（创建模式）"></a>Creational（创建模式）</h3><h4 id="Abstract-factory"><a href="#Abstract-factory" class="headerlink" title="Abstract factory:"></a>Abstract factory:</h4><p>创建一组有关联的对象实例。这个模式在JDK中也是相当的常见，还有很多的framework例如Spring。我们很容易找到这样的实例。</p>
<p>java.util.Calendar#getInstance()<br>java.util.Arrays#asList()<br>java.util.ResourceBundle#getBundle()<br>java.sql.DriverManager#getConnection()<br>java.sql.Connection#createStatement()<br>java.sql.Statement#executeQuery()<br>java.text.NumberFormat#getInstance()<br>javax.xml.transform.TransformerFactory#newInstance()</p>
<h4 id="Builder"><a href="#Builder" class="headerlink" title="Builder:"></a>Builder:</h4><p>主要用来简化一个复杂的对象的创建。这个模式也可以用来实现一个 Fluent Interface。<br>java.lang.StringBuilder#append()<br>java.lang.StringBuffer#append()<br>java.sql.PreparedStatement<br>javax.swing.GroupLayout.Group#addComponent()</p>
<h4 id="Factory"><a href="#Factory" class="headerlink" title="Factory:"></a>Factory:</h4><p>简单来说，按照需求返回一个类型的实例。<br>java.lang.Proxy#newProxyInstance()<br>java.lang.Object#toString()<br>java.lang.Class#newInstance()<br>java.lang.reflect.Array#newInstance()<br>java.lang.reflect.Constructor#newInstance()<br>java.lang.Boolean#valueOf(String)<br>java.lang.Class#forName()</p>
<h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype:"></a>Prototype:</h4><p>使用自己的实例创建另一个实例。有时候，创建一个实例然后再把已有实例的值拷贝过去，是一个很复杂的动作。所以，使用这个模式可以避免这样的复杂性。<br>java.lang.Object#clone()<br>java.lang.Cloneable</p>
<h4 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton:"></a>Singleton:</h4><p>只允许一个实例。在 Effective Java中建议使用Emun.<br>java.lang.Runtime#getRuntime()<br>java.awt.Toolkit#getDefaultToolkit()<br>java.awt.GraphicsEnvironment#getLocalGraphicsEnvironment()<br>java.awt.Desktop#getDesktop()<br>Behavioral(行为模式)</p>
<h4 id="Chain-of-responsibility"><a href="#Chain-of-responsibility" class="headerlink" title="Chain of responsibility:"></a>Chain of responsibility:</h4><p>把一个对象在一个链接传递直到被处理。在这个链上的所有的对象有相同的接口（抽象类）但却有不同的实现。<br>java.util.logging.Logger#log()<br>javax.servlet.Filter#doFilter()</p>
<h4 id="Command"><a href="#Command" class="headerlink" title="Command:"></a>Command:</h4><p>把一个或一些命令封装到一个对象中。<br>java.lang.Runnable<br>javax.swing.Action</p>
<h4 id="Interpreter"><a href="#Interpreter" class="headerlink" title="Interpreter:"></a>Interpreter:</h4><p>一个语法解释器的模式。</p>
<p>java.util.Pattern<br>java.text.Normalizer<br>java.text.Format</p>
<h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator:"></a>Iterator:</h4><p>提供一种一致的方法来顺序遍历一个容器中的所有元素。<br>java.util.Iterator<br>java.util.Enumeration</p>
<h4 id="Mediator"><a href="#Mediator" class="headerlink" title="Mediator:"></a>Mediator:</h4><p>用来减少对象单的直接通讯的依赖关系。使用一个中间类来管理消息的方向。<br>java.util.Timer<br>java.util.concurrent.Executor#execute()<br>java.util.concurrent.ExecutorService#submit()<br>java.lang.reflect.Method#invoke()</p>
<h4 id="Memento"><a href="#Memento" class="headerlink" title="Memento:"></a>Memento:</h4><p>给一个对象的状态做一个快照。Date类在内部使用了一个long型来做这个快照。<br>java.util.Date<br>java.io.Serializable</p>
<h4 id="Null-Object"><a href="#Null-Object" class="headerlink" title="Null Object:"></a>Null Object:</h4><p>这个模式用来解决如果一个Collection中没有元素的情况。<br>java.util.Collections#emptyList()<br>java.util.Collections#emptyMap()<br>java.util.Collections#emptySet()</p>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer:"></a>Observer:</h4><p>允许一个对象向所有的侦听的对象广播自己的消息或事件。<br>java.util.EventListener<br>javax.servlet.http.HttpSessionBindingListener<br>javax.servlet.http.HttpSessionAttributeListener<br>javax.faces.event.PhaseListener</p>
<h4 id="State"><a href="#State" class="headerlink" title="State:"></a>State:</h4><p>这个模式允许你可以在运行时很容易地根据自身内部的状态改变对象的行为。<br>java.util.Iterator<br>javax.faces.lifecycle.LifeCycle#execute()</p>
<h4 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy:"></a>Strategy:</h4><p>定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。<br>java.util.Comparator#compare()<br>javax.servlet.http.HttpServlet<br>javax.servlet.Filter#doFilter()</p>
<h4 id="Template-method"><a href="#Template-method" class="headerlink" title="Template method:"></a>Template method:</h4><p>允许子类重载部分父类而不需要完全重写。<br>java.util.Collections#sort()<br>java.io.InputStream#skip()<br>java.io.InputStream#read()<br>java.util.AbstractList#indexOf()</p>
<h4 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor:"></a>Visitor:</h4><p>作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作.<br>javax.lang.model.element.Element 和javax.lang.model.element.ElementVisitor<br>javax.lang.model.type.TypeMirror 和javax.lang.model.type.TypeVisitor</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java内存模型]]></title>
      <url>http://yoursite.com/2016/04/15/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-5-4/73912420.jpg" alt="java核心要点"><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/16-4-15/55500961.jpg" alt="java内存模型"></p>
<ol>
<li>主内存包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。</li>
<li><p>Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成</p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p> 关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>
</li>
</ol>
<blockquote>
<p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则</p>
</blockquote>
<ul>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>
</ul>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JDK并发工具类]]></title>
      <url>http://yoursite.com/2016/04/12/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h3 id="Fork-Join-框架测试"><a href="#Fork-Join-框架测试" class="headerlink" title="Fork/Join 框架测试"></a>Fork/Join 框架测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.ExecutionException;</div><div class="line">import java.util.concurrent.ForkJoinPool;</div><div class="line">import java.util.concurrent.ForkJoinTask;</div><div class="line">import java.util.concurrent.RecursiveTask;</div><div class="line">/**</div><div class="line"> * Fork/Join框架测试</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class ForkTest extends RecursiveTask&lt;Integer&gt;&#123;</div><div class="line">	public static int THRESHOLD = 2;</div><div class="line">	public int start;</div><div class="line">	public int end;</div><div class="line">	public ForkTest(int start,int end)&#123;</div><div class="line">		this.start = start;</div><div class="line">		this.end = end;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	protected Integer compute() &#123;</div><div class="line">		int sum = 0;</div><div class="line">		if(end-start &lt;= THRESHOLD)&#123;</div><div class="line">			for(int i=start;i&lt;=end;i++)&#123;</div><div class="line">				sum +=i;</div><div class="line">			&#125;</div><div class="line">		&#125;else&#123;</div><div class="line">			int middle = (start+end)/2;</div><div class="line">			ForkTest leftTask = new ForkTest(start, middle);</div><div class="line">			ForkTest rightTask = new ForkTest(middle+1,end);</div><div class="line">			leftTask.fork();</div><div class="line">			rightTask.fork();</div><div class="line">			int leftResult = leftTask.join();</div><div class="line">			int rightResult = rightTask.join();</div><div class="line">			sum = leftResult + rightResult;</div><div class="line">		&#125;</div><div class="line">		return sum;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		ForkJoinPool forkJoinPool = new ForkJoinPool();</div><div class="line">		ForkTest task = new ForkTest(1, 100);</div><div class="line">		ForkJoinTask&lt;Integer&gt; result = forkJoinPool.submit(task);</div><div class="line">		try &#123;</div><div class="line">			System.out.println(result.get());</div><div class="line">		&#125; catch (InterruptedException | ExecutionException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CountDownLatch-使用"><a href="#CountDownLatch-使用" class="headerlink" title="CountDownLatch 使用"></a>CountDownLatch 使用</h3><h4 id="不使用-CountDownLatch实现"><a href="#不使用-CountDownLatch实现" class="headerlink" title="不使用 CountDownLatch实现"></a>不使用 CountDownLatch实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class CDTest &#123;</div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		Thread t1 = new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				System.out.println(&quot;parse 1 finished!&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		Thread t2 = new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				System.out.println(&quot;parse 2 finished!&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">		// join用于让当前线程等待join线程执行结束</div><div class="line">		t1.join();</div><div class="line">		t2.join();</div><div class="line">		System.out.println(&quot;all parse finished!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-CountDownLatch实现"><a href="#使用-CountDownLatch实现" class="headerlink" title="使用 CountDownLatch实现"></a>使用 CountDownLatch实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class CountDownTest &#123;</div><div class="line">	static CountDownLatch c = new CountDownLatch(2);</div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		Thread t1 = new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				System.out.println(&quot;parse 1 finished!&quot;);</div><div class="line">				c.countDown();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		Thread t2 = new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				System.out.println(&quot;parse 2 finished!&quot;);</div><div class="line">				c.countDown();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">		// await方法会阻塞当前线程，直到N变为0.</div><div class="line">		// countDown可以用在任何地方，可以是N个线程，也可以是1个线程里的N个执行步骤。</div><div class="line">		c.await();  // 也可以指定等待时间  --- await(long time,TimeUnit unit)</div><div class="line">		System.out.println(&quot;finished!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CyclicBarrier-使用"><a href="#CyclicBarrier-使用" class="headerlink" title="CyclicBarrier 使用"></a>CyclicBarrier 使用</h3><h4 id="CyclicBarrierTest1"><a href="#CyclicBarrierTest1" class="headerlink" title="CyclicBarrierTest1"></a>CyclicBarrierTest1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class CYclicBarrierTest_1 &#123;</div><div class="line">	/*</div><div class="line">	 *  屏障拦截的线程数量，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行</div><div class="line">	 *</div><div class="line">	 */</div><div class="line">	static CyclicBarrier c = new CyclicBarrier(2);</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125; catch (BrokenBarrierException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(1);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">			c.await();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">		&#125;</div><div class="line">		System.out.println(2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="CyclicBarrierTest2"><a href="#CyclicBarrierTest2" class="headerlink" title="CyclicBarrierTest2"></a>CyclicBarrierTest2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.BrokenBarrierException;</div><div class="line">import java.util.concurrent.CyclicBarrier;</div><div class="line">/**</div><div class="line"> * CyclicBarrier还提供了一个更高级的构造函数CyclicBarrier(int parties,Runnable barrier-Action)</div><div class="line"> * 用于在线程到达屏障时，优先执行barrierAction,，方便处理更复杂的业务场景</div><div class="line"> * eg: 先输出3，再输出1,2，或者2,1。</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class CyclicBarrierTest_2 &#123;</div><div class="line">	static CyclicBarrier c = new CyclicBarrier(2,new A());</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125; catch (BrokenBarrierException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(1);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">			c.await();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">		&#125;</div><div class="line">		System.out.println(2);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class A implements Runnable&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println(3);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="CyclicBarrierTest3"><a href="#CyclicBarrierTest3" class="headerlink" title="CyclicBarrierTest3"></a>CyclicBarrierTest3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest_3 &#123;</div><div class="line">	static CyclicBarrier c =new CyclicBarrier(2);</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		Thread t = new Thread(new Runnable() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		t.start();</div><div class="line">		t.interrupt();</div><div class="line">		try &#123;</div><div class="line">			c.await();</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			// 此时发生BrokenBarrierException 异常执行该代码</div><div class="line">			System.out.println(&quot;Exception&quot;+c.isBroken());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="CyclicBarrier的应用场景"><a href="#CyclicBarrier的应用场景" class="headerlink" title="CyclicBarrier的应用场景"></a>CyclicBarrier的应用场景</h4><p>例如用一个Excel保存了用户所有银行流水，每一个sheet保存一个账号近一年的银行流水，现在需要统计用户的日均银行流水。先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">import java.util.Map.Entry;</div><div class="line">import java.util.concurrent.ConcurrentHashMap;</div><div class="line">import java.util.concurrent.CyclicBarrier;</div><div class="line">import java.util.concurrent.Executor;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line">/**</div><div class="line"> * 使用线程池创建4个线程，分别计算每个sheet里面的数据，每个sheet计算结果是1，</div><div class="line"> * 再由BankWaterService汇总4个sheet计算出的结果</div><div class="line"> */</div><div class="line">public class BankWaterService implements Runnable &#123;</div><div class="line">	private CyclicBarrier c = new CyclicBarrier(4, this);</div><div class="line">	private Executor executor = Executors.newFixedThreadPool(4);</div><div class="line">	private ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;String, Integer&gt;();</div><div class="line">	private void count()&#123;</div><div class="line">		for(int i=0;i&lt;4;i++)&#123;</div><div class="line">			executor.execute(new Runnable() &#123;</div><div class="line">				@Override</div><div class="line">				public void run() &#123;</div><div class="line">					sheetBankWaterCount.put(Thread.currentThread().getName(), 1);</div><div class="line">					try &#123;</div><div class="line">						c.await();</div><div class="line">					&#125; catch (Exception e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		int result = 0;</div><div class="line">		for(Entry&lt;String,Integer&gt; sheet:sheetBankWaterCount.entrySet())&#123;</div><div class="line">			result += sheet.getValue();</div><div class="line">		&#125;</div><div class="line">		sheetBankWaterCount.put(&quot;result&quot;, result);</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		BankWaterService bankWaterService = new BankWaterService();</div><div class="line">		bankWaterService.count();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h4><ul>
<li>CountDownLatch 的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset方法重置，所以CyclicBarrier可以处理更为复杂的业务场景，例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</li>
<li>CyclicBarrier 还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest_3 &#123;</div><div class="line">	static CyclicBarrier c =new CyclicBarrier(2);</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		Thread t = new Thread(new Runnable() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				try &#123;</div><div class="line">					c.await();</div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		t.start();</div><div class="line">		t.interrupt();</div><div class="line">		try &#123;</div><div class="line">			c.await();</div><div class="line">			System.out.println(c.isBroken());</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			System.out.println(&quot;Exception&quot;+c.isBroken());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Semaphore-用法"><a href="#Semaphore-用法" class="headerlink" title="Semaphore 用法"></a>Semaphore 用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class SemaphoreTest &#123;</div><div class="line">	private static final int THREAD_COUNT = 30;</div><div class="line">	static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</div><div class="line">	private static Semaphore s = new Semaphore(10);</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		for(int i=0;i&lt;THREAD_COUNT;i++)&#123;</div><div class="line">			threadPool.execute(new Runnable() &#123;</div><div class="line">				@Override</div><div class="line">				public void run() &#123;</div><div class="line">					try &#123;</div><div class="line">						s.acquire();</div><div class="line">						Thread.sleep(1000);</div><div class="line">						System.out.println(Thread.currentThread().getName()+&quot; Save Data&quot;);</div><div class="line">						s.release();</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">		threadPool.shutdown();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Semaphore 还有一些其他方法：</p>
<ul>
<li>public int availablePermits() 返回此信号量中当前可用的许可数</li>
<li>public final int getQueueLength()  返回正在等待获取许可证的线程数</li>
<li>public final boolean hasQueuedThreads() 是否有线程正在等待获取许可证</li>
<li>protected Collection<thread> getQueuedThreads()  返回所有等待获取许可证的线程集合，是个protected方法</thread></li>
</ul>
<h3 id="线程间交换数据的Exchanger"><a href="#线程间交换数据的Exchanger" class="headerlink" title="线程间交换数据的Exchanger"></a>线程间交换数据的Exchanger</h3><p>一个用于线程间协作的工具类。它提供一个同步点，在这个同步点，两个线程更可以交换彼此的数据。这两个线程通过exchanger方法交换数据。如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法。当两个线程都到达同步点时，这两个线程就可以交换数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class ExchangerTest &#123;</div><div class="line">	static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;();</div><div class="line">	static ExecutorService threadPool = Executors.newFixedThreadPool(2);</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		threadPool.execute(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				try &#123;</div><div class="line">					String A = &quot;银行流水A&quot;;</div><div class="line">					String newA = exgr.exchange(A);</div><div class="line">					System.out.println(&quot;newA &quot;+newA);</div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		threadPool.execute(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				try &#123;</div><div class="line">					String B = &quot;银行流水B&quot;;</div><div class="line">					String newB = exgr.exchange(B);</div><div class="line">					System.out.println(&quot;newB &quot;+newB);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">输出:</div><div class="line">newB 银行流水A</div><div class="line">newA 银行流水B</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法-数组]]></title>
      <url>http://yoursite.com/2016/04/11/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h3 id="奇数全部放在偶数前面"><a href="#奇数全部放在偶数前面" class="headerlink" title="奇数全部放在偶数前面"></a>奇数全部放在偶数前面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 把数组中的奇数全部放到偶数之前</div><div class="line"> * 注意：面试官期待我们提供的不仅仅是解决一个问题的办法，而是解决一系列问题的通用办法</div><div class="line"> */</div><div class="line">public class OrderArray &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] arr = &#123;1,2,3,4,5,6,7,8,9&#125;;</div><div class="line">		orderModify(arr);</div><div class="line">		ArrayUtils.printArray(arr);</div><div class="line">	&#125;</div><div class="line">	private static void orderModify(int[] arr) &#123;</div><div class="line">		int i=0,j=arr.length-1;</div><div class="line">		while(i&lt;j)&#123;</div><div class="line">			while(i&lt;j &amp;&amp; !isEven(arr[i]))</div><div class="line">				i++;</div><div class="line">			while(i&lt;j &amp;&amp; isEven(arr[j]))</div><div class="line">				j--;</div><div class="line">			if(i &lt; j)&#123;</div><div class="line">				int temp = arr[i];</div><div class="line">				arr[i] = arr[j];</div><div class="line">				arr[j] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private static boolean isEven(int n)&#123;</div><div class="line">		return (n&amp;1)==0 ? true:false;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="行列均递增的二维数组查找指定值"><a href="#行列均递增的二维数组查找指定值" class="headerlink" title="行列均递增的二维数组查找指定值"></a>行列均递增的二维数组查找指定值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 行列都是递增的二维数组，根据给定的数判断是否在在二维数组中</div><div class="line"> * eg:</div><div class="line"> * 1 2 8  9</div><div class="line"> * 2 4 9  12</div><div class="line"> * 4 7 10 13</div><div class="line"> * 6 8 11 15</div><div class="line"> */</div><div class="line">public class FindMatrix &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[][] arr = &#123;</div><div class="line">			&#123;1,2,8,9&#125;,&#123;2,4,9,12&#125;,&#123;4,7,10,13&#125;,&#123;6,8,11,15&#125;</div><div class="line">		&#125;;</div><div class="line">		boolean flag = Find(arr,4,4,4);</div><div class="line">		System.out.println(flag);</div><div class="line">	&#125;</div><div class="line">	private static boolean Find(int[][] arr, int rows, int columns,int num) &#123;</div><div class="line">		boolean found = false;</div><div class="line">		int row=0,col=columns-1;</div><div class="line">		while(row&lt;rows &amp;&amp; col &gt; 0)&#123;</div><div class="line">			if(arr[row][col] == num)&#123;</div><div class="line">				found = true;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			else if(arr[row][col] &gt; num)</div><div class="line">				col--;</div><div class="line">			else</div><div class="line">				row++;</div><div class="line">		&#125;</div><div class="line">		return found;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="未排序正数数组中累加和为给定值的最长子数组长度"><a href="#未排序正数数组中累加和为给定值的最长子数组长度" class="headerlink" title="未排序正数数组中累加和为给定值的最长子数组长度"></a>未排序正数数组中累加和为给定值的最长子数组长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * eg : arr=[1,2,1,1,1]  k=3</div><div class="line"> * 返回最长子数组为[1,1,1]</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class LongestArr &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[] arr = &#123;1,2,1,1,1,1&#125;;</div><div class="line">		int k= 3;</div><div class="line">		int len = getLongestArr(arr,k);</div><div class="line">		System.out.println(len);</div><div class="line">	&#125;</div><div class="line">	private static int getLongestArr(int[] arr,int k) &#123;</div><div class="line">		int left = 0,right = 0,len = 0;</div><div class="line">		int sum=arr[0];</div><div class="line">		while(right &lt; arr.length)&#123;</div><div class="line">			if(sum==k)&#123;</div><div class="line">				System.out.println(&quot;right=&quot;+right+&quot; left=&quot;+left);</div><div class="line">				len = Math.max(len,right-left+1);</div><div class="line">				sum-=arr[left++];</div><div class="line">			&#125;else if(sum &lt; k)&#123;</div><div class="line">				right++;</div><div class="line">				if(right == arr.length)</div><div class="line">					break;</div><div class="line">				sum+=arr[right];</div><div class="line">			&#125;else&#123;</div><div class="line">				sum-=arr[left++];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return len;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最少需要排序的数组元素个数"><a href="#最少需要排序的数组元素个数" class="headerlink" title="最少需要排序的数组元素个数"></a>最少需要排序的数组元素个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 最少需要修改的数组元素个数</div><div class="line"> * eg: &#123;1,5,3,-1,4,2,6,7&#125; 需要修改6个</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class ZuiDuanZiShuZuLength &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[] arr =&#123;1,5,3,-1,4,2,6,7&#125;;</div><div class="line">		int result = getShorestLength(arr);</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int getShorestLength(int[] arr) &#123;</div><div class="line">		// maxIndex 从左往右找到最右侧小于左边最大值的位置</div><div class="line">		int maxIndex = -1;</div><div class="line">		//  minIndex 从右往左找到最左侧大于右边最小值的位置</div><div class="line">		int minIndex = arr.length-1;</div><div class="line">		int max = arr[0];</div><div class="line">		int min=arr[arr.length-1];</div><div class="line">		for(int i=1;i&lt;arr.length;i++)&#123;</div><div class="line">			if(arr[i] &lt; max)&#123;</div><div class="line">				maxIndex = i;</div><div class="line">			&#125;else&#123;</div><div class="line">				max = Math.max(max,arr[i]);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if(maxIndex==-1)</div><div class="line">			return 0;</div><div class="line">		for(int j=arr.length-2;j&gt;=0;j--)&#123;</div><div class="line">			if(arr[j] &gt; min)&#123;</div><div class="line">				minIndex = j;</div><div class="line">			&#125;else&#123;</div><div class="line">				min = Math.min(min, arr[j]);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if(minIndex==-1)</div><div class="line">			return 0;</div><div class="line">		return maxIndex-minIndex+1;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数组中最小的K个数"><a href="#数组中最小的K个数" class="headerlink" title="数组中最小的K个数"></a>数组中最小的K个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 最小的K个数</div><div class="line"> * 思路：建立个数为K的数组，构造大顶堆，然后维护这K个元素的大顶堆，</div><div class="line"> * 若数组后续值比大顶堆的第一个值小，则替换并重新调整大顶堆</div><div class="line"> */</div><div class="line">public class ZuiXiaoKShu &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] arr = &#123;7,8,0,2,2,-1,9,6,4,5,1,-2&#125;;</div><div class="line">		int k=4;</div><div class="line">		heapSort(arr);</div><div class="line">		int[] arrCopy = Arrays.copyOfRange(arr, 0, k);</div><div class="line">		heapSort(arrCopy);</div><div class="line">		for(int i=k;i&lt;arr.length;i++)&#123;</div><div class="line">			if(arr[i] &lt; arrCopy[0])&#123;</div><div class="line">				arrCopy[0] =arr[i];</div><div class="line">				heapSort(arrCopy);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ArrayUtils.printArray(arrCopy);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void heapSort(int[] arr) &#123;</div><div class="line">		if (arr == null || arr.length &lt;= 1) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">		buildMaxHeap(arr);</div><div class="line">		for(int i=arr.length-1;i&gt;=0;i--)&#123;</div><div class="line">			ArrayUtils.swap(arr, 0, i);</div><div class="line">			maxHeap(arr, i, 0);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void buildMaxHeap(int[] arr) &#123;</div><div class="line">		if (arr == null || arr.length &lt;= 1) &#123;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		int half = (arr.length-1)/2;</div><div class="line">		for(int i=half;i&gt;=0;i--)&#123;</div><div class="line">			maxHeap(arr,arr.length,i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void maxHeap(int[] arr, int length, int index) &#123;</div><div class="line">		 int left = 2*index+1;</div><div class="line">		 int right = 2*index+2;</div><div class="line">		 int largestIndex = index;</div><div class="line">		if(left &lt; length &amp;&amp; arr[left] &lt; arr[largestIndex])</div><div class="line">			largestIndex = left;</div><div class="line">		if(right &lt; length &amp;&amp; arr[right] &lt; arr[largestIndex])</div><div class="line">			largestIndex = right;</div><div class="line">		if(largestIndex!=index)&#123;</div><div class="line">			ArrayUtils.swap(arr, index, largestIndex);</div><div class="line">			maxHeap(arr, length, largestIndex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="求给定数字包含1的个数"><a href="#求给定数字包含1的个数" class="headerlink" title="求给定数字包含1的个数"></a>求给定数字包含1的个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 求给定数字包含1的个数</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class TestOne &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(CountOne(56));</div><div class="line">	&#125;</div><div class="line">	private static int CountOne(int n) &#123;</div><div class="line">		int count = 0;</div><div class="line">		while(n!=0)&#123;</div><div class="line">			//相当于抹去最右边的1</div><div class="line">			n &amp;= (n-1);</div><div class="line">			count++;</div><div class="line">		&#125;</div><div class="line">		return count;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="一个数出现了奇数次"><a href="#一个数出现了奇数次" class="headerlink" title="一个数出现了奇数次"></a>一个数出现了奇数次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 给定一个整型数组arr，其中只有一个数出现了奇数次，其他的数都出现了偶数次，求此数</div><div class="line"> * @author flyyc</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class TestOld &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 数组中出现一次的一个数</div><div class="line">		getFromEvenArray();</div><div class="line">	&#125;</div><div class="line">	private static void getFromEvenArray() &#123;</div><div class="line">		int[] array = &#123;3,3,6,2,4,6,4&#125;;</div><div class="line">		int e0=0;</div><div class="line">		for(int cur : array)&#123;</div><div class="line">			e0 ^= cur;</div><div class="line">		&#125;</div><div class="line">		System.out.println(e0);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="两个数出现了奇数次"><a href="#两个数出现了奇数次" class="headerlink" title="两个数出现了奇数次"></a>两个数出现了奇数次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 出现奇数次的数</div><div class="line"> * 给定一个整型数组arr，其中只有两个数出现了奇数次，其他的数都出现了偶数次，求此数</div><div class="line"> */</div><div class="line">public class TestOneTwo &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		//数组中只出现一次的两个数</div><div class="line">		getFromEvenArray2();</div><div class="line">	&#125;</div><div class="line">	private static void getFromEvenArray2() &#123;</div><div class="line">		char[] result;</div><div class="line">		int[] array = &#123;3,3,6,2,4,6,4,12&#125;;</div><div class="line">		int e0=0,e2=0;</div><div class="line">		for(int cur : array)&#123;</div><div class="line">			e0 ^= cur;</div><div class="line">		&#125;</div><div class="line">		// 求出最低位为1的位置</div><div class="line">		int pri = e0 &amp; (~e0+1);</div><div class="line">		for(int cur : array)&#123;</div><div class="line">			// 若第K位为1，则进行异或，这样可以确定异或结果中不受另一个出现一次的数的影响</div><div class="line">			if((cur &amp; pri)!=0)&#123;</div><div class="line">				e2 ^= cur;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(e2+&quot; &quot; + (e2 ^ e0));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="其他数出现K次"><a href="#其他数出现K次" class="headerlink" title="其他数出现K次"></a>其他数出现K次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 给定一个整型数组arr和一个大于1的整数k。已知arr中只有1个数出现了1次，其他的数都出现了k次，请返回只出现了1次的数。</div><div class="line"> * 时间复杂度为O(N),额外空间复杂度为O(1).</div><div class="line"> * 仿照无进位相加思想。即忽略进位的相加。</div><div class="line"> * eg: 两个7进制的a和b，在i位上无进位相加的结果就是(a[i]+b[i])%7。出现K次使用K进制相加为0,则最后数组中结果即为所求 。</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class KInOne &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] e0 = new int[32];</div><div class="line">		int[] arr = &#123;3,3,7,7,7,3,4,4,4,5,5,5,9,6,6,6&#125;;</div><div class="line">		int k = 3;</div><div class="line">		for(int i =0;i&lt;arr.length;i++)&#123;</div><div class="line">			// 对数组中每一个数进行无进位相加</div><div class="line">			setExclusive(e0,arr[i],k);</div><div class="line">		&#125;</div><div class="line">		int res = getNumFromKSysNum(e0,k);</div><div class="line">		System.out.println(res);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public  static void setExclusive(int[] e0, int n, int k) &#123;</div><div class="line">		int[] cur = getKNum(n,k);</div><div class="line">		for(int i=0 ; i&lt;cur.length;i++)&#123;</div><div class="line">			e0[i] = (e0[i] + cur[i])%k;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static int[] getKNum(int n, int k) &#123;</div><div class="line">		int[] res = new int[32];</div><div class="line">		int index = 0;</div><div class="line">		// 把n转化为K进制，此处转化结果与后面从数组中读取顺序要一致。</div><div class="line">		// 注意：此处是按从0开始保存余数。</div><div class="line">		while(n!=0)&#123;</div><div class="line">			res[index++] = n%k;</div><div class="line">			n = n/k;</div><div class="line">		&#125;</div><div class="line">		return res;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public  static int getNumFromKSysNum(int[] arr, int k) &#123;</div><div class="line">		int result = 0;</div><div class="line">		for(int i = 0;i &lt; arr.length;i++)&#123;</div><div class="line">			// 从结果数组中还原K进制数为十进制。因为上面保存的时候是从前往后保存，所以此处读取顺序一致</div><div class="line">			result+=arr[i]*Math.pow(k, i);</div><div class="line">		&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="奇偶数下标"><a href="#奇偶数下标" class="headerlink" title="奇偶数下标"></a>奇偶数下标</h3><p>调整次序使得所有偶数在偶数下标或者奇数在奇数下标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private static void adjust(int[] arr) &#123;</div><div class="line">		int evenIndex = 0;</div><div class="line">		int oddIndex = 1;</div><div class="line">		int high=arr.length-1;</div><div class="line">		while(evenIndex &lt; arr.length &amp;&amp; oddIndex &lt; arr.length)&#123;</div><div class="line">			if((arr[high]&amp;1)==0)&#123;</div><div class="line">				arr[evenIndex] = arr[high];</div><div class="line">				evenIndex+=2;</div><div class="line">			&#125;else&#123;</div><div class="line">				arr[oddIndex] = arr[high];</div><div class="line">				oddIndex++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 非递归二分搜索</div><div class="line">	private static int binarySearch(int[] arr,int key) &#123;</div><div class="line">		int left = 0;</div><div class="line">		int right = arr.length-1;</div><div class="line">		while(left &lt;= right)&#123;</div><div class="line">			int middle = (left+right)&gt;&gt;1;</div><div class="line">			if(arr[middle]==key)</div><div class="line">				return middle;</div><div class="line">			else if(arr[middle] &gt; key)</div><div class="line">				right=middle-1;</div><div class="line">			else</div><div class="line">				left=middle+1;</div><div class="line">		&#125;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	// 递归二分搜索</div><div class="line">	private static int recBinarySearch(int[] arr,int low,int high,int key)&#123;</div><div class="line">		if(low &lt;= high)&#123;</div><div class="line">			int middle = (low+high)/2;</div><div class="line">			if(key==arr[middle])&#123;</div><div class="line">				return middle;</div><div class="line">			&#125;else if(key&lt;arr[middle])&#123;</div><div class="line">				return recBinarySearch(arr, low, middle-1, key);</div><div class="line">			&#125;else&#123;</div><div class="line">				return recBinarySearch(arr, middle+1, high, key);</div><div class="line">			&#125;</div><div class="line">		&#125;else</div><div class="line">			return -1;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="从左上角沿着边缘线走到右下角"><a href="#从左上角沿着边缘线走到右下角" class="headerlink" title="从左上角沿着边缘线走到右下角"></a>从左上角沿着边缘线走到右下角</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class QiPan &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(numOfMethod(1,1));</div><div class="line">	&#125;</div><div class="line">	//从图中可以看出，要达到右下角的位置，必须先到达右下角的上边或者左边，可以归结为n-1行m列和n行m-1列的模型解决</div><div class="line">	private static int numOfMethod(int i, int j) &#123;</div><div class="line">		if(i&lt;=0 || j&lt;=0)</div><div class="line">			return 0;</div><div class="line">		else if(i==1)</div><div class="line">			return j+1;</div><div class="line">		else if(j==1)</div><div class="line">			return i+1;</div><div class="line">		else</div><div class="line">			return numOfMethod(i-1, j)+numOfMethod(i, j-1);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="苹果放法"><a href="#苹果放法" class="headerlink" title="苹果放法"></a>苹果放法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * M个相同的苹果放到N个相同的盘子里，允许为空，共有多少种不同的放法。</div><div class="line"> */</div><div class="line">public class PlaceApple &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int result = fun(7,3);</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int fun(int n, int m) &#123;</div><div class="line">		if(n&lt;0) return 0;</div><div class="line">		if(n==0||m==1) return 1;</div><div class="line">		return fun(n,m-1)+fun(n-m,m);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/** 模型： 最长递增子序列</div><div class="line"> * 1.计算最少出列多少位同学，使得剩下的同学排成合唱队形。</div><div class="line"> * 2.走梅花桩，从前到后，往高的桩子走，走的步数最多。</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class IncrementOrderTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] arr = &#123;186,186,150,200,160,130,197,200&#125;;</div><div class="line">		int[] dp = getDp(arr);</div><div class="line">		int max = 0;</div><div class="line">		for(int i=0;i&lt;dp.length;i++)&#123;</div><div class="line">			if(dp[i] &gt; max)</div><div class="line">				max = dp[i];</div><div class="line">		&#125;</div><div class="line">		System.out.println(max);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int[] getDp(int[] arr) &#123;</div><div class="line">		int[] dp = new int[arr.length];</div><div class="line">		for(int i=0;i&lt;arr.length;i++)&#123;</div><div class="line">			dp[i] = 1;</div><div class="line">			for(int j=0;j&lt;i;j++)&#123;</div><div class="line">				if(arr[j] &lt; arr[i])</div><div class="line">					dp[i] = Math.max(dp[i],dp[j]+1);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="未排序-最长子数组长度"><a href="#未排序-最长子数组长度" class="headerlink" title="未排序 最长子数组长度"></a>未排序 最长子数组长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 未排序正数数组中累加和为给定值的最长子数组长度</div><div class="line"> * eg : arr=[1,2,1,1,1]  k=3</div><div class="line"> * 返回最长子数组为[1,1,1]</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class LongestArr &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[] arr = &#123;1,2,1,1,1,1&#125;;</div><div class="line">		int k= 3;</div><div class="line">		int len = getLongestArr(arr,k);</div><div class="line">		System.out.println(len);</div><div class="line">	&#125;</div><div class="line">	private static int getLongestArr(int[] arr,int k) &#123;</div><div class="line">		int left = 0,right = 0,len = 0;</div><div class="line">		int sum=arr[0];</div><div class="line">		while(right &lt; arr.length)&#123;</div><div class="line">			if(sum==k)&#123;</div><div class="line">				System.out.println(&quot;right=&quot;+right+&quot; left=&quot;+left);</div><div class="line">				len = Math.max(len,right-left+1);</div><div class="line">				sum-=arr[left++];</div><div class="line">			&#125;else if(sum &lt; k)&#123;</div><div class="line">				right++;</div><div class="line">				if(right == arr.length)</div><div class="line">					break;</div><div class="line">				sum+=arr[right];</div><div class="line">			&#125;else&#123;</div><div class="line">				sum-=arr[left++];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return len;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法-树]]></title>
      <url>http://yoursite.com/2016/04/10/%E7%AE%97%E6%B3%95-%E6%A0%91/</url>
      <content type="html"><![CDATA[<h3 id="创建二叉排序树"><a href="#创建二叉排序树" class="headerlink" title="创建二叉排序树"></a>创建二叉排序树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private static void createBinaryTree(TreeNode head ,int value) &#123;</div><div class="line">		if(head==null)</div><div class="line">			return;</div><div class="line">		TreeNode currentNode = head;</div><div class="line">		while(true)&#123;</div><div class="line">			if(value &lt; currentNode.value)&#123;</div><div class="line">				if(currentNode.left == null)&#123;</div><div class="line">					currentNode.left = new TreeNode(value);</div><div class="line">					return;</div><div class="line">				&#125;else</div><div class="line">					currentNode = currentNode.left;</div><div class="line">			&#125;else&#123;</div><div class="line">				if(currentNode.right == null)&#123;</div><div class="line">					currentNode.right = new TreeNode(value);</div><div class="line">					return;</div><div class="line">				&#125;else</div><div class="line">					currentNode = currentNode.right;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">private static String sequenceTree(TreeNode&lt;Integer&gt; head) &#123;</div><div class="line">	if(head==null)</div><div class="line">		return &quot;#!&quot;;</div><div class="line">	String res = String.valueOf(head.item)+&quot;!&quot;;</div><div class="line">	res += sequenceTree(head.left);</div><div class="line">	res += sequenceTree(head.right);</div><div class="line">	return res;</div><div class="line">&#125;</div><div class="line">// 使用前序遍历来反序列化</div><div class="line">//  seq=&quot;10!3!2!#!#!4!#!7!5!#!#!9!8!#!#!#!11!#!12!#!20!#!23!#!#!&quot;</div><div class="line">private static TreeNode&lt;Integer&gt; reconByString(String seq) &#123;</div><div class="line">	String[] value = seq.split(&quot;!&quot;);</div><div class="line">	Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</div><div class="line">	for(int i=0;i!=value.length;i++)</div><div class="line">		queue.offer(value[i]);</div><div class="line">	return reconPreOrder(queue);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static TreeNode&lt;Integer&gt; reconPreOrder(Queue&lt;String&gt; queue) &#123;</div><div class="line">	String value =queue.poll();</div><div class="line">	if(value.equals(&quot;#&quot;))</div><div class="line">		return null;</div><div class="line">	TreeNode head = new TreeNode(Integer.valueOf(value));</div><div class="line">	head.left = reconPreOrder(queue);</div><div class="line">	head.right = reconPreOrder(queue);</div><div class="line">	return head;</div><div class="line">&#125;</div><div class="line">// 使用层次遍历来反序列化</div><div class="line">private static String sequenceTreeByLevel(TreeNode head)&#123;</div><div class="line">	if(head==null)</div><div class="line">		return &quot;#!&quot;;</div><div class="line">	String res = head.value+&quot;!&quot;;</div><div class="line">	Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();</div><div class="line">	queue.offer(head);</div><div class="line">	while(!queue.isEmpty())&#123;</div><div class="line">		head = queue.poll();</div><div class="line">		if(head.left!=null)&#123;</div><div class="line">			res+=head.left.value+&quot;!&quot;;</div><div class="line">			queue.offer(head.left);</div><div class="line">		&#125;else&#123;</div><div class="line">			res+=&quot;#!&quot;;</div><div class="line">		&#125;</div><div class="line">		if(head.right!=null)&#123;</div><div class="line">			res+=head.right.value+&quot;!&quot;;</div><div class="line">			queue.offer(head.right);</div><div class="line">		&#125;else&#123;</div><div class="line">			res+=&quot;#!&quot;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法-链表]]></title>
      <url>http://yoursite.com/2016/04/10/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h3 id="单链表整体逆置-相邻元素逆置"><a href="#单链表整体逆置-相邻元素逆置" class="headerlink" title="单链表整体逆置/相邻元素逆置"></a>单链表整体逆置/相邻元素逆置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 单链表整体逆置 &amp;&amp;  单链表相邻元素逆置</div><div class="line"> */</div><div class="line">public class LinkList &#123;</div><div class="line">	static class Node&#123;</div><div class="line">		public int data;</div><div class="line">		public Node next;</div><div class="line">		public Node(int data)&#123;</div><div class="line">			this.data = data;</div><div class="line">		&#125;</div><div class="line">		public Node()&#123;&#125;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//带头结点的链表</div><div class="line">		Node head = new Node();</div><div class="line">		head.next = null;</div><div class="line">		Node p = head;</div><div class="line">		for(int i = 1;i&lt;10;i++)&#123;</div><div class="line">			Node temp = new Node(i);</div><div class="line">			temp.next = null;</div><div class="line">			p.next = temp;</div><div class="line">			p = p.next;</div><div class="line">		&#125;</div><div class="line">		//单链表整体逆置</div><div class="line">		reverseLinkedList(head);</div><div class="line">		printLinkedList(head);</div><div class="line"></div><div class="line">		//单链表相邻元素逆置</div><div class="line">		neighbourReverse(head);</div><div class="line">		printLinkedList(head);</div><div class="line">	&#125;</div><div class="line">	//反转相邻元素，交换相邻元素的值，然后令next指向后两个节点，若有一个不存在则结束</div><div class="line">	private static void neighbourReverse(Node head) &#123;</div><div class="line">		int temp;</div><div class="line">		Node p=head.next;</div><div class="line">		Node q=p.next;</div><div class="line">		while(p!=null &amp;&amp; q!=null)&#123;</div><div class="line">			temp = p.data;</div><div class="line">			p.data = q.data;</div><div class="line">			q.data = temp;</div><div class="line">			p = q.next;</div><div class="line">			q = p.next;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//反转单链表</div><div class="line">	private static Node reverseLinkedList(Node head) &#123;</div><div class="line">		Node p,q,r;</div><div class="line">		p = head.next;</div><div class="line">		q = p.next;</div><div class="line">		p.next = null;</div><div class="line">		while(q!=null)&#123;</div><div class="line">			 r=q.next;</div><div class="line">			 q.next=head.next;</div><div class="line">			 head.next=q;</div><div class="line">			 q=r;</div><div class="line">		&#125;</div><div class="line">		return head;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//	反转链表(没有头结点)</div><div class="line">	// 将结点保存至pNext，然后将当前结点的next重新设置为prev，将prev指向当前结点，再将指针后移一个结点</div><div class="line">	private static Node reverseLink(Node head) &#123;</div><div class="line">		Node prev = null;</div><div class="line">		Node newHead = null;</div><div class="line">		Node p = head;</div><div class="line">		while(p!=null)&#123;</div><div class="line">			Node pNext = p.next;</div><div class="line">			if(pNext==null)</div><div class="line">				newHead = p;</div><div class="line">			p.next = prev;</div><div class="line">			prev = p;</div><div class="line">			p = pNext;</div><div class="line">		&#125;</div><div class="line">		return newHead;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 递归反转链表(没有头结点)</div><div class="line">	private static Node reverseRecursively(Node head)&#123;</div><div class="line">		if(head == null || head.next == null)</div><div class="line">			return head;</div><div class="line">		else&#123;</div><div class="line">			Node newHead = reverseRecursively(head.next);</div><div class="line">			head.next.next = head;</div><div class="line">			head.next = null;</div><div class="line">			return newHead;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	//顺序打印输出(带头结点的链表输出)</div><div class="line">	private static void printLinkedList(Node p) &#123;</div><div class="line">		p = p.next;</div><div class="line">		while(p!=null)&#123;</div><div class="line">			System.out.println(p.data);</div><div class="line">			p = p.next;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	// 逆序打印结点(不带头结点)</div><div class="line">	private static void printReverse(Node head) &#123;</div><div class="line">		Node p = head;</div><div class="line">		if(p!=null)&#123;</div><div class="line">			if(p.next!=null)</div><div class="line">				printReverse(p.next);</div><div class="line">		&#125;</div><div class="line">		System.out.print(p.value+&quot; &quot;);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法-动态规划]]></title>
      <url>http://yoursite.com/2016/04/10/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      <content type="html"><![CDATA[<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 给定两个字符串str1和str2,返回这两个字符串的最长公共子序列</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class ZuiChangGongGongZiXuLie &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String str1=&quot;1B12A2C33D4B56&quot;;</div><div class="line">		String str2=&quot;B12D33BA45B6A&quot;;</div><div class="line">		int[][] dp = getDp(str1,str2);</div><div class="line">		ArrayUtils.printArray(dp);</div><div class="line">		printResult(str1,str2,dp);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void printResult(String str1,String str2,int[][] dp) &#123;</div><div class="line">		int rows = dp.length-1;</div><div class="line">		int cols = dp[0].length-1;</div><div class="line">		char[] chs1 = str1.toCharArray();</div><div class="line">		char[] chs2 = str2.toCharArray();</div><div class="line"></div><div class="line">		char[] res = new char[dp[rows][cols]];</div><div class="line">		int index = res.length-1;</div><div class="line">		while(index &gt;= 0)&#123;</div><div class="line">			if(rows &gt; 0 &amp;&amp; dp[rows][cols] == dp[rows-1][cols])</div><div class="line">				rows--;</div><div class="line">			else if(cols &gt; 0 &amp;&amp; dp[rows][cols] == dp[rows][cols-1])</div><div class="line">				cols--;</div><div class="line">			else&#123;</div><div class="line">				res[index--] =  chs1[rows];</div><div class="line">				rows--;</div><div class="line">				cols--;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ArrayUtils.printArray(res);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int[][] getDp(String str1, String str2) &#123;</div><div class="line">		char[] chs1 = str1.toCharArray();</div><div class="line">		char[] chs2 = str2.toCharArray();</div><div class="line">		int[][] dp = new int[chs1.length][chs2.length];</div><div class="line">		dp[0][0] = chs1[0]==chs2[0]?1:0;</div><div class="line">		for(int i = 1;i &lt; chs2.length;i++)&#123;</div><div class="line">			// 若有一处为1，则该行或该列都为1</div><div class="line">			dp[0][i] = Math.max(dp[0][i-1],chs1[0]==chs2[i]?1:0);</div><div class="line">		&#125;</div><div class="line">		for(int j = 1;j &lt; chs1.length;j++)&#123;</div><div class="line">			dp[j][0] = Math.max(dp[j-1][0],chs1[j]==chs2[0]?1:0);</div><div class="line">		&#125;</div><div class="line">		for(int i=1;i&lt;chs1.length;i++)&#123;</div><div class="line">			for(int j=1;j&lt;chs2.length;j++)&#123;</div><div class="line">				dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);</div><div class="line">				if(chs1[i] == chs2[j])</div><div class="line">					// 相等则为上一次末尾相等的字符对应的值加1</div><div class="line">					dp[i][j] = Math.max(dp[i][j],dp[i-1][j-1]+1);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 最长公共子串</div><div class="line"> * 与最长公共子序列不同的地方在于，必须连续</div><div class="line"> *</div><div class="line"> * eg:  String str1 = &quot;1AB2345CD&quot;;</div><div class="line">		String str2 = &quot;123345EF&quot;;</div><div class="line">	返回  &#123;3,4,5&#125;</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class ZuiChangGongGongZiChuan &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String str1 = &quot;1AB2345CD&quot;;</div><div class="line">		String str2 = &quot;123345EF&quot;;</div><div class="line">		int  index = 0;</div><div class="line">		int max = 0;</div><div class="line">		char[] chs1 = str1.toCharArray();</div><div class="line">		char[] chs2 = str2.toCharArray();</div><div class="line">		int[][] dp = getDp(chs1,chs2);</div><div class="line">		ArrayUtils.printArray(dp);</div><div class="line">		for(int i = 0;i &lt; chs2.length;i++)&#123;</div><div class="line">			for(int j = 0;j &lt; chs1.length;j++)&#123;</div><div class="line">				if(dp[i][j] &gt; max)&#123;</div><div class="line">					// 找到最大公共子串的末尾位置</div><div class="line">					index = i;</div><div class="line">					// 找到最大公共子串的长度</div><div class="line">					max = dp[i][j];</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		char result[]  = new char[max];</div><div class="line">		while(max &gt; 0)</div><div class="line">			// 最大公共子串的长度不为1，则赋值给result</div><div class="line">			result[--max] = chs1[index--];</div><div class="line">		ArrayUtils.printArray(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	private static int[][] getDp(char[] chs1, char[] chs2) &#123;</div><div class="line">		int lenA = chs1.length;</div><div class="line">		int lenB = chs2.length;</div><div class="line">		int[][] dp = new int[lenB][lenA];</div><div class="line">		for(int i = 0;i &lt; chs2.length;i++)&#123;</div><div class="line">			if(chs2[i] == chs1[0])</div><div class="line">				dp[i][0] = 1;</div><div class="line">		&#125;</div><div class="line">		for(int i = 0;i &lt; chs1.length;i++)&#123;</div><div class="line">			if(chs2[0] == chs1[i])</div><div class="line">				dp[0][i] = 1;</div><div class="line">		&#125;</div><div class="line">		for(int i = 1;i &lt; chs1.length;i++)&#123;</div><div class="line">			for(int j = 1;j &lt; chs2.length;j++)&#123;</div><div class="line">				if(chs1[i] == chs2[j])</div><div class="line">					// 因为所求为连续字符串，所以下一个dp[i][j]为上一个dp[i-1][j-1]的值加1</div><div class="line">					dp[i][j] = dp[i-1][j-1] + 1;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 数组中最长连续序列</div><div class="line"> * eg: arr=[100,4,1,3,2] 返回 [1,2,3,4]</div><div class="line"> */</div><div class="line">import java.util.HashMap;</div><div class="line"></div><div class="line">public class ArrZuiChangLianXuXuLie &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[] arr=&#123;100,4,200,1,3,2,6,5&#125;;</div><div class="line">		int maxLen = getLongestLen(arr);</div><div class="line">		System.out.println(maxLen);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int getLongestLen(int[] arr) &#123;</div><div class="line">		HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();</div><div class="line">		// 全局max，保存最长连续序列最大值</div><div class="line">		int max = 1;</div><div class="line">		for(int i = 0;i &lt; arr.length;i++)&#123;</div><div class="line">			if(!map.containsKey(arr[i]))&#123;</div><div class="line">				map.put(arr[i], 1);</div><div class="line">				if(map.containsKey(arr[i]-1))&#123;</div><div class="line">					max = Math.max(max,mergeArr(map,arr[i]-1,arr[i]));</div><div class="line">				&#125;</div><div class="line">				if(map.containsKey(arr[i]+1))&#123;</div><div class="line">					max = Math.max(max,mergeArr(map,arr[i],arr[i]+1));</div><div class="line"></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return max;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int mergeArr(HashMap&lt;Integer, Integer&gt; map, int low, int high) &#123;</div><div class="line">		// 对于一串连续的序列，会把首字符和长度、尾字符和长度存到map里面，方便合并的时候使用首尾</div><div class="line">		// 得到较小的数的首字符位置</div><div class="line">		int left = low-map.get(low)+1;</div><div class="line">		// 得到较大的数的尾字符位置</div><div class="line">		int right= high+map.get(high)-1;</div><div class="line">		int len = right - left + 1;</div><div class="line">		// 把首字符和长度存入map</div><div class="line">		map.put(left, len);</div><div class="line">		// 把尾字符和长度存入map</div><div class="line">		map.put(right, len);</div><div class="line">		return len;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 最长递增子序列</div><div class="line"> * eg: arr=&#123;2,1,5,3,6,4,8,9,7&#125; 返回的最长的递增子序列为[1,3,4,8,9]。</div><div class="line"> */</div><div class="line">public class IncrementSubOrder &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[] arr = &#123;2,1,5,3,6,4,8,9,7&#125;;</div><div class="line">		int[] result = getIncrementArr(arr);</div><div class="line">		int index = 0;</div><div class="line">		int len = 0;</div><div class="line">		// 打印dp路径 dp[i]表示以arr[i]结尾的情况下，arr[0...j]中的最大递增子序列长度。</div><div class="line">		ArrayUtils.printArray(result);</div><div class="line">		for(int i = 0;i &lt; result.length;i++)&#123;</div><div class="line">			if(result[index] &lt; result[i])&#123;</div><div class="line">				// index定位最大值，即最大递增子序列的末尾数</div><div class="line">				index = i;</div><div class="line">				len = result[i];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		int[] newArr = new int[len];</div><div class="line">		newArr[--len] = arr[index];</div><div class="line">		for(int i = index;i &gt;= 0;i--)&#123;</div><div class="line">			// 若某个数小于index所指的数且dp长度相差为1，则可以包含这个数</div><div class="line">			if(arr[index] &gt; arr[i] &amp;&amp; result[i] == result[index]-1)&#123;</div><div class="line">				newArr[--len] = arr[i];</div><div class="line">				index = i;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ArrayUtils.printArray(newArr);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int[] getIncrementArr(int[] arr) &#123;</div><div class="line">		int len = arr.length;</div><div class="line">		int[] dp = new int[len];</div><div class="line">		for(int i = 0;i &lt; arr.length;i++)&#123;</div><div class="line">			// 默认都为1 (包含自身)</div><div class="line">			dp[i] = 1;</div><div class="line">			for(int j = 0;j &lt; i;j++)&#123;</div><div class="line">				if(arr[i] &gt; arr[j])</div><div class="line">					dp[i] = Math.max(dp[i], dp[j]+1);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二维数组中最小路径和"><a href="#二维数组中最小路径和" class="headerlink" title="二维数组中最小路径和"></a>二维数组中最小路径和</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 给定一个矩阵m，从左上角开始每次只能向右或向下走，最后到达右下角的位置，路径上</div><div class="line"> * 所有数字累加起来就是路径和，返回最小的路径和</div><div class="line"> * 1 3 5 9</div><div class="line"> * 8 1 3 4</div><div class="line"> * 5 0 6 1</div><div class="line"> * 8 8 4 0</div><div class="line"> */</div><div class="line"></div><div class="line">public class ShortDistance &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[][] arr = &#123;</div><div class="line">				&#123;1,3,5,9&#125;,&#123;8,1,3,4&#125;,&#123;5,0,6,1&#125;,&#123;8,8,4,0&#125;</div><div class="line">		&#125;;</div><div class="line">		int[][] dp = getDp(arr);</div><div class="line">		System.out.println(dp[dp.length-1][dp[0].length-1]);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int[][] getDp(int[][] arr) &#123;</div><div class="line">		int rows = arr.length;</div><div class="line">		int cols = arr[0].length;</div><div class="line">		int[][] dp = new int[rows][cols];</div><div class="line">		dp[0][0] = arr[0][0];</div><div class="line">		// dp的行</div><div class="line">		for(int i=1;i&lt;cols;i++)</div><div class="line">			dp[0][i] = dp[0][i-1]+arr[0][i];</div><div class="line">		// dp的列</div><div class="line">		for(int i=1;i&lt;rows;i++)</div><div class="line">			dp[i][0] = dp[i-1][0]+arr[i][0];</div><div class="line">		// 更新dp其他行列值</div><div class="line">		for(int i=1;i&lt;rows;i++)&#123;</div><div class="line">			for(int j=1;j&lt;cols;j++)&#123;</div><div class="line">				// dp[i][j] 根据左边或者上边的值确定之后加上当前arr的值</div><div class="line">				dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1])+arr[i][j];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a>交错字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 动态规划</div><div class="line"> * 给定三个字符串：str1,str2,aim。若aim包含str1和str2且相对属顺序一致则true</div><div class="line"> * dp[i][j]代表aim[i+j-1]能否被str1[0..i-1]和str2[0..j-1]交错组成</div><div class="line"> * dp[i-1][j] 代表aim[0..i+j-2]能否被str1[0..i-2]和str2[0..j-1]组成，此时，如果str[i-1]等于aim[i+j-1] 说明</div><div class="line"> * str[i-1]又可以作为交错组成aim[0..i+j-1]的最后一个字符，令dp[i][j]=true.</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class StringCross &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">//		String str1 = &quot;ABE1EF12&quot;;</div><div class="line">//		String str2 = &quot;CDG&quot;;</div><div class="line">//		String aim = &quot;ABE1ECF1D2G&quot;;</div><div class="line">		String str1 = &quot;AB&quot;;</div><div class="line">		String str2 = &quot;12&quot;;</div><div class="line">		String aim = &quot;A12B&quot;;</div><div class="line">		char[] chs1 = str1.toCharArray();</div><div class="line">		char[] chs2 = str2.toCharArray();</div><div class="line">		char[] chsaim = aim.toCharArray();</div><div class="line">		boolean flag = getDp(chs1,chs2,chsaim);</div><div class="line">		System.out.println(flag);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static boolean getDp(char[] chs1, char[] chs2, char[] chsaim) &#123;</div><div class="line">		if(chsaim.length != chs1.length+ chs2.length)</div><div class="line">			return false;</div><div class="line">		boolean[][] dp = new boolean[chs1.length+1][chs2.length+1];</div><div class="line">		dp[0][0] = true;</div><div class="line">		for(int i = 1;i &lt;= chs1.length;i++)&#123;</div><div class="line">			if(chs1[i-1] == chsaim[i-1])</div><div class="line">				dp[i][0] = true;</div><div class="line">		&#125;</div><div class="line">		for(int i = 1;i &lt;= chs2.length;i++)&#123;</div><div class="line">			if(chs2[i-1] == chsaim[i-1])</div><div class="line">				dp[0][i] = true;</div><div class="line">		&#125;</div><div class="line">		for(int i = 1;i &lt;= chs1.length;i++)&#123;</div><div class="line">			for(int j = 1;j &lt;= chs2.length;j++)&#123;</div><div class="line">				if((dp[i-1][j] &amp;&amp; chs1[i-1] == chsaim[i+j-1])</div><div class="line">						|| (dp[i][j-1] &amp;&amp; chs2[j-1] == chsaim[i+j-1]))</div><div class="line">					dp[i][j] = true;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		// 打印dp</div><div class="line">		ArrayUtils.printArray(dp);</div><div class="line">		return isCross(dp);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static boolean isCross(boolean[][] dp) &#123;</div><div class="line"></div><div class="line">		return dp[dp.length-1][dp[0].length-1];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最大乘积数组"><a href="#最大乘积数组" class="headerlink" title="最大乘积数组"></a>最大乘积数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> * 利用动态规划求解。考虑到负数的情况，用maxEnd来表示以arr[i]结尾的最大连续子数组的乘积值</div><div class="line"> * 用minEnd表示以arr[i]结尾的最小连续子数组的乘积值</div><div class="line"> * @flyzyc</div><div class="line"> */</div><div class="line">public class LargestMultiArr &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		double[] arr = &#123;1,0,-2,0.5,-8,7,2&#125;;</div><div class="line">		double result = getLargestArr(arr);</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line">	private static double getLargestArr(double[] arr) &#123;</div><div class="line">		double maxEnd = arr[0];</div><div class="line">		double minEnd = arr[0];</div><div class="line">		double maxResult = arr[0];</div><div class="line">		for(int i=1;i&lt;arr.length;i++)&#123;</div><div class="line">			// maxEnd和minEnd分别保存arr[i]之前的最大值和最小值</div><div class="line">			double end1=maxEnd*arr[i],end2=minEnd*arr[i];</div><div class="line">			// 状态转移方程</div><div class="line">			maxEnd = Math.max(Math.max(end1,end2),arr[i]);</div><div class="line">			minEnd = Math.min(Math.min(end1, end2),arr[i]);</div><div class="line">			maxResult=Math.max(maxResult,maxEnd);</div><div class="line">		&#125;</div><div class="line">		return maxResult;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">最优子问题和无后效性保证。一个状态下的最优值取决于到达这个状态的全部子状态的最优值，且状态之间的最优值不互相影响</div><div class="line">动态规划实质上是一种递推。假设当前状态是S，所有能达到S的状态是S&apos;&apos;，用f(state)表示在状态state下的最优值，payoff表示代价，则有</div><div class="line">f(S)=min&#123;f(S&apos;&apos;)+payoff(S&apos;&apos;-&gt;S)&#125;</div></pre></td></tr></table></figure>
<h3 id="最长回文字符串"><a href="#最长回文字符串" class="headerlink" title="最长回文字符串"></a>最长回文字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class LongestString &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String str=&quot;aabaabac&quot;;</div><div class="line">		System.out.println(LongestString(str));</div><div class="line">	&#125;</div><div class="line">	private static int LongestString(String str) &#123;</div><div class="line">		int max=0,c=0;</div><div class="line">		if(str==null)</div><div class="line">			return 0;</div><div class="line">		char[] ch = str.toCharArray();</div><div class="line">		for(int i=0;i&lt;ch.length-1;i++)&#123;</div><div class="line">			// 最中间位置可能为单个字符回文</div><div class="line">			String str1 = getLongestString(ch,i,i);</div><div class="line">			// 最中间位置可能为两个字符回文</div><div class="line">			String str2 = getLongestString(ch,i,i+1);</div><div class="line">			c = str1.length() &gt; str2.length()?str1.length() : str2.length();</div><div class="line">			max = max &gt; c?max:c;</div><div class="line">		&#125;</div><div class="line">		return max;</div><div class="line">	&#125;</div><div class="line">	private static String getLongestString(char[] ch, int i, int j) &#123;</div><div class="line">		int l = i;</div><div class="line">		int r  = j;</div><div class="line">		while(l&gt;=0 &amp;&amp; r&lt;=ch.length-1 &amp;&amp; ch[l]==ch[r])&#123;</div><div class="line">			l--;</div><div class="line">			r++;</div><div class="line">		&#125;</div><div class="line">		return String.valueOf(ch).substring(l+1, r);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最大连续子数组和"><a href="#最大连续子数组和" class="headerlink" title="最大连续子数组和"></a>最大连续子数组和</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 方法一</div><div class="line">	private static int getMaxSum(int[] arr) &#123;</div><div class="line">		int currSum=0;</div><div class="line">		int maxSum=Integer.MIN_VALUE;</div><div class="line">		for(int j=0;j&lt;arr.length;j++)&#123;</div><div class="line">			if(currSum&gt;=0)</div><div class="line">				currSum += arr[j];</div><div class="line">			// 小于0则记录当前值，然后从下一个开始重新计算最大值</div><div class="line">			else</div><div class="line">				currSum = arr[j];</div><div class="line">			if(currSum &gt; maxSum)</div><div class="line">				maxSum = currSum;</div><div class="line">		&#125;</div><div class="line">		return maxSum;</div><div class="line">	&#125;</div><div class="line">	// 方法二</div><div class="line">	private static int getMaxSum2(int[] arr)&#123;</div><div class="line">		int cur = 0;</div><div class="line">		int max =Integer.MIN_VALUE;</div><div class="line">		for (int i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">			cur += arr[i];</div><div class="line">			max = Math.max(max,cur);</div><div class="line">			cur = cur &lt; 0?0:cur;</div><div class="line">		&#125;</div><div class="line">		return max;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串的全排列"><a href="#字符串的全排列" class="headerlink" title="字符串的全排列"></a>字符串的全排列</h3><p>设一组数p = {r1, r2, r3, … ,rn}, 全排列为perm(p)，pn = p - {rn}。因此perm(p) = r1perm(p1), r2perm(p2), r3perm(p3), … , rnperm(pn)。当n = 1时perm(p} = r1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class QuanPaiLie &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] arr=&#123;1,2,3,4&#125;;</div><div class="line">		calcAllPermutation(arr,0,3);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void calcAllPermutation(int[] arr, int from, int to) &#123;</div><div class="line">		if(to&lt;=1)</div><div class="line">			return;</div><div class="line">		if(from==to)&#123;</div><div class="line">			for(int i=0;i&lt;=to;i++)&#123;</div><div class="line">				System.out.print(arr[i]);</div><div class="line">			&#125;</div><div class="line">			System.out.println();</div><div class="line">		&#125;else&#123;</div><div class="line">			for(int j=from;j&lt;=to;j++)&#123;</div><div class="line">				ArrayUtils.swap(arr, j, from);</div><div class="line">				calcAllPermutation(arr, from+1, to);</div><div class="line">				ArrayUtils.swap(arr, from,j);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关键的就是arrange方法的else里面的内容，我的理解是（以求str[] = {“a”,”b”,”c”}的排列为例子）：用i从str[st]做一遍循环：<br>每一次循环中，都要将str[i]与str[i]互相调换位置：第一次开始，”a”与自己换，这时候，递归调用arrange[str,st + 1, len]<br>这是在求取str[str…len - 1]的排列即”b”,”c”的排列；<br>第二次，”a”与”b”互相调换，递归调用arrange[str,str + 1, len]就是在求取{“a”,”c”}的排列。<br>第三次，”a”与”c”互相调换，递归调用arrange[str, str + 1,len]就是在求取”{“b”,”a}的排列。<br>下面再以”b”,”c”的排列求取为例：<br>首先还是做循环，第一次，”b”与自己调换，这时候，调用arrange[str,st + 1,len]就是求c的排列。呵呵，这时候终于到了函数递归调用的出口了<br>: st = len - 1。输出”b”  “c”;第二次，类似的，输出”c”,”b”;至此，”b” “c”的排列求取完毕。加上前面的a,就输出”a””b””c”  “a””c””b”。<br>类似的，就可以输出所有的排列了。</p>
<h3 id="第一次只出现一次的字符"><a href="#第一次只出现一次的字符" class="headerlink" title="第一次只出现一次的字符"></a>第一次只出现一次的字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class TheFirstOnceNum &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(firstNotRepeatingChar(&quot;google&quot;)); // l</div><div class="line">        System.out.println(firstNotRepeatingChar(&quot;aabccdbd&quot;)); // &apos;\0&apos;</div><div class="line">        System.out.println(firstNotRepeatingChar(&quot;abcdefg&quot;)); // a</div><div class="line">        System.out.println(firstNotRepeatingChar(&quot;gfedcba&quot;)); // g</div><div class="line">        System.out.println(firstNotRepeatingChar(&quot;zgfedcba&quot;)); // g</div><div class="line">	&#125;</div><div class="line">	private static char firstNotRepeatingChar(String str) &#123;</div><div class="line">		HashMap&lt;Character, Integer&gt; hm = new HashMap&lt;Character,Integer&gt;();</div><div class="line">		for(int i=0;i&lt;str.length();i++)&#123;</div><div class="line">			char c = str.charAt(i);</div><div class="line">			if(hm.containsKey(c))&#123;</div><div class="line">				// 若已存在，则排除，把value设置为负数，在最后判断的时候根据value排除</div><div class="line">				hm.put(c, -2);</div><div class="line">			&#125;else&#123;</div><div class="line">				hm.put(c, i);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		int idx = Integer.MAX_VALUE;</div><div class="line">		char result = &apos; &apos;;</div><div class="line">		for(Map.Entry&lt;Character, Integer&gt; entry : hm.entrySet())&#123;</div><div class="line">			if(entry.getValue() &gt;= 0 &amp;&amp; entry.getValue() &lt; idx)&#123;</div><div class="line">				// idx保存字符串中位置的索引，选择最小的就是最早出现的。</div><div class="line">				idx = entry.getValue();</div><div class="line">				// idx对应的字符</div><div class="line">				result = entry.getKey();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="寻找和为定值的多个数"><a href="#寻找和为定值的多个数" class="headerlink" title="寻找和为定值的多个数"></a>寻找和为定值的多个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class SumGivenNumber &#123;</div><div class="line">	static Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;();</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		sumOfNumber(10, 8);</div><div class="line">	&#125;</div><div class="line">	public static void sumOfNumber(int sum, int n) &#123;</div><div class="line">		if (n &lt;= 0 || sum &lt;= 0)</div><div class="line">			return;</div><div class="line">		if (sum == n) &#123;</div><div class="line">			System.out.print(n+&quot; &quot;);</div><div class="line">			Enumeration&lt;Integer&gt; elements = st.elements();</div><div class="line">			while (elements.hasMoreElements()) &#123;</div><div class="line">				System.out.print(elements.nextElement()+&quot; &quot;);</div><div class="line">			&#125;</div><div class="line">			System.out.println();</div><div class="line">		&#125;</div><div class="line">		st.push(n);</div><div class="line">		sumOfNumber(sum - n, n - 1);</div><div class="line">		st.pop();</div><div class="line">		sumOfNumber(sum, n - 1);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法-字符串相关]]></title>
      <url>http://yoursite.com/2016/04/10/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h3 id="句子逆序输出"><a href="#句子逆序输出" class="headerlink" title="句子逆序输出"></a>句子逆序输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">/** 句子逆序</div><div class="line"> * 将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”</div><div class="line"> * 所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符</div><div class="line"> */</div><div class="line">import java.util.Scanner;</div><div class="line"></div><div class="line"></div><div class="line">public class StringReverse &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		Scanner sc = new Scanner(System.in);</div><div class="line">		while(sc.hasNext())&#123;</div><div class="line">			String str = sc.nextLine();</div><div class="line">			String result = reverse(str);</div><div class="line">			System.out.println(result);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public static  String reverse(String sentence)&#123;</div><div class="line">		char[] arr = sentence.toCharArray();</div><div class="line">		rev(arr,0,arr.length-1);</div><div class="line">		int start=0,end=0;</div><div class="line">		while(arr[start]==&apos; &apos;) start++;</div><div class="line">		while(arr[end]!=&apos;\0&apos; &amp;&amp; end &lt; arr.length-1)&#123;</div><div class="line">			while(end &lt; arr.length-1 &amp;&amp; arr[end]!=&apos; &apos;)</div><div class="line">				end++;</div><div class="line">			if(end==arr.length-1)&#123;</div><div class="line">				rev(arr,start,end);</div><div class="line">			&#125;else</div><div class="line">				rev(arr,start,end-1);</div><div class="line">			if(arr[end]==&apos; &apos; &amp;&amp; arr[end]!=&apos;\0&apos;)&#123;</div><div class="line">				end++;</div><div class="line">				start=end;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return new String(arr);</div><div class="line">	&#125;</div><div class="line">	public static void rev(char arr[],int start,int end)&#123;</div><div class="line">		char temp;</div><div class="line">		while(start&lt;end)&#123;</div><div class="line">			temp = arr[start];</div><div class="line">			arr[start] = arr[end];</div><div class="line">			arr[end] = temp;</div><div class="line">			start++;</div><div class="line">			end--;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="替换空格为指定字符串"><a href="#替换空格为指定字符串" class="headerlink" title="替换空格为指定字符串"></a>替换空格为指定字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 替换字符串</div><div class="line"> * 将字符串中的每个空格替换成&apos;%20&apos;</div><div class="line"> * eg &quot;we are happy&quot; 替换为&quot;we%20are%20happy.&quot;</div><div class="line"> * 需求：将特殊符号转换为服务器可以识别的字符，转换的规则是在&apos;%&apos;后面跟上ASCII码的两位十六进制的表示</div><div class="line"> */</div><div class="line">public class ReplaceBlank &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		String str = &quot;We Are Happy.&quot;;</div><div class="line">		String st = replaceChar(str);</div><div class="line">		System.out.println(st);</div><div class="line">	&#125;</div><div class="line">	public static String replaceChar(String str)&#123;</div><div class="line">		char[] ch = str.toCharArray();</div><div class="line">		int i=0;</div><div class="line">		int numBlack=0;</div><div class="line">		int numOrigin=ch.length;</div><div class="line">		while(i&lt;ch.length)&#123;</div><div class="line">			if(ch[i]==&apos; &apos;)</div><div class="line">				++numBlack;</div><div class="line">			++i;</div><div class="line">		&#125;</div><div class="line">		int newLength = numOrigin+numBlack*2;</div><div class="line">		char[] chs = new char[newLength];</div><div class="line">		int newOrigin = numOrigin-1;</div><div class="line">		newLength--;</div><div class="line">		while(newOrigin&gt;=0)&#123;</div><div class="line">			if(ch[newOrigin]==&apos; &apos;)&#123;</div><div class="line">				chs[newLength--]=&apos;0&apos;;</div><div class="line">				chs[newLength--]=&apos;2&apos;;</div><div class="line">				chs[newLength--]=&apos;%&apos;;</div><div class="line">			&#125;else&#123;</div><div class="line">				chs[newLength--]=ch[newOrigin];</div><div class="line">			&#125;</div><div class="line">			newOrigin--;</div><div class="line">		&#125;</div><div class="line">		return new String(chs);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CocurrentHashMap源码理解]]></title>
      <url>http://yoursite.com/2016/04/06/CocurrentHashMap%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="CurrentHashMap-笔记"><a href="#CurrentHashMap-笔记" class="headerlink" title="CurrentHashMap 笔记"></a>CurrentHashMap 笔记</h3><ol>
<li>ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/nuEZ0.png" alt="CurrentHashMap"></li>
<li>ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部，因此，这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长，但是带来的好处是写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，这样，在最理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（刚好这些写操作都非常平均地分布在所有的Segment上），所以，通过这一种结构，ConcurrentHashMap的并发能力可以大大的提高。</li>
<li>Segment的数据结构<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</div><div class="line">    transient volatile int count;</div><div class="line">    transient int modCount;</div><div class="line">    transient int threshold;</div><div class="line">    transient volatile HashEntry&lt;K,V&gt;[] table;</div><div class="line">    final float loadFactor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>segment成员变量意义<br>count：Segment中元素的数量<br>modCount：对table的大小造成影响的操作的数量（比如put或者remove操作）<br>threshold：阈值，Segment里面元素的数量超过这个值依旧就会对Segment进行扩容<br>table：链表数组，数组中的每一个元素代表了一个链表的头部<br>loadFactor：负载因子，用于确定threshold</p>
<p><strong>HashEntry</strong><br>Segment中的元素是以HashEntry的形式存放在链表数组中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static final class HashEntry&lt;K,V&gt; &#123;</div><div class="line">    final K key;</div><div class="line">    final int hash;</div><div class="line">    volatile V value;</div><div class="line">    final HashEntry&lt;K,V&gt; next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除了value以外，其他的几个变量都是final的，这样做是为了防止链表结构被破坏，出现ConcurrentModification的情况。</p>
<blockquote>
<p>注意： 初始化中的concurrentLevel，代表ConcurrentHashMap内部的Segment的数量，ConcurrentLevel一经指定，不可改变，后续如果ConcurrentHashMap的元素数量增加导致ConrruentHashMap需要扩容，ConcurrentHashMap不会增加Segment的数量，而只会增加Segment中链表数组的容量大小，这样的好处是扩容过程不需要对整个ConcurrentHashMap做rehash，而只需要对Segment里面的元素做一次rehash就可以了。<br>之所以进行再散列，目的是减少三列冲突，使元素能够均匀的分别在不同的Segment上，从而提高容器的存取效率。<br><strong>ConcurrentHashMap的get操作</strong><br>get操作不加锁因为get方法里将要使用的共享变量都定义成volatile类型。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java面试0312]]></title>
      <url>http://yoursite.com/2016/03/14/java%E9%9D%A2%E8%AF%950312/</url>
      <content type="html"><![CDATA[<h3 id="利用StringBuilder-重写toString-方法"><a href="#利用StringBuilder-重写toString-方法" class="headerlink" title="利用StringBuilder 重写toString()方法"></a>利用StringBuilder 重写toString()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public String toString() &#123;</div><div class="line">        StringBuilder sb = new StringBuilder(&quot;[&quot;);</div><div class="line">        Field[] fields = getClass().getDeclaredFields();</div><div class="line">        for (Field field : fields) &#123;</div><div class="line">            try &#123;</div><div class="line">                field.setAccessible(true);</div><div class="line">                sb.append(field.getName()).append(&quot;:&quot;).append(field.get(this)).append(&quot;,&quot;);</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 去掉多于的逗号</div><div class="line">        if(sb.length() &gt; 1)&#123;</div><div class="line">            sb.deleteCharAt(sb.length()-1);</div><div class="line">        &#125;</div><div class="line">        sb.append(&quot;]&quot;);</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="字节和位的转化"><a href="#字节和位的转化" class="headerlink" title="字节和位的转化"></a>字节和位的转化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Byte转Bit</div><div class="line"> */</div><div class="line">public static String byteToBit(byte b) &#123;</div><div class="line">    return &quot;&quot; + (byte) ((b &gt;&gt; 7) &amp; 0x1) + (byte) ((b &gt;&gt; 6) &amp; 0x1)</div><div class="line">            + (byte) ((b &gt;&gt; 5) &amp; 0x1) + (byte) ((b &gt;&gt; 4) &amp; 0x1)</div><div class="line">            + (byte) ((b &gt;&gt; 3) &amp; 0x1) + (byte) ((b &gt;&gt; 2) &amp; 0x1)</div><div class="line">            + (byte) ((b &gt;&gt; 1) &amp; 0x1) + (byte) ((b &gt;&gt; 0) &amp; 0x1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Bit转Byte</div><div class="line"> */</div><div class="line">public static byte BitToByte(String byteStr) &#123;</div><div class="line">    int re, len;</div><div class="line">    if (null == byteStr) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    len = byteStr.length();</div><div class="line">    if (len != 4 &amp;&amp; len != 8) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (len == 8) &#123;// 8 bit处理</div><div class="line">        if (byteStr.charAt(0) == &apos;0&apos;) &#123;// 正数</div><div class="line">            re = Integer.parseInt(byteStr, 2);</div><div class="line">        &#125; else &#123;// 负数</div><div class="line">            re = Integer.parseInt(byteStr, 2) - 256;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;// 4 bit处理</div><div class="line">        re = Integer.parseInt(byteStr, 2);</div><div class="line">    &#125;</div><div class="line">    return (byte) re;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReadWriteLock 中若Reader优先的话会无限期地延迟 writer，而 writer 优先会减少可能的并发。</p>
<h3 id="垃圾收集算法："><a href="#垃圾收集算法：" class="headerlink" title="垃圾收集算法："></a>垃圾收集算法：</h3><p>可达性分析： 将一些列gc roots 对象作为起始点，当一个对象到gc roots 没有任何引用链相连时，则不可用<br>一、标记-清除算法<br>    缺点：效率低，会产生空间碎片<br>二、复制算法<br>    一块Eden，两块survivor清理时将一块Eden和一块survivor上存活的对象复制到剩下的那块survivor上，之后清理掉前两者。<br>三、标记-整理算法<br>    标记后，将所有存活的对象向一段移动，剩下的清理。<br>四、分代收集算法<br>    商业虚拟机均用此，根据对象存活周期的不同分为新生代和老年代，新生代用复制算法，老年代用标记清除算法和标记整理算法。</p>
<h3 id="wait-、sleep-、notify-、notifyAll-区别"><a href="#wait-、sleep-、notify-、notifyAll-区别" class="headerlink" title="wait()、sleep()、notify()、notifyAll()区别"></a>wait()、sleep()、notify()、notifyAll()区别</h3><p>wait():使一个线程处于等待状态，并且释放锁。<br>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。此方法不会释放锁。<br>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程(一般是最先开始等待的线程)，而且不是按优先级。<br>notityAll():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
<p>JDK1.5中提供了多线程升级的解决方案：将同步synchonized替换成了显式的Lock操作，将Object中的wait、notify、notifyAll替换成了Condition对象。</p>
<h3 id="Lock的方法摘要："><a href="#Lock的方法摘要：" class="headerlink" title="Lock的方法摘要："></a>Lock的方法摘要：</h3><p>void lock()  获取锁。<br>Condition newCondition() 返回绑定到此 Lock 实例的新 Condition 实例。<br>void unlock() 释放锁。<br>Condition方法摘要：<br>void await() 造成当前线程在接到信号或被中断之前一直处于等待状态。<br>void signal() 唤醒一个等待线程。<br>void signalAll() 唤醒所有等待线程。</p>
<h3 id="守护线程-后台线程"><a href="#守护线程-后台线程" class="headerlink" title="守护线程(后台线程)"></a>守护线程(后台线程)</h3><p>setDaemon(boolean on):将该线程标记为守护线程或者用户线程。当正在运行的线程都是守护线程时，java虚拟机jvm退出；所以该方法必须在启动线程前调用；</p>
<h3 id="进程线程管程区别"><a href="#进程线程管程区别" class="headerlink" title="进程线程管程区别"></a>进程线程管程区别</h3><p>进程 ： 一个程序在一个数据集合上的一次运行过程，是资源分配的最小单位，进程无法突破进程边界存取其他进程内的存储空间<br>线程 ： 线程是进程中的一个实体，是被系统独立调度和执行的最小单位，同一进程所产生的线程共享同一内存空间。<br>管程： 管程是定义了一个数据结构和在该数据结构上的能为并发进程锁执行的一组操作，这组操作能同步进程和改变管程上的数据<br>进程间通信 信号量、消息队列、共享内存</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>产生死锁的条件：　互斥、请求与保持、不剥夺条件、循环等待条件<br>解除与预防：<br>1.采用资源静态分配策略，破坏”部分分配”条件<br>2.允许进程剥夺使用其他进程占有的资源，破坏不可剥夺条件<br>3.采用资源有序分配法，破坏环路条件</p>
<h3 id="静态链接库和动态链接库"><a href="#静态链接库和动态链接库" class="headerlink" title="静态链接库和动态链接库"></a>静态链接库和动态链接库</h3><p>都是共享代码的方式，如果采用静态链接库，lib中的指令都全部被直接包含在最终生成的exe文件中了。但是若使用dll，该dll不被包含在最终exe文件中，exe文件执行时可以动态的引用和卸载这个与exe独立的dll文件。</p>
<h3 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h3><p>1.聚集索引的顺序就是数据的物理存储顺序，非聚集索引的索引顺序与物理顺序无关。<br>2.一个表只能包含一个聚集索引，可以有多个非聚集索引<br>3.聚集索引对于那些经常要搜索范围值的列有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻<br>4.非索引存储中的项目按索引键值的顺序存储，而表中信息按另一种顺序存储。</p>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>1、寻找jre目录，寻找jvm.dll，并初始化JVM；<br>2、产生一个Bootstrap Loader（启动类加载器）；<br>3、Bootstrap Loader自动加载Extended Loader（标准扩展类加载器），并将其父Loader设为Bootstrap Loader。<br>4、Bootstrap Loader自动加载AppClass Loader（系统类加载器），并将其父Loader设为Extended Loader。<br>5、最后由AppClass Loader加载HelloWorld类。</p>
<h3 id="类加载器的特点"><a href="#类加载器的特点" class="headerlink" title="类加载器的特点"></a>类加载器的特点</h3><p>1、运行一个程序时，总是由AppClass Loader（系统类加载器）开始加载指定的类。<br>2、在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载。<br>3、Bootstrap Loader（启动类加载器）是最顶级的类加载器了，其父加载器为null.</p>
<h3 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h3><p>1.在启动一个java程序的同时会诞生一个虚拟机实例，当该程序退出时，虚拟机实例也随之消亡。如果在同一计算机同时运行三个java程序，会得到三个java虚拟机实例。每个java程序都运行在自己的java虚拟机实例中。<br>2.java栈是由许多栈帧组成的，一个栈帧包含一个java方法调用的状态。当线程调用一个java方法时，虚拟机压入一个新的栈帧到该线程的java栈中；当该方法返回时，这个栈帧被从java栈中弹出并抛弃。<br>3.对于一个正在运行java方法的线程而言，它的PC寄存器总是指向下一条将被执行的指令。</p>
<h3 id="什么是ThreadLocal类-怎么使用它？"><a href="#什么是ThreadLocal类-怎么使用它？" class="headerlink" title="什么是ThreadLocal类,怎么使用它？"></a>什么是ThreadLocal类,怎么使用它？</h3><p>一个线程局部变量(ThreadLocal variables)为每个线程方便地提供了一个单独的变量。<br>ThreadLocal 实例通常作为静态的私有的(private static)字段出现在一个类中，这个类用来关联一个线程。当多个线程访问 ThreadLocal 实例时，每个线程维护 ThreadLocal 提供的独立的变量副本。</p>
<blockquote>
<p>常用的使用可在 DAO 模式中见到，当 DAO 类作为一个单例类时，数据库链接(connection)被每一个线程独立的维护，互不影响。(基于线程的单例)</p>
</blockquote>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>1.为避免其他程序创建该类对象，将构造函数私有化<br>2.为了其他程序访问到该类对象，须在本类中创建一个该类私有对象<br>3.为了方便其他程序访问该类对象，可对外提供一个公共访问方式<br>比如API中的Runtime类就是单例设计模式。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>(1)最终的意思，可以用于修饰类，方法，变量。<br>(2)final修饰的类不能被继承。final修饰的方法不能被重写。final修饰的变量是一个常量。只能被赋值一次。<br>  内部类只能访问被final修饰的局部变量。</p>
<h3 id="模板设计模式："><a href="#模板设计模式：" class="headerlink" title="模板设计模式："></a>模板设计模式：</h3><p>在定义功能时，功能的一部分是确定的，有一部分是不确定的，而且确定的部分在使用不确定的部分，<br>可将不确定的部分暴露出去，由该类的子类去完成。<br>如：求一段程序的运行时间例子。</p>
<h3 id="Mess"><a href="#Mess" class="headerlink" title="Mess"></a>Mess</h3><p>不重写Bean的hashCode()方法是否会对性能带来影响？<br>如果一个计算hash的方法写得不好，直接的影响是，当向HashMap中添加元素的时候会更频繁地造成冲突<br>对于一个不可修改的类，它的每个对象是不是都必须声明成final的？<br>不尽然，可以将成员声明为private，不为它提供setter方法，同时不会通过任何方法泄漏出对此成员的引用高就可以不被别的类修改。注意：把对象声明为final仅仅保证了它不会被重新赋值，你仍然可以通过此引用过来修改引用对象的属性。</p>
<h3 id="什么是不可修改对象-Immutable-Object-？你能否写一个例子？"><a href="#什么是不可修改对象-Immutable-Object-？你能否写一个例子？" class="headerlink" title="什么是不可修改对象(Immutable Object)？你能否写一个例子？"></a>什么是不可修改对象(Immutable Object)？你能否写一个例子？</h3><p>不可修改对象是那些一旦被创建就不能修改的对象。例如Java中的String类就是不可修改的。大多数这样的类通常都是final类型的，因为这样可以避免自己被继承继而被覆盖方法，你同样要保证你的类不要通过任何方法暴露成员，当你通过类函数返回一个可修改对象的时候，返回一个类成功的副本，防止客户代码通过此引用修改了成员对象的属性。</p>
<h3 id="双亲委派模型的工作过程为："><a href="#双亲委派模型的工作过程为：" class="headerlink" title="双亲委派模型的工作过程为："></a>双亲委派模型的工作过程为：</h3><p>1、前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。<br>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。<br>2、当前 classLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.<br>3、当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。<br>classloader 有两种装载class的方式<br>1、隐式：运行过程中，碰到new方式生成对象时，隐式调用classLoader到JVM<br>2、显式：通过class.forname()动态加载</p>
<h3 id="JVM-运行时数据区-JVM-Runtime-Area"><a href="#JVM-运行时数据区-JVM-Runtime-Area" class="headerlink" title="JVM 运行时数据区 (JVM Runtime Area)"></a>JVM 运行时数据区 (JVM Runtime Area)</h3><p>6个区域：<br>1、PC程序计数器：一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器, NAMELY存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。Java 的多线程机制离不开程序计数器，每个线程都有一个自己的PC，以便完成不同线程上下文环境的切换。<br>2、java虚拟机栈：与 PC 一样，java 虚拟机栈也是线程私有的。每一个 JVM 线程都有自己的 java 虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈<br>帧在虚拟机栈中从入栈到出栈的过程。<br>3、本地方法栈：与虚拟机栈的作用相似，虚拟机栈为虚拟机执行执行java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务。<br>4、Java堆：被所有线程共享的一块存储区域，在虚拟机启动时创建，它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。<br>Java堆在JVM启动的时候就被创建，堆中储存了各种对象，这些对象被自动管理内存系统（Automatic Storage Management System，也即是常说的 “Garbage Collector（垃圾回收器）”）所管理。这些对象无需、也无法显示地被销毁。<br>JVM将Heap分为两块：新生代New Generation和旧生代Old Generation<br>Note:<br>堆在JVM是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是new开销比较大的原因。<br>5、方法区<br>方法区和堆区域一样，是各个线程共享的内存区域，它用于存储每一个类的结构信息，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。当开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。<br>方法区也是全局共享的，在虚拟机启动时候创建。在一定条件下它也会被GC。这块区域对应Permanent Generation 持久代。 XX：PermSize指定大小。<br>6、运行时常量池其空间从方法区中分配，存放的为类中固定的常量信息、方法和域的引用信息。</p>
<h3 id="获得给定数字n的第i位"><a href="#获得给定数字n的第i位" class="headerlink" title="获得给定数字n的第i位"></a>获得给定数字n的第i位</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 从右往左数第i位</div><div class="line">public static int getBit(int num,int i)&#123;</div><div class="line">        int result = num &amp; (i-1&lt;&lt;1);</div><div class="line">        return result &gt; 0? 1:0;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="重写equals方法"><a href="#重写equals方法" class="headerlink" title="重写equals方法"></a>重写equals方法</h3><p>1.使用==符号检查“参数是否为这个对象的引用”。如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。<br>2.使用instanceof操作符检查“参数是否为正确的类型”。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。<br>3.把参数转换成正确的类型。因为转换之前进行过instanceof测试，所以确保会成功。<br>4.对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回true;否则返回false。<br>5.当编写完成了equals方法之后，检查“对称性”、“传递性”、“一致性”。</p>
<h3 id="重写hashCode方法意义？"><a href="#重写hashCode方法意义？" class="headerlink" title="重写hashCode方法意义？"></a>重写hashCode方法意义？</h3><ul>
<li>在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。</li>
<li>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li>
<li>如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。</li>
<li>如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。</li>
</ul>
<p>###hashCode()和equals()方法有何重要性？<br>HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。<br>同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：<br>（1）如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。<br>（2）如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。</p>
<h3 id="transient变量有什么特点"><a href="#transient变量有什么特点" class="headerlink" title="transient变量有什么特点?"></a>transient变量有什么特点?</h3><p>答案：transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。</p>
<h3 id="String和StringTokenizer的区别是什么？"><a href="#String和StringTokenizer的区别是什么？" class="headerlink" title="String和StringTokenizer的区别是什么？"></a>String和StringTokenizer的区别是什么？</h3><p>答案：StringTokenizer是一个用来分割字符串的工具类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">StringTokenizer st = new StringTokenizer(”Hello World”);</div><div class="line">// 根据delim分割字符串，false表示delim不参与输出</div><div class="line">StringTokenizer st = new StringTokenizer(&quot;www.baidu.com&quot;, &quot;.a&quot;, false);</div><div class="line">while (st.hasMoreTokens()) &#123;</div><div class="line">    System.out.println(st.nextToken());</div><div class="line">&#125;</div><div class="line">输出：</div><div class="line">Hello</div><div class="line">World</div></pre></td></tr></table></figure></p>
<h3 id="HashMap和HashTable有何不同？"><a href="#HashMap和HashTable有何不同？" class="headerlink" title="HashMap和HashTable有何不同？"></a>HashMap和HashTable有何不同？</h3><p>1.HashMap允许key和value为null，而HashTable不允许。<br>2.HashTable是同步的，而HashMap不是。所以HashMap适合单线程环境，HashTable适合多线程环境。<br>3.假如你想要遍历顺序，你很容易从HashMap转向LinkedHashMap，但是HashTable不是这样的，它的顺序是不可预知的。<br>4.HashMap提供对key的Set进行遍历，因此它是fail-fast的，但HashTable提供对key的Enumeration进行遍历，它不支持fail-fast。<br>5.HashTable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。</p>
<h3 id="fail-fast-amp-amp-fail-safe"><a href="#fail-fast-amp-amp-fail-safe" class="headerlink" title="fail-fast &amp;&amp; fail-safe"></a>fail-fast &amp;&amp; fail-safe</h3><p>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p>
<p>我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。<br>   这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HashIterator() &#123;</div><div class="line">    expectedModCount = modCount;</div><div class="line">    if (size &gt; 0) &#123; // advance to first entry</div><div class="line">    Entry[] t = table;</div><div class="line">    while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</div><div class="line">        ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：<br>   注意到modCount声明为volatile，保证线程之间修改的可见性。</p>
<h3 id="保证集合不被修改"><a href="#保证集合不被修改" class="headerlink" title="保证集合不被修改"></a>保证集合不被修改</h3><p>在作为参数传递之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。</p>
<h3 id="final关键字-1"><a href="#final关键字-1" class="headerlink" title="final关键字"></a>final关键字</h3><ul>
<li>final修饰变量：<br>final修饰的变量只能被赋值一次，可以是在声明的时候进行初始化，也可以是在初始化函数中进行初始化，基本数据类型在赋值后它的值无法改变，如果是一个对象的引用则不能再指向其它对象，但是这个对象的值是可以改变的。比如一个指向StringBuilder的对象A，A不能再被赋值，但是这个StringBuilder对象的值是可以改变的。</li>
<li>final修饰的方法：<br>final修饰的方法不能被子类重写，Java编程思想中是这样说的：<br>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；</li>
<li>final修饰的类：<br>final修饰的类不能被继承，也就是说它所有的实现都不能被改变，方法不能被重写。常用于设计一些不想让使用者改变的类。</li>
</ul>
<h3 id="单例适用场景"><a href="#单例适用场景" class="headerlink" title="单例适用场景"></a>单例适用场景</h3><ul>
<li>控制资源的使用，通过线程同步来控制资源的并发访问</li>
<li>控制实例的产生，以达到节约资源的目的</li>
<li>控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li>
</ul>
<h3 id="堆内存三部分（新生代、老年代、永久代）"><a href="#堆内存三部分（新生代、老年代、永久代）" class="headerlink" title="堆内存三部分（新生代、老年代、永久代）"></a>堆内存三部分（新生代、老年代、永久代）</h3><p>1.新生代，新生区是类的诞生、成长、消亡的区域，一个类在这里产生、应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区和幸存者区，<br>所有的类都是在伊甸区被创建的，幸存区有两个：0区（Survivor 0）和1区(Survivor 1)。当伊甸区的空间用完，程序又需要创建对象，JVM的垃圾回收器将<br>对伊甸区进行垃圾回收，将伊甸区中的不再被其他对象所引用的对象进行销毁。然后将伊甸区中的剩余对象移动到幸存0区，若幸存0区也满了，再对该区进行<br>垃圾回收，然后移动到1区，如果1区也满了，就移动到老年区。<br>2.老年代，用于保存从新生区筛选出来的java对象，一般池对象都在这个区域活跃。<br>3.永久代 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class Interface 的元数据，也就是说，它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被回收器回收的，关闭JVM才会释放此区域所占用的内存。<br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B61.png" alt="java垃圾回收之新生代老年代永久代"></p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>由于疏忽或错误造成程序未能释放已经不再使用的内存，失去了对该段内存的控制，造成内存浪费。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>1.标记-清除算法<br>首先标记出所有需要回收的对象，在标完成后统一回收掉所有被标记的对象。缺点：效率不高，且标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致运行过程中需要分配大对象的时候无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作<br>2.复制算法<br>将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清理掉，内存使用率不高，现在商业虚拟机比如HotSpot都采用8:1的比例（Eden:Survivor）<br>3.标记-整理算法<br>把存活对象往内存的一端移动，然后直接回收边界以外的内存，提高了内存利用率，适合在收集对象存活时间较长的老年代。<br>4.分代收集算法<br>根据对象的存活时间把内存分为新生代和老年代，根据各代对象的存活特点，每个代采用不同的垃圾回收算法，新生代采用标记-复制算法，老年代采用标记-整理算法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程笔记]]></title>
      <url>http://yoursite.com/2016/03/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class ThreadLocalTest &#123;</div><div class="line">	private static ThreadLocal&lt;Integer&gt; seqNum = new ThreadLocal&lt;Integer&gt;()&#123;</div><div class="line">		protected Integer initialValue() &#123;</div><div class="line">			return 0;</div><div class="line">		&#125;;</div><div class="line">	&#125;;</div><div class="line">	// 便于后面删除该对象</div><div class="line">	public ThreadLocal&lt;Integer&gt; getThreadLocal()&#123;</div><div class="line">		return seqNum;</div><div class="line">	&#125;</div><div class="line">	public int getNextNum()&#123;</div><div class="line">		seqNum.set(seqNum.get()+1);</div><div class="line">		return seqNum.get();</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		ThreadLocalTest sn = new ThreadLocalTest();</div><div class="line">		TestClient t1 = new TestClient(sn);</div><div class="line">		TestClient t2 = new TestClient(sn);</div><div class="line">		TestClient t3 = new TestClient(sn);</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">		t3.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	private static class TestClient extends Thread&#123;</div><div class="line">		private ThreadLocalTest sn;</div><div class="line">		public TestClient(ThreadLocalTest sn)&#123;</div><div class="line">			this.sn = sn;</div><div class="line">		&#125;</div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			for(int i=0;i&lt;3;i++)&#123;</div><div class="line">				System.out.println(&quot;thread &quot;+Thread.currentThread().getName()+&quot; -&gt; &quot;+sn.getNextNum());</div><div class="line">			&#125;</div><div class="line">			//  每个线程用完的时候要记得删除，减少内存占用</div><div class="line">			// 使用ThreadLocal ，一般都是声明在静态变量中，如果不断的创建ThreadLocal而且没有调用其remove方法</div><div class="line">			//将会导致内存泄漏，特别是在高并发的web容器中</div><div class="line">			sn.getThreadLocal().remove();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="线程异常捕获"><a href="#线程异常捕获" class="headerlink" title="线程异常捕获"></a>线程异常捕获</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import java.lang.Thread.UncaughtExceptionHandler;</div><div class="line"></div><div class="line">public class ThreadMain &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ThreadB task = new ThreadB();</div><div class="line">		Thread thread = new Thread(task);</div><div class="line">		// 线程出现异常，通过设置 setUncaughtExceptionHandler 注册一个UncaughtExceptionHandler的对象实例来处理</div><div class="line">		thread.setUncaughtExceptionHandler(new ExceptionHandleThreadB());</div><div class="line">		thread.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ThreadB implements Runnable &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		// 一个会出现异常的线程</div><div class="line">		int number = Integer.parseInt(&quot;TTT&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//  实现  UncaughtExceptionHandler 接口 处理出现异常的实例</div><div class="line">class ExceptionHandleThreadB implements UncaughtExceptionHandler &#123;</div><div class="line">	@Override</div><div class="line">	public void uncaughtException(Thread t, Throwable e) &#123;</div><div class="line">		System.out.println(&quot;An Exception Has Been captured&quot;);</div><div class="line">		System.out.printf(&quot;Thread %s\n&quot;, t.getId());</div><div class="line">		System.out.printf(&quot;Exception : %s: %s\n&quot;, e.getClass().getName(),</div><div class="line">				e.getMessage());</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java面试]]></title>
      <url>http://yoursite.com/2016/03/11/java%E9%9D%A2%E8%AF%95/</url>
      <content type="html"><![CDATA[<h3 id="并行计算与分布式计算"><a href="#并行计算与分布式计算" class="headerlink" title="并行计算与分布式计算"></a>并行计算与分布式计算</h3><p>1.并行计算借助并行算法和并行编程语言能够实现进程及并行和线程级并行；而分布式计算只是将任务分成小块到各个计算机分别计算各自执行<br>2.粒度方面，并行计算中，处理器间的交互一般很频繁，往往具有细粒度和的开销的特征并且被认为是可靠的；分布式计算中，处理器间的交互不频繁，粗粒度，并被认为是不可靠的，并行计算注重短的执行时间，分布式计算则注重长的正常运行时间。<br>java中断机制是一种协作机制，也就是说通常并不能直接终止另一个线程，而需要被中断的线程自己处理中断</p>
<p>通常情况下，根线程组是System线程组，system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。也就是说system线程组是最顶级的父线程组<br>Thread.currentThread().getThreadGroup()  // 获得当前线程的线程组</p>
<h3 id="线程组和线程池的区别"><a href="#线程组和线程池的区别" class="headerlink" title="线程组和线程池的区别"></a>线程组和线程池的区别</h3><p>线程组和线程池作用不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。<br>注意： ThreadLocalMap 对象是以this指向的ThreadLocal对象为键进行查找的，和set方法是相对应的。<br>每一个线程都有一个独立的ThreadLocalMap 副本，它所存储的值，只能被当前线程读取和修改。</p>
<h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><p>每个线程都有自己的工作内存，工作内存存储了主存的某些变量的副本，当然线程的工作内存是有限制的，当线程操作某个对象时，执行顺序如下：<br>1.从主存复制变量到当前工作内存 (read and load)<br>2.执行代码，改变共享变量   (use and assign)<br>3.用工作内存数据刷新主存相关的内容   (store and write)<br>线程在引用变量时不能直接从内存中引用，如果线程工作内存中没有该变量，会从主存拷贝一个副本到工作内存中，read and load ，完成后线程会引用该副本，当同一线程再度引用该字段时，可能重新从主存获取变量副本 read load use ,也有可能直接引用原来的的副本，也就是说read load use顺序由JVM决定。产生时序性问题。</p>
<p>加锁和释放锁都需要此对象的资源，那肯定对象越小越好，所以方法块加锁使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private byte[] lock = new byte[1];</div><div class="line">public void methodB()&#123;</div><div class="line">	synchronized(lock)&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ReentrantLock 是工作中使用频率最高的方法块加锁</p>
<h3 id="Lock-与-synchronized-区别"><a href="#Lock-与-synchronized-区别" class="headerlink" title="Lock 与 synchronized 区别"></a>Lock 与 synchronized 区别</h3><ol>
<li>Lock使用起来更灵活，但是必须有释放锁的动作配合</li>
<li>Lock必须手动释放和开启锁，而synchronized不需要手动释放和开启锁</li>
<li>Lock只适用于代码块锁，而synchronized对象之间是互斥关系</li>
</ol>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Singleton&#123;</div><div class="line">	private static Singleton instance;</div><div class="line">	private static byte[] lock = new byte[1];</div><div class="line">	private Singleton&#123; &#125;</div><div class="line">	public static Singleton getInstance()&#123;</div><div class="line">		if(instance == null)&#123;</div><div class="line">			synchronized(lock)&#123;</div><div class="line">				if(instance == null) &#123;</div><div class="line">					instance = new Singleton();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CopyOnWrite机制"><a href="#CopyOnWrite机制" class="headerlink" title="CopyOnWrite机制"></a>CopyOnWrite机制</h3><p>CopyOnWrite 写时复制的容器，当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器copy，复制出一个新的容器，然后新的容器里<br>、添加元素，添加完元素之后，再将当前容器的引用指向新的容器。</p>
<p>线程池一定要在合理的单例模式下才有效</p>
<h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><p>1.降低资源消耗，重用已经创建好的线程，降低创建和销毁的开销<br>2.提高响应速度，不用等待创建线程就能立即执行<br>3.提高线程的可管理性，统一分配、调优和监控<br>4.防止服务器过载，防止内存溢出或者CPU耗尽</p>
<h3 id="对象引用的类型"><a href="#对象引用的类型" class="headerlink" title="对象引用的类型"></a>对象引用的类型</h3><p>Reference(or named Strong Reference)（ 强引用）：普通类型的引用。<br>SoftReference（ 软引用）：被这种引用指向的对象，如果此对象没要再被其他Strong Reference引用的话，可能在任何时候被GC。虽然是可能在任何时候被GC，但是通常是在可用内存数比较低的时候，并且在程序抛出OutOfMemoryError之前才发生对此对象的GC。SoftReference通常被用作实现Cache的对象引用，如果这个对象被GC了，那么他可以在任何时候再重新被创建。另外，根据JDK文档中介绍，实际JVM的实现是鼓励不回收最近创建和最近使用的对象。SoftReference 类的一个典型用途就是用于内存敏感的高速缓存。<br>WeakReference（弱引用）：如果一个被WeakReference引用的对象，当没要任何SoftReference和StrongReference引用时，立即会被GC。和SoftReference的区别是：WeakReference对象是被eagerly collected，即一旦没要任何SoftReference和StrongReference引用，立即被清楚；而只被SoftReference引用的对象，不回立即被清楚，只有当内存不够，即将发生OutOfMemoryError时才被清除，而且是先清除不常用的。SoftReference适合实现Cache用。WeakReference 类的一个典型用途就是规范化映射（ canonicalized mapping ）<br>PhantomReference（虚引用）：当没有StrongReference，SoftReference和WeakReference引用时，随时可被GC。通常和ReferenceQueue联合使用，管理和清除与被引用对象（没有finalize方法）相关的本地资源。</p>
<h3 id="简单工厂-工厂方法-抽象工厂"><a href="#简单工厂-工厂方法-抽象工厂" class="headerlink" title="简单工厂 工厂方法 抽象工厂"></a>简单工厂 工厂方法 抽象工厂</h3><p>简单工厂: 抽象了同一类型(比如不同品牌的笔记本电脑)产品的生产过程,通过工厂类来实现对不同产品生产过程的选择<br>工厂方法: 不仅抽象了产品类的生产过程,还抽象了工厂类本身. 将特定的产品的生产过程和特定的工厂相对应. 将原先工厂类中的选择提升到工程类以上的层级—即客户层级. 通过选择特定的工厂,来选择生产特定的产品.<br>抽象工厂: 在工厂方法的基础上,将特定的产品生产过程和特定的工厂类之间的对应关系解除,使得工厂类和产品类之间能够产生更多灵活的组合方式.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[堆排序]]></title>
      <url>http://yoursite.com/2016/03/11/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote>
<ul>
<li>堆是一种重要的数据结构，为一棵完全二叉树, 底层如果用数组存储数据的话，假设某个元素为序号为i(Java数组从0开始,i为0到n-1), 如果它有左子树，那么左子树的位置是2i+1，如果有右子树，右子树的位置是2i+2，如果有父节点，父节点的位置是(n-1)/2取整。分为最大堆和最小堆，最大堆的任意子树根节点不小于任意子结点，最小堆的根节点不大于任意子结点。所谓堆排序就是利用堆这种数据结构来对数组排序，我们使用的是最大堆。处理的思想和冒泡排序，选择排序非常的类似，一层层封顶，只是最大元素的选取使用了最大堆。最大堆的最大元素一定在第0位置，构建好堆之后，交换0位置元素与顶即可。堆排序为原位排序(空间小), 且最坏运行时间是O(n2)，是渐进最优的比较排序算法。</li>
</ul>
</blockquote>
<h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ArrayUtils &#123;</div><div class="line">	public static void printArray(int[] array)&#123;</div><div class="line">		System.out.print(&quot;&#123; &quot;);</div><div class="line">		for(int i=0;i&lt;array.length;i++)&#123;</div><div class="line">			System.out.print(array[i]);</div><div class="line">			if(i&lt;array.length-1)&#123;</div><div class="line">				System.out.print(&quot;,&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot; &#125; &quot;);</div><div class="line">	&#125;</div><div class="line">	public static void swap(int[] array,int index1,int index2)&#123;</div><div class="line">		int temp = array[index1];</div><div class="line">		array[index1] = array[index2];</div><div class="line">		array[index2] = temp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="堆排序核心算法"><a href="#堆排序核心算法" class="headerlink" title="堆排序核心算法"></a>堆排序核心算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">package com.Arr;</div><div class="line"></div><div class="line">import org.junit.experimental.max.MaxHistory;</div><div class="line"></div><div class="line">public class HeapSort &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] arr = &#123;7,8,0,2,9,6,4,5,1&#125;;</div><div class="line">		heapSort(arr);</div><div class="line">		ArrayUtils.printArray(arr);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void heapSort(int[] arr) &#123;</div><div class="line">		if (arr == null || arr.length &lt;= 1) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">		buildMaxHeap(arr);</div><div class="line">		for(int i=arr.length-1;i&gt;=0;i--)&#123;</div><div class="line">			ArrayUtils.swap(arr, 0, i);</div><div class="line">			maxHeap(arr, i, 0);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void buildMaxHeap(int[] arr) &#123;</div><div class="line">		if (arr == null || arr.length &lt;= 1) &#123;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		int half = (arr.length-1)/2;</div><div class="line">		for(int i=half;i&gt;=0;i--)&#123;</div><div class="line">			maxHeap(arr,arr.length,i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void maxHeap(int[] arr, int length, int index) &#123;</div><div class="line">		 int left = 2*index+1;</div><div class="line">		 int right = 2*index+2;</div><div class="line">		 int largestIndex = index;</div><div class="line">		if(left &lt; length &amp;&amp; arr[left] &gt; arr[largestIndex])</div><div class="line">			largestIndex = left;</div><div class="line">		if(right &lt; length &amp;&amp; arr[right] &gt; arr[largestIndex])</div><div class="line">			largestIndex = right;</div><div class="line">		if(largestIndex!=index)&#123;</div><div class="line">			ArrayUtils.swap(arr, index, largestIndex);</div><div class="line">			maxHeap(arr, length, largestIndex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class MergeSort &#123;</div><div class="line">	public static int[] sort(int[] nums, int low, int high) &#123;</div><div class="line">		int mid = (low + high) / 2;</div><div class="line">		if (low &lt; high) &#123;</div><div class="line">			// 左边</div><div class="line">			sort(nums, low, mid);</div><div class="line">			// 右边</div><div class="line">			sort(nums, mid + 1, high);</div><div class="line">			// 左右归并</div><div class="line">			merge(nums, low, mid, high);</div><div class="line">		&#125;</div><div class="line">		return nums;</div><div class="line">	&#125;</div><div class="line">	public static void merge(int[] nums, int low, int mid, int high) &#123;</div><div class="line">		int[] temp = new int[high - low + 1];</div><div class="line">		int i = low;// 左指针</div><div class="line">		int j = mid + 1;// 右指针</div><div class="line">		int k = 0;</div><div class="line">		// 把较小的数先移到新数组中</div><div class="line">		while (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</div><div class="line">			if (nums[i] &lt; nums[j]) &#123;</div><div class="line">				temp[k++] = nums[i++];</div><div class="line">			&#125; else &#123;</div><div class="line">				temp[k++] = nums[j++];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		// 把左边剩余的数移入数组</div><div class="line">		while (i &lt;= mid) &#123;</div><div class="line">			temp[k++] = nums[i++];</div><div class="line">		&#125;</div><div class="line">		// 把右边边剩余的数移入数组</div><div class="line">		while (j &lt;= high) &#123;</div><div class="line">			temp[k++] = nums[j++];</div><div class="line">		&#125;</div><div class="line">		// 把新数组中的数覆盖nums数组</div><div class="line">		for (int k2 = 0; k2 &lt; temp.length; k2++) &#123;</div><div class="line">			nums[k2 + low] = temp[k2];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	// 归并排序的实现</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[] nums = &#123; 2, 7, 8, 3, 1, 6, 9, 0, 5, 4 &#125;;</div><div class="line">		MergeSort.sort(nums, 0, nums.length - 1);</div><div class="line">		System.out.println(Arrays.toString(nums));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class SortQuick &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[] arr = &#123; 3, 5, 6, 9, -1, 4, 8, 2, 7 &#125;;</div><div class="line">		quickSort(arr, 0, arr.length - 1);</div><div class="line">		ArrayUtils.printArray(arr);</div><div class="line">	&#125;</div><div class="line">	private static void quickSort(int[] arr, int i, int j) &#123;</div><div class="line">		if (i &lt; j) &#123;</div><div class="line">			int pivot = qSort(arr, i, j);</div><div class="line">			quickSort(arr, i, pivot - 1);</div><div class="line">			quickSort(arr, pivot + 1, j);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private static int qSort(int[] arr, int i, int j) &#123;</div><div class="line">		int n = arr[i];</div><div class="line">		while (i &lt; j) &#123;</div><div class="line">			while (i &lt; j &amp;&amp; arr[j] &gt;= n)</div><div class="line">				j--;</div><div class="line">			arr[i] = arr[j];</div><div class="line">			while (i &lt; j &amp;&amp; arr[i] &lt;= n)</div><div class="line">				i++;</div><div class="line">			arr[j] = arr[i];</div><div class="line">		&#125;</div><div class="line">		arr[i] = n;</div><div class="line">		return i;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="位排序"><a href="#位排序" class="headerlink" title="位排序"></a>位排序</h3><p>把数组元素作为键，boolean元素作为值映射到数组上，然后顺序遍历数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private static void bitSort(int[] arr) &#123;</div><div class="line">		boolean[] bitMap = new boolean[256];</div><div class="line">		for(int i=0;i&lt;bitMap.length;i++)</div><div class="line">			bitMap[i] = false;</div><div class="line">		for(int i=0;i&lt;arr.length;i++)&#123;</div><div class="line">			if(arr[i]!=0)</div><div class="line">				bitMap[arr[i]]=true;</div><div class="line">		&#125;</div><div class="line">		for(int i=0;i&lt;bitMap.length;i++)</div><div class="line">			if(bitMap[i]==true)</div><div class="line">				System.out.print(i);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java线程池]]></title>
      <url>http://yoursite.com/2016/03/08/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<p>1、线程池简介：<br>多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。<br>假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。<br>如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。<br>一个线程池包括以下四个基本组成部分：<br>1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；<br>2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；<br>3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态<br>4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。<br>线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。<br>线程池不仅调整T1,T3产生的时间段，而且它还显著减少了创建线程的数目，看一个例子：<br>假设一个服务器一天要处理50000个请求，并且每个请求需要一个单独的线程完成。在线程池中，线程数一般是固定的，所以产生线程总数不会超过线程池中线程的数目，而如果服务器不利用线程池来处理这些请求则线程总数为50000。一般线程池大小是远小于50000。所以利用线程池的服务器程序不会为了创建50000而在处理请求时浪费时间，从而提高效率。</p>
<p>代码实现中并没有实现任务接口，而是把Runnable对象加入到线程池管理器（ThreadPool），然后剩下的事情就由线程池管理器（ThreadPool）来完成了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line">package mine.util.thread;</div><div class="line">import java.util.LinkedList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 线程池类，线程管理器：创建线程，执行任务，销毁线程，获取线程基本信息</div><div class="line"> */</div><div class="line">public final class ThreadPool &#123;</div><div class="line">    // 线程池中默认线程的个数为5</div><div class="line">    private static int worker_num = 5;</div><div class="line">    // 工作线程</div><div class="line">    private WorkThread[] workThrads;</div><div class="line">    // 未处理的任务</div><div class="line">    private static volatile int finished_task = 0;</div><div class="line">    // 任务队列，作为一个缓冲,List线程不安全</div><div class="line">    private List&lt;Runnable&gt; taskQueue = new LinkedList&lt;Runnable&gt;();</div><div class="line">    private static ThreadPool threadPool;</div><div class="line"></div><div class="line">    // 创建具有默认线程个数的线程池</div><div class="line">    private ThreadPool() &#123;</div><div class="line">        this(5);</div><div class="line">    &#125;</div><div class="line">    // 创建线程池,worker_num为线程池中工作线程的个数</div><div class="line">    private ThreadPool(int worker_num) &#123;</div><div class="line">        ThreadPool.worker_num = worker_num;</div><div class="line">        workThrads = new WorkThread[worker_num];</div><div class="line">        for (int i = 0; i &lt; worker_num; i++) &#123;</div><div class="line">            workThrads[i] = new WorkThread();</div><div class="line">            workThrads[i].start();// 开启线程池中的线程</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 单态模式，获得一个默认线程个数的线程池</div><div class="line">    public static ThreadPool getThreadPool() &#123;</div><div class="line">        return getThreadPool(ThreadPool.worker_num);</div><div class="line">    &#125;</div><div class="line">    // 单态模式，获得一个指定线程个数的线程池,worker_num(&gt;0)为线程池中工作线程的个数</div><div class="line">    // worker_num&lt;=0创建默认的工作线程个数</div><div class="line">    public static ThreadPool getThreadPool(int worker_num1) &#123;</div><div class="line">        if (worker_num1 &lt;= 0)</div><div class="line">            worker_num1 = ThreadPool.worker_num;</div><div class="line">        if (threadPool == null)</div><div class="line">            threadPool = new ThreadPool(worker_num1);</div><div class="line">        return threadPool;</div><div class="line">    &#125;</div><div class="line">    // 执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定</div><div class="line">    public void execute(Runnable task) &#123;</div><div class="line">        synchronized (taskQueue) &#123;</div><div class="line">            taskQueue.add(task);</div><div class="line">            taskQueue.notify();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定</div><div class="line">    public void execute(Runnable[] task) &#123;</div><div class="line">        synchronized (taskQueue) &#123;</div><div class="line">            for (Runnable t : task)</div><div class="line">                taskQueue.add(t);</div><div class="line">            taskQueue.notify();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 批量执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器觉定</div><div class="line">    public void execute(List&lt;Runnable&gt; task) &#123;</div><div class="line">        synchronized (taskQueue) &#123;</div><div class="line">            for (Runnable t : task)</div><div class="line">                taskQueue.add(t);</div><div class="line">            taskQueue.notify();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 销毁线程池,该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁</div><div class="line">    public void destroy() &#123;</div><div class="line">        while (!taskQueue.isEmpty()) &#123;// 如果还有任务没执行完成，就先睡会吧</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(10);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 工作线程停止工作，且置为null</div><div class="line">        for (int i = 0; i &lt; worker_num; i++) &#123;</div><div class="line">            workThrads[i].stopWorker();</div><div class="line">            workThrads[i] = null;</div><div class="line">        &#125;</div><div class="line">        threadPool=null;</div><div class="line">        taskQueue.clear();// 清空任务队列</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回工作线程的个数</div><div class="line">    public int getWorkThreadNumber() &#123;</div><div class="line">        return worker_num;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回已完成任务的个数,这里的已完成是只出了任务队列的任务个数，可能该任务并没有实际执行完成</div><div class="line">    public int getFinishedTasknumber() &#123;</div><div class="line">        return finished_task;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回任务队列的长度，即还没处理的任务个数</div><div class="line">    public int getWaitTasknumber() &#123;</div><div class="line">        return taskQueue.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 覆盖toString方法，返回线程池信息：工作线程个数和已完成任务个数</div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;WorkThread number:&quot; + worker_num + &quot;  finished task number:&quot;</div><div class="line">                + finished_task + &quot;  wait task number:&quot; + getWaitTasknumber();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 内部类，工作线程</div><div class="line">     */</div><div class="line">    private class WorkThread extends Thread &#123;</div><div class="line">        // 该工作线程是否有效，用于结束该工作线程</div><div class="line">        private boolean isRunning = true;</div><div class="line"></div><div class="line">        /*</div><div class="line">         * 关键所在啊，如果任务队列不空，则取出任务执行，若任务队列空，则等待</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            Runnable r = null;</div><div class="line">            while (isRunning) &#123;// 注意，若线程无效则自然结束run方法，该线程就没用了</div><div class="line">                synchronized (taskQueue) &#123;</div><div class="line">                    while (isRunning &amp;&amp; taskQueue.isEmpty()) &#123;// 队列为空</div><div class="line">                        try &#123;</div><div class="line">                            taskQueue.wait(20);</div><div class="line">                        &#125; catch (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    if (!taskQueue.isEmpty())</div><div class="line">                        r = taskQueue.remove(0);// 取出任务</div><div class="line">                &#125;</div><div class="line">                if (r != null) &#123;</div><div class="line">                    r.run();// 执行任务</div><div class="line">                &#125;</div><div class="line">                finished_task++;</div><div class="line">                r = null;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 停止工作，让该线程自然执行完run方法，自然结束</div><div class="line">        public void stopWorker() &#123;</div><div class="line">            isRunning = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//测试线程池</div><div class="line">public class TestThreadPool &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 创建3个线程的线程池</div><div class="line">        ThreadPool t = ThreadPool.getThreadPool(3);</div><div class="line">        t.execute(new Runnable[] &#123; new Task(), new Task(), new Task() &#125;);</div><div class="line">        t.execute(new Runnable[] &#123; new Task(), new Task(), new Task() &#125;);</div><div class="line">        System.out.println(t);</div><div class="line">        t.destroy();// 所有线程都执行完成才destory</div><div class="line">        System.out.println(t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 任务类</div><div class="line">    static class Task implements Runnable &#123;</div><div class="line">        private static volatile int i = 1;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;// 执行任务</div><div class="line">            System.out.println(&quot;任务 &quot; + (i++) + &quot; 完成&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">运行结果：</div><div class="line">WorkThread number:3  finished task number:0  wait task number:6</div><div class="line">任务 1 完成</div><div class="line">任务 2 完成</div><div class="line">任务 3 完成</div><div class="line">任务 4 完成</div><div class="line">任务 5 完成</div><div class="line">任务 6 完成</div><div class="line">WorkThread number:3  finished task number:6  wait task number:0</div><div class="line"></div><div class="line">分析：由于并没有任务接口，传入的可以是自定义的任何任务，所以线程池并不能准确的判断该任务是否真正的已经完成（真正完成该任务是这个任务的run方法执行完毕），只能知道该任务已经出了任务队列，正在执行或者已经完成。</div></pre></td></tr></table></figure></p>
<p><img src="http://7xrkr6.com1.z0.glb.clouddn.com/java.current.gif" alt="java.util.concurrent"><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/0_1319784243mu5f.gif" alt="java.util.concurrent"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字符串算法]]></title>
      <url>http://yoursite.com/2016/03/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h3><h4 id="字符串变形词"><a href="#字符串变形词" class="headerlink" title="字符串变形词"></a>字符串变形词</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 判断两个字符串是否互为变形词</div><div class="line"> * 如果str1和str2中出现的字符种类一样且每种字符出现的次数也一样,则互为变形词</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class SqureString &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(isDeformation(&quot;aannvv123a&quot;,&quot;aannvv123&quot;));</div><div class="line">	&#125;</div><div class="line">	public static boolean isDeformation(String str1,String str2)&#123;</div><div class="line">		char[] chas1 = str1.toCharArray();</div><div class="line">		char[] chas2 = str2.toCharArray();</div><div class="line">		// map[a]=b 代表字符编码为a的字符出现了b次</div><div class="line">		int[] map = new int[256];</div><div class="line">		for(int i=0;i&lt;chas1.length;i++)&#123;</div><div class="line">			map[chas1[i]]++;</div><div class="line">		&#125;</div><div class="line">		// 扫描str2的字符数组，若曾出现在str1的字符数组中则减1</div><div class="line">		for(int i=0;i&lt;chas2.length;i++)&#123;</div><div class="line">			map[chas1[i]]--;</div><div class="line">		&#125;</div><div class="line">		// 扫描结果数组，若出现不为0的位置则判断两个字符串不同</div><div class="line">		for(int i = 0;i&lt;map.length;i++)&#123;</div><div class="line">			if(map[i]!=0)</div><div class="line">				return false;</div><div class="line">		&#125;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="判断各字符是否只出现一次"><a href="#判断各字符是否只出现一次" class="headerlink" title="判断各字符是否只出现一次"></a>判断各字符是否只出现一次</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 判断各字符是否只出现一次</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class UniqueChar &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		System.out.println(isUnique(&quot;abcdaef&quot;));</div><div class="line">	&#125;</div><div class="line">	public static boolean isUnique(String str)&#123;</div><div class="line">		char[] chars = str.toCharArray();</div><div class="line">		if(chars == null)</div><div class="line">			return true;</div><div class="line">		boolean[] map = new boolean[256];</div><div class="line">		for(int i=0;i&lt;chars.length;i++)&#123;</div><div class="line">			if(map[chars[i]])</div><div class="line">				return false;</div><div class="line">			map[chars[i]]=true;</div><div class="line">		&#125;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="移除K个连续0字符"><a href="#移除K个连续0字符" class="headerlink" title="移除K个连续0字符"></a>移除K个连续0字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 移除K个连续0字符</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class RemoveKZero &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String result = removeKZero(&quot;A00B000C00D00&quot;, 2);</div><div class="line">		System.out.println(result);</div><div class="line">	&#125;</div><div class="line">	public static String removeKZero(String str,int k)&#123;</div><div class="line">		char[] chas = str.toCharArray();</div><div class="line">		int count=0,start=-1;</div><div class="line">		for(int i=0;i!=chas.length;i++)&#123;</div><div class="line">			if(chas[i]==&apos;0&apos;)&#123;</div><div class="line">				count++;</div><div class="line">				// 如果start为-1 则更新值，指向当前为0的位置；如果不为-1 则维持，由count记录0的个数</div><div class="line">				start = start==-1?i:start;</div><div class="line">			&#125;else&#123;</div><div class="line">				if(count==k)&#123;</div><div class="line">					while(count--!=0)</div><div class="line">						chas[start++]=0;</div><div class="line">				&#125;</div><div class="line">				count=0;</div><div class="line">				start=-1;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		// 检查一下count是否为K，如果为K,则去掉最后一组连续值</div><div class="line">		if(count==k)&#123;</div><div class="line">			while(count--!=0)</div><div class="line">				chas[start++]=0;</div><div class="line">		&#125;</div><div class="line">		return String.valueOf(chas);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 给定一个字符串和一个整数，把前k个字符整体移到右半区，右半区整体移到左半区</div><div class="line"> * eg: &quot;ABCDE&quot; ,size=3 调整为 &quot;DEABC&quot;</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class ReverseString &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		char[] ss =&quot;abacde&quot;.toCharArray();</div><div class="line">		rotate(ss, 3);</div><div class="line">		System.out.println(String.valueOf(ss));</div><div class="line">	&#125;</div><div class="line">	public static void rotate(char[] chas,int size)&#123;</div><div class="line">		if(chas == null || size &lt;=0 || size &gt;=chas.length)</div><div class="line">			return;</div><div class="line">		reverse(chas,0,size-1);</div><div class="line">		reverse(chas,size,chas.length-1);</div><div class="line">		reverse(chas,0,chas.length-1);</div><div class="line">	&#125;</div><div class="line">	public static void reverse(char[] chas,int start,int end)&#123;</div><div class="line">		char tmp=0;</div><div class="line">		while(start &lt; end)&#123;</div><div class="line">			tmp = chas[start];</div><div class="line">			chas[start] = chas[end];</div><div class="line">			chas[end] = tmp;</div><div class="line">			start ++;</div><div class="line">			end --;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="反转单词"><a href="#反转单词" class="headerlink" title="反转单词"></a>反转单词</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class RotateWord &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// char[] chas = &quot;dog loves pig&quot;.toCharArray();</div><div class="line">		char[] chas = &quot;one two three&quot;.toCharArray();</div><div class="line">		rotateWord(chas);</div><div class="line">		System.out.println(String.valueOf(chas));</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public static void rotateWord(char[] chas)&#123;</div><div class="line">	    // 先整体逆置，然后各个单词逆置</div><div class="line">		reverse(chas, 0, chas.length-1);</div><div class="line">		int start=-1,count=0;</div><div class="line">		for(int i=0;i&lt;chas.length;i++)&#123;</div><div class="line">		// start指向要移除的字符的开头，count记录反转的字符个数</div><div class="line">			if(chas[i]!=&apos; &apos;)&#123;</div><div class="line">				start=start==-1?i:start;</div><div class="line">				count++;</div><div class="line">			&#125;else&#123;</div><div class="line">				reverse(chas, start, start+count-1);</div><div class="line">				count=0;</div><div class="line">				start=-1;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		reverse(chas, start, start+count-1);</div><div class="line">	&#125;</div><div class="line">	// 反转字符串</div><div class="line">	public static void reverse(char[] chas,int start,int end)&#123;</div><div class="line">		char tmp=0;</div><div class="line">		while(start &lt; end)&#123;</div><div class="line">			tmp = chas[start];</div><div class="line">			chas[start] = chas[end];</div><div class="line">			chas[end] = tmp;</div><div class="line">			start ++;</div><div class="line">			end --;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[矩阵的加速乘法(斐波那契、台阶、农场母牛问题)]]></title>
      <url>http://yoursite.com/2016/03/07/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8A%A0%E9%80%9F%E4%B9%98%E6%B3%95-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E3%80%81%E5%8F%B0%E9%98%B6%E3%80%81%E5%86%9C%E5%9C%BA%E6%AF%8D%E7%89%9B%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="矩阵相乘的加速算法"><a href="#矩阵相乘的加速算法" class="headerlink" title="矩阵相乘的加速算法"></a>矩阵相乘的加速算法</h3><h4 id="实现复杂度为O-logN-的算法"><a href="#实现复杂度为O-logN-的算法" class="headerlink" title="实现复杂度为O(logN)的算法"></a>实现复杂度为O(logN)的算法</h4><blockquote>
<ul>
<li>给定整数N，返回斐波那契数列的第N项</li>
<li>一次可以跨2个或1个台阶，返回有多少种走法</li>
<li>农场成熟的母牛每年只会生一头小母牛，假设不死。第一年农场有一只成熟的母牛，从第二年开始，母牛生小母牛，每只小母牛3年之后成熟生小母牛，求N年之后牛的数量</li>
</ul>
</blockquote>
<h4 id="矩阵相乘算法"><a href="#矩阵相乘算法" class="headerlink" title="矩阵相乘算法"></a>矩阵相乘算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * F(n)=F(n-1)+F(n-2) 是一个二阶递推数列，一定可以用矩阵乘法的形式表示，且状态矩阵是2*2的矩阵</div><div class="line"> * 求出状态矩阵 [1,1][1,0] 而求矩阵N次方的问题是一个能够在O(logN)时间内解决的问题</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class MatrixAlgorithm &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int[][] res = &#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;;</div><div class="line">		int p=3;</div><div class="line">		int[][] result = matrix(res,p);</div><div class="line">		for (int i = 0; i &lt; result.length; i++) &#123;</div><div class="line">			for (int j = 0; j &lt; result[0].length; j++) &#123;</div><div class="line">				System.out.print(result[i][j]+&quot; &quot;);</div><div class="line">			&#125;</div><div class="line">			System.out.println();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static int[][] matrix(int[][] res, int p) &#123;</div><div class="line">		int[][] result = new int[res.length][res[0].length];</div><div class="line">		for(int i=0;i&lt;res.length;i++)&#123;</div><div class="line">			result[i][i] = 1;</div><div class="line">		&#125;</div><div class="line">		int[][] tmp = res;</div><div class="line">		for(;p!=0;p&gt;&gt;=1)&#123;</div><div class="line">			if ((p &amp; 1) !=0) &#123;</div><div class="line">				res = getMatrix(res, tmp);</div><div class="line">			&#125;</div><div class="line">			tmp = getMatrix(tmp, tmp);</div><div class="line">		&#125;</div><div class="line">		return res;</div><div class="line">	&#125;</div><div class="line">	public static int[][] getMatrix(int[][] m1, int[][] m2) &#123;</div><div class="line">		int[][] result = new int[m1.length][m2[0].length];</div><div class="line">		for (int i = 0; i &lt; result.length; i++) &#123;</div><div class="line">			for(int j = 0;j &lt; result[0].length;j++)</div><div class="line">				result[i][j] = 0;</div><div class="line">		&#125;</div><div class="line">		for(int i = 0;i&lt;m1.length;i++)&#123;</div><div class="line">			for(int j = 0;j&lt;m2[0].length;j++)&#123;</div><div class="line">				for(int k=0;k&lt;m2.length;k++)&#123;</div><div class="line">					result[i][j] += m1[i][k] * m2[k][j];</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="斐波那契数列的O-logN）实现"><a href="#斐波那契数列的O-logN）实现" class="headerlink" title="斐波那契数列的O(logN）实现"></a>斐波那契数列的O(logN）实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class PeiBoNaQi &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(f3(5));</div><div class="line">	&#125;</div><div class="line">	public static int f3(int n)&#123;</div><div class="line">		if(n &lt; 1)</div><div class="line">			return 0;</div><div class="line">		if(n == 1 || n == 2)</div><div class="line">			return 1;</div><div class="line">		int[][] base = &#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;;</div><div class="line">		int[][] res = MatrixAlgorithm.matrix(base, n-3);</div><div class="line">		return res[0][0]+res[0][1];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="台阶问题的O-logN）实现"><a href="#台阶问题的O-logN）实现" class="headerlink" title="台阶问题的O(logN）实现"></a>台阶问题的O(logN）实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 根据上文所得，(s(n),s(n-1)) = ((s(2),s(1))*&#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;[n-2]</div><div class="line"> * 即    (2,1)*&#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;[n-2]</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class TaiJie &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(f3(5));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static int f3(int n) &#123;</div><div class="line">		if(n &lt; 1)</div><div class="line">			return 0;</div><div class="line">		if(n == 1 || n==2)</div><div class="line">			return n;</div><div class="line">		int[][] base = &#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;;</div><div class="line">		int[][] res = MatrixAlgorithm.matrix(base, n-3);</div><div class="line">		return 2*res[0][0]+res[0][1];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="母牛问题的O-logN）实现"><a href="#母牛问题的O-logN）实现" class="headerlink" title="母牛问题的O(logN）实现"></a>母牛问题的O(logN）实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 基数为(3,2,1)</div><div class="line">*/</div><div class="line">    public int c3(int n)&#123;</div><div class="line">		if(n&lt;1)</div><div class="line">			return 0;</div><div class="line">		if(n ==1 || n==2 || n==3)</div><div class="line">			return n;</div><div class="line">		int[][] base = &#123;&#123;1,1,0&#125;,&#123;0,0,1&#125;,&#123;1,0,0&#125;;</div><div class="line">		int[][] res = MatrixAlgorithm.matrix(base, n-4);</div><div class="line">		return 3*res[0][0] +2*res[1][0]+res[0][0];</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[死锁简单例子]]></title>
      <url>http://yoursite.com/2016/03/05/%E6%AD%BB%E9%94%81%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 写出一个死锁例子</div><div class="line"> * @author flyyc</div><div class="line"> */</div><div class="line">public class DealTHread implements Runnable &#123;</div><div class="line">	public String userName;</div><div class="line">	public byte[] lock1 = new byte[1];</div><div class="line">	public byte[] lock2 = new byte[1];</div><div class="line">	public void setFlag(String userName)&#123;</div><div class="line">		this.userName = userName;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		if(userName.equals(&quot;a&quot;))&#123;</div><div class="line">			synchronized (lock1) &#123;</div><div class="line">				try &#123;</div><div class="line">					System.out.println(&quot;userName = &quot; + userName);</div><div class="line">					Thread.sleep(3000);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				synchronized (lock2) &#123;</div><div class="line">					System.out.println(&quot;lock1-&gt;lock2&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if(userName.equals(&quot;b&quot;))&#123;</div><div class="line">			synchronized (lock2) &#123;</div><div class="line">				try &#123;</div><div class="line">					System.out.println(&quot;userName = &quot; + userName);</div><div class="line">					Thread.sleep(3000);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				synchronized (lock1) &#123;</div><div class="line">					System.out.println(&quot;lock2-&gt;lock1&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">			try &#123;</div><div class="line">				DealTHread t1 = new DealTHread();</div><div class="line">				t1.setFlag(&quot;a&quot;);</div><div class="line">				Thread thread1 = new Thread(t1);</div><div class="line">				thread1.start();</div><div class="line">				Thread.sleep(1000);</div><div class="line">				t1.setFlag(&quot;b&quot;);</div><div class="line">				Thread thread2 = new Thread(t1);</div><div class="line">				thread2.start();</div><div class="line">			&#125; catch (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Map接口及子类总结]]></title>
      <url>http://yoursite.com/2016/03/05/Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%AD%90%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>转自 <a href="http://blog..hsuxu/article/details/7454172" target="_blank" rel="external">Hsuxu的专栏</a></p>
<h3 id="子接口"><a href="#子接口" class="headerlink" title="子接口"></a>子接口</h3><p>Bindings、ConcurrentMap、ConcurrentNavigableMap、MessageContext、LogicMessageContext、NavigableMap、SOAPMessageMap、SortedMap</p>
<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><p>AbstractMap, Attributes,AuthProvider, ConcurrentHashMap, EnumMap,ConcurrentSkipListMap,HashMap, Hashtable, IdentityHashMap,<br>LinkedHashMap, PrinterStateReasons,Properties,Provider, RenderingHints, SimpleBindings, TabularDataSupport,TreeMap,UIDefaults,<br>WeakHashMap</p>
<h3 id="方法定义说明"><a href="#方法定义说明" class="headerlink" title="方法定义说明"></a>方法定义说明</h3><p>put(K, V) ： 将给定的“键-值”对放入到给定的Map当中<br>putAll(Map&lt;? extends K, ? extends V) : 将指定的Map中的“键-值”对放入到给定的Map当中<br>remove(Object key) : 从该集合中移除指定的对象，并返回对应的value<br>clear() : 清空Map中的所有对象<br>int size() : 返回此Map中“键-值”对的个数<br>boolean isEmpty() : 判断此Map中“键-值”对的个数是否为0<br>boolean containsKey(Object key) : 测试此Map中是否有该key<br>boolean containsValue(Object value) : 测试此Map中是否包含该value<br>V get(Object key) : 通过指定的key查询Map中对应的value<br>Collection<object value=""> values() : 取得Map中所有的value<br>Set<object key=""> keySet() : 取得当前Map中key的集合<br>Set<entry<k, v="">&gt; entrySet() : 取得当前Map中entry的集合</entry<k,></object></object></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap 实现了Map、CloneMap、Serializable三个接口，并且继承自AbstractMap类。<br>HashMap 基于hash数组实现，若key的hash值相同则使用链表方式进行保存。Entry是一个结点，它持有下一个元素的引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static int indexFor(int h,int length)&#123;</div><div class="line">	return h &amp; (length-1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法是根据hashCode及当前table的长度得到该元素应该存放的位置，或者在table中的索引。<br>在HashMap中当数据量很多时，并且已经达到了负载限度时，会重新做一次哈希，也就是说会再散列。调用的方法为resize()<br>resize（再哈希）的工作量是不是很大啊。再哈希是重新建一个指定容量的数组，然后将每个元素重新计算它要放的位置<br>Q： 如何提高Hash表的性能 ？<br>比较重要的是HashMap的遍历方法,KeySet,EntrySet。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1.HashMap采用数组方式存储key，value构成的Entry对象，无容量限制。<br>2.HashMap基于key hash寻找Entry对象存放到数组的位置，对于Hash冲突采用链表的方式来解决。<br>3.HashMap在插入元素时可能要扩大数组的容量，扩大容量时对所有的数据要重新计算哈希和存放到新数组中。当元素个数size大于threshold扩容<br>threshold = (int)(newCapacity* loadFactor);<br>4.HashMap保证数组的大小为2的指数大小。<br>5.HashMap非线程安全。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap继承自HashMap并且实现了Map接口。和HashMap一样，LinkedHashMap允许key和value均为null。<br>如果你想在多线程中使用，那么需要使用Collections.synchronizedMap方法进行外部同步。<br>LinkedHashMap与HashMap的不同之处在于，LinkedHashMap维护着运行于所有条目的双向链接列表，此链接列表可以是插入顺序或者访问顺序。<br>重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上<br>又构成了双向链接列表<br>LinkedHashMap重写了init()方法，在调用父类的构造方法完成构造后，进一步实现了对其元素Entry的初始化操作（双向链表）<br>LinkedHashMap适合做LRU缓存。</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>如果要控制TreeMap中元素的存储顺序，应使用带Comparator参数的构造器。<br>put(K,V)<br>先判断root是否为null，如果为null，则创建一个新的Entry对象，并赋值给root属性。否则，首先判断是否传入了Compatator实现，如果是，则基于<br>红黑树的方式遍历，直到为树节点null，使用传入的comparator比较Key的大小，如果找到相等的key则更新其值，若没有找到相同的key，则创建一个<br>新的Entry对象，并将其parent设置为上面所寻找到的元素，并根据和parent key比较的情况设置parent的left和right属性。最后对红黑树进行调整。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap 是线程安全的HashMap实现。支持获取，查找时完全并发和更新时可调整并发的哈希表。获取操作（包括 get）通常不会受阻塞。<br>并发场景中(多个线程的情况下) ConcurrentHashMap 比HashMap优秀很多。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一张图看懂Java多线程]]></title>
      <url>http://yoursite.com/2016/03/05/%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%87%82Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="一张图看懂Java多线程"><a href="#一张图看懂Java多线程" class="headerlink" title="一张图看懂Java多线程"></a>一张图看懂Java多线程</h1><hr>
<p>转自 <a href="http://blog..hsuxu/article/details/7454172" target="_blank" rel="external">Hsuxu的专栏</a><br><img src="http://7xrkr6.com1.z0.glb.clouddn.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="java多线程"></p>
<blockquote>
<ul>
<li><p>Thread t = new Thread()，初始化一个线程，实际上就是一个普通对象，此时他的状态为New</p>
</li>
<li><p>t.start(); 线程处于就绪状态（可运行状态），也就是随时等待着运行， 不要小看这个start，这个start决定了他是否是一个真正的线程实例，因为start为其准备了线程环境，你若只是普通调用run方法，那么这就是 一个普通的方法。处在这个时候的线程，都会去竞争CPU资源，所以谁被竞争到了CPU资源，也就是被调度Scheduler，那么他就可以从可运行状态到 真正运行状态。</p>
</li>
<li><p>当线程获取到了CPU资源时，线程就从可运行状态到真正运行状态，也就是Running，不用怀疑，他现在正在运行。</p>
</li>
<li><p>如果这个线程正在等待客户输入学习，也就是IO异常，等各种阻塞事件，也有可能是自己调用了sleep或者join方法等阻塞事件，线程就会从运行状态转为阻塞状态，这个状态是不会发生任何事情的！</p>
</li>
<li><p>一旦阻塞事件被清除，比如用户已经输入完成，IO流已经关闭，sleep也已经超时，join()结束等，线程从阻塞状态变为就绪状态，又一次回到了可运行状态，随时与别的线程竞争资源，等待运行！</p>
</li>
<li><p>处于运行状态的线程可能会在运行当中遇到了同步方法或同步块，也就是synchronized标记的方法或块，这个时候该线程获到了对象的锁， 其他线程就无法进入该同步方法，那么这些无法执行的线程怎么办呢？他们就都阻塞在这里，等待锁的释放，从新去竞争锁资源，因为只有拥有锁的线程才有资格继 续往下运行，那么这里这些线程就阻塞在锁池（Lock Pool）。</p>
</li>
<li><p>一旦被阻塞在锁池的线程竞争到了锁（之前的线程运行完了或之前的线程在内部跑出来异常，或者调用了wait等，都会释放线程的锁），那么这个线 程就会从阻塞状态转为就绪状态，不要以为这个线程会立刻执行，这是不可能的，你要想到线程执行都是要获取到CPU资源的，如果没有操作系统的调度，他们都 没有资格运行！</p>
</li>
<li><p>处于运行状态的线程可能会在运行当中进入了同步方法或同步块，这个时候他拥有了对象的锁，至高无上，可是由于当前环境可能导致他没必要继续执 行，所以他会自己让出锁资源让别的线程也有机会继续执行，所以这个线程可能在synchronized内部调用所对象的wait方法，一旦调用，当前线程 让出锁资源，同时自己进入等待池（wait pool）中，直到被别的线程唤醒！如果没有被唤醒就一直会处在等待池当中，受到线程的阻塞，所以这个时候他们一心想要的是被唤醒，因为只有唤醒才有可能 继续运行！</p>
</li>
<li><p>一旦被阻塞在等待池的线程被唤醒（可能是某个synchronized的线程调用了notify或notifyAll，也可能是外部调用 interrupt导致内部抛出异常，也会获取到锁），那么这个线程就会从等待池转为锁池当中，继续阻塞，所以不要以为线程被唤醒就会继续运行，这是不可 能的，他们同样需要竞争锁资源。</p>
</li>
<li><p>线程运行过程中抛出异常，或者线程实在运行完了，那么线程就结束了，也就是消亡期。运行完了是不可以继续start的，必须从新new 一个线程才能start。那么将是有一个生命周期。</p>
</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Cmd Markdown参考]]></title>
      <url>http://yoursite.com/2016/03/05/Cmd-Markdown%E5%8F%82%E8%80%83/</url>
      <content type="html"><![CDATA[<h1 id="欢迎使用-Cmd-Markdown-编辑阅读器"><a href="#欢迎使用-Cmd-Markdown-编辑阅读器" class="headerlink" title="欢迎使用 Cmd Markdown 编辑阅读器"></a>欢迎使用 Cmd Markdown 编辑阅读器</h1><hr>
<p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p>
<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p>
<p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p>
<h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="external">Windows/Mac/Linux 全平台客户端</a></h3><blockquote>
<p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p>
</blockquote>
<hr>
<h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>
<h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="external">Todo 列表</a></h3><ul>
<li>[ ] 支持以 PDF 格式导出文稿</li>
<li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li>[x] 新增 Todo 列表功能</li>
<li>[x] 修复 LaTex 公式渲染问题</li>
<li>[x] 新增 LaTex 公式编号功能</li>
</ul>
<h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p>
<h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@requires_authorization</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># A comment</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>
<h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="external">流程图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: Start</div><div class="line">op=&gt;operation: Your Operation</div><div class="line">cond=&gt;condition: Yes or No?</div><div class="line">e=&gt;end</div><div class="line"></div><div class="line">st-&gt;op-&gt;cond</div><div class="line">cond(yes)-&gt;e</div><div class="line">cond(no)-&gt;op</div></pre></td></tr></table></figure>
<h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="external">序列图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Alice-&gt;Bob: Hello Bob, how are you?</div><div class="line">Note right of Bob: Bob thinks</div><div class="line">Bob--&gt;Alice: I am good thanks!</div></pre></td></tr></table></figure>
<h3 id="6-绘制表格"><a href="#6-绘制表格" class="headerlink" title="6. 绘制表格"></a>6. 绘制表格</h3><table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算机</td>
<td style="text-align:right">\$1600</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">\$12</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>管线</td>
<td style="text-align:right">\$1</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="7-更详细语法说明"><a href="#7-更详细语法说明" class="headerlink" title="7. 更详细语法说明"></a>7. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="external">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="external">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p>
<p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>
<hr>
<h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p>
<h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p>
<h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p>
<p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p>
<h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右测的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p>
<h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p>
<h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p>
<h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p>
<p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p>
<p>通过管理工具栏可以：</p>
<p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p>
<h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p>
<p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p>
<p>工具栏上的五个图标依次为：</p>
<p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>
<h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p>
<h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p>
<p>标签： 未分类</p>
<p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p>
<p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p>
<h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p>
<hr>
<p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p>
<p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="external">@ghosert</a><br>2015 年 06月 15日</p>
<p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">MathJax</a> 参考更多使用方法。</p>
<p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最长公共子序列]]></title>
      <url>http://yoursite.com/2016/03/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 最长公共子序列问题</div><div class="line"> * 给定两个字符串str1和str2,返回两个字符串的最长公共子序列</div><div class="line"> * dp[i][j] 的值可能来自于三种情况</div><div class="line"> * 1.dp[i-1][j]</div><div class="line"> * 2.dp[i][j-1]</div><div class="line"> * 3.dp[i-1][j-1]+1</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class LongestCommonSequence &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		String str1=&quot;A23Ddfd4B56&quot;;</div><div class="line">		String str2=&quot;B1D2eCA45B6A&quot;;</div><div class="line">		System.out.println(lcse(str1,str2));</div><div class="line">	&#125;</div><div class="line">	public static int[][] getdp(char[] str1,char[] str2)&#123;</div><div class="line">		int[][] dp = new int[str1.length][str2.length];</div><div class="line">		dp[0][0] = str1[0]==str2[0]?1:0;</div><div class="line">		//dp第一列中，如果str1[i]==str2[0],令dp[i][0]=1,一旦dp[i][0]被设置为1，之后的dp[i+1...M-1][0]也都为1</div><div class="line">		for(int i=1;i&lt;str1.length;i++)&#123;</div><div class="line">			dp[i][0] = Math.max(dp[i-1][0], str1[i]==str2[0]?1:0);</div><div class="line">		&#125;</div><div class="line">		//dp第一行中，如果str1[0]==str2[j],令dp[0][j]=1,一旦dp[0][j]被设置为1，之后的dp[0][j+1...M-1]也都为1</div><div class="line">		for(int j=1;j&lt;str2.length;j++)&#123;</div><div class="line">			dp[0][j]=Math.max(dp[0][j-1], str1[0] == str2[j]?1:0);</div><div class="line">		&#125;</div><div class="line">		//dp[i][j]是 dp[i-1][j]、dp[i][j-1]、dp[i-1][j-1]+1中最大的值</div><div class="line">		for(int i=1;i&lt;str1.length;i++)&#123;</div><div class="line">			for(int j=1;j&lt;str2.length;j++)&#123;</div><div class="line">				dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);</div><div class="line">				if(str1[i] == str2[j])&#123;</div><div class="line">					dp[i][j] = Math.max(dp[i][j], dp[i-1][j-1]+1);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static String lcse(String str1,String str2)&#123;</div><div class="line">		char[] chs1 = str1.toCharArray();</div><div class="line">		char[] chs2 = str2.toCharArray();</div><div class="line">		int[][] dp = getdp(chs1, chs2);</div><div class="line">		int m = chs1.length-1;</div><div class="line">		int n = chs2.length-1;</div><div class="line">		char[] res = new char[dp[m][n]];</div><div class="line">		int index = res.length-1;</div><div class="line">		while(index &gt;=0)&#123;</div><div class="line">			//从右下角开始向左、向上、向左上方移动</div><div class="line">			if(n&gt;0 &amp;&amp; dp[m][n] == dp[m][n-1])</div><div class="line">				//说明之前在计算dp[i][j]的时候，dp[i-1][j-1]+1这个不是必须选择的，向上方移动</div><div class="line">				n--;</div><div class="line">			else if(m&gt;0 &amp;&amp; dp[m][n] == dp[m-1][n])</div><div class="line">				//说明之前在计算dp[i][j]的时候，dp[i-1][j-1]+1这个不是必须选择的，向左方移动</div><div class="line">				m--;</div><div class="line">			else&#123;</div><div class="line">				//说明之前在计算dp[i][j]的时候，dp[i-1][j-1]是必须选择的，向左上方移动</div><div class="line">				res[index--] = chs1[m];</div><div class="line">				m--;</div><div class="line">				n--;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return String.valueOf(res);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[动态规划(最长公共子串)]]></title>
      <url>http://yoursite.com/2016/03/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 最长公共子串</div><div class="line"> * dp[i][j] 的值只可能有两种情况</div><div class="line"> * 1.如果str1[i]!=str2[j],说明在必须把str1[i]和str2[j]当做公共子串最后一个字符是不可能的，令dp[i][j]=0</div><div class="line"> * 2.如果str1[i]==str2[j] 说明str1[i]和str2[j]可以作为公共子串的最后一个字符，所以令 dp[i][j] = dp[i-1][j-1]+1</div><div class="line"> */</div><div class="line">public class CommonString &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		String str1=&quot;ABCE12F&quot;;</div><div class="line">		String str2=&quot;EAEEF&quot;;</div><div class="line">		char[] chs1 = str1.toCharArray();</div><div class="line">		char[] chs2 = str2.toCharArray();</div><div class="line">		int[][] dp = getDp(chs1,chs2);</div><div class="line">		int max=0;</div><div class="line">		for(int i = 0;i&lt;dp.length;i++)&#123;</div><div class="line">			for(int j = 0;j&lt;dp[i].length;j++)&#123;</div><div class="line">				if(max&lt;dp[i][j])</div><div class="line">					max = dp[i][j];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(max);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static int[][] getDp(char[] chs1, char[] chs2) &#123;</div><div class="line">		int[][] dp = new int[chs1.length][chs2.length];</div><div class="line">		for(int i=0;i&lt;chs1.length;i++)&#123;</div><div class="line">			if(chs1[i]==chs2[0])</div><div class="line">				dp[i][0]=1;</div><div class="line">		&#125;</div><div class="line">		for(int j=0;j&lt;chs2.length;j++)&#123;</div><div class="line">			if(chs1[0] == chs2[j])</div><div class="line">				dp[0][j]=1;</div><div class="line">		&#125;</div><div class="line">		for(int i=1;i&lt;chs1.length;i++)&#123;</div><div class="line">			for(int j=1;j&lt;chs2.length;j++)&#123;</div><div class="line">				if(chs1[i] == chs2[j])</div><div class="line">					dp[i][j] = dp[i-1][j-1]+1;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础算法]]></title>
      <url>http://yoursite.com/2016/03/04/%E7%AE%97%E6%B3%95%E4%B8%80/</url>
      <content type="html"><![CDATA[<h3 id="裴波那契"><a href="#裴波那契" class="headerlink" title="裴波那契"></a>裴波那契</h3><p>36596<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 裴波那契</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class PeiBoNaQi &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		System.out.println(func(9));</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	private static int func(int i) &#123;</div><div class="line">		if(i==1 || i==2)</div><div class="line">			return 1;</div><div class="line">		else</div><div class="line">			return func(i-1)+func(i-2);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 裴波那契的非递归方法</div><div class="line">	private static int fibo(int n) &#123;</div><div class="line">		int[] dp = &#123;1,1,0&#125;;</div><div class="line">		for(int i=2;i&lt;n;i++)&#123;</div><div class="line">			dp[2] = dp[0]+dp[1];</div><div class="line">			dp[0] = dp[1];</div><div class="line">			dp[1] = dp[2];</div><div class="line">		&#125;</div><div class="line">		return dp[2];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="求解素数"><a href="#求解素数" class="headerlink" title="求解素数"></a>求解素数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Prime &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		int count = 0;</div><div class="line">		for (int i = 101; i &lt; 200; i++) &#123;</div><div class="line">			if (isPrime(i)) &#123;</div><div class="line">				count++;</div><div class="line">				System.out.println(i);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(count);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	private static boolean isPrime(int i) &#123;</div><div class="line">		for (int j = 2; j &lt;= Math.sqrt(i); j++) &#123;</div><div class="line">			if (i % j == 0)</div><div class="line">				return false;</div><div class="line">		&#125;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="哥德巴赫猜想"><a href="#哥德巴赫猜想" class="headerlink" title="哥德巴赫猜想"></a>哥德巴赫猜想</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 哥德巴赫猜想</div><div class="line"> * 一个偶数总能表示为两个素数之和</div><div class="line"> */</div><div class="line">public class GeDeBaHeCaiXiang &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Scanner sc = new Scanner(System.in);</div><div class="line">		int n,i;</div><div class="line">		do &#123;</div><div class="line">			System.out.println(&quot;please input:\n&quot;);</div><div class="line">			n = sc.nextInt();</div><div class="line">		&#125; while (n&lt;2 || n%2!=0);</div><div class="line">		for(i=0;i&lt;n/2;i++)&#123;</div><div class="line">			int j = n-i;</div><div class="line">			if(isPrime(i) &amp;&amp; isPrime(j) &amp;&amp; i &lt;= j)&#123;</div><div class="line">				System.out.println(&quot;number is &quot;+i+&quot; and &quot;+j);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static boolean isPrime(int j) &#123;</div><div class="line">		boolean flag = true;</div><div class="line">		for(int i=2;i&lt;=Math.sqrt(j);i++)&#123;</div><div class="line">			if(j%i==0)&#123;</div><div class="line">				flag = false;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return flag;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class YangHuiSanJiao &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		int[][] arr = new int[15][15];</div><div class="line">		for(int i = 0;i&lt;15;i++)</div><div class="line">			for(int j = 0;j&lt;15;j++)&#123;</div><div class="line">				if(j==0||i-1==j)</div><div class="line">					arr[i][j]=1;</div><div class="line">			&#125;</div><div class="line">		for(int i = 2;i&lt;15;i++)</div><div class="line">			for(int j = 1;j&lt;i;j++)&#123;</div><div class="line">				arr[i][j]=arr[i-1][j-1]+arr[i-1][j];</div><div class="line">			&#125;</div><div class="line">		for(int i = 0;i&lt;15;i++)&#123;</div><div class="line">			for(int j = 0;j&lt;i;j++)&#123;</div><div class="line">				System.out.print(arr[i][j]+&quot; &quot;);</div><div class="line">			&#125;</div><div class="line">			System.out.println();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h3><p>/**</p>
<ul>
<li>最大公约数、最小公倍数</li>
<li>在循环中，只要除数不等于0，用较大数除以较小的数，将小的一个数作为下一轮循环的大数，取得的余数作为下一轮循环的较小的数，</li>
<li>如此循环直到较小的数的值为0，返回较大的数，此数即为最大公约数，最小公倍数为两数之积除以最大公约数<br>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class GCD &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Scanner sc = new Scanner(System.in);</div><div class="line">		int m = sc.nextInt();</div><div class="line">		int n = sc.nextInt();</div><div class="line">		int k = gcd(m, n);</div><div class="line">		System.out.println(&quot;公约数是 &quot;+k+&quot; 公倍数是 &quot;+m*n/k);</div><div class="line">	&#125;</div><div class="line">	private static int gcd(int m, int n) &#123;</div><div class="line">		int k = 0;</div><div class="line">		if(m &lt; n)&#123;</div><div class="line">			m = m ^ n;</div><div class="line">			n = n ^ m;</div><div class="line">			m = m ^ n;</div><div class="line">		&#125;</div><div class="line">		while(n!=0)&#123;</div><div class="line">			if(m==n)</div><div class="line">				return m;</div><div class="line">			else &#123;</div><div class="line">				k = m;</div><div class="line">				m = n;</div><div class="line">				n = k%n;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return m;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 分解质因数</div><div class="line"> * 	(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。</div><div class="line">	(2)如果n &lt;&gt; k，但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数你n,重复执行第一步。</div><div class="line">	(3)如果n不能被k整除，则用k+1作为k的值,重复执行第一步。</div><div class="line"> */</div><div class="line">public class FenJieZhiYinShu &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		Scanner sc = new Scanner(System.in);</div><div class="line">		int n = sc.nextInt();</div><div class="line">		int k = 2;</div><div class="line">		while (k &lt;= n) &#123;</div><div class="line">			if (k == n)&#123;</div><div class="line">				System.out.println(k);</div><div class="line">				break;</div><div class="line">			&#125;else if (n % k == 0) &#123;</div><div class="line">				System.out.print(k + &quot;*&quot;);</div><div class="line">				n /= k;</div><div class="line">			&#125;else</div><div class="line">				k++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1的个数"><a href="#1的个数" class="headerlink" title="1的个数"></a>1的个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">while(sc.hasNext())&#123;</div><div class="line">			int num = sc.nextInt();</div><div class="line">			while(num!=0)&#123;</div><div class="line">				num = num &amp; (num-1);</div><div class="line">				count++;</div><div class="line">			&#125;</div><div class="line">			System.out.println(count);</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h3 id="整数的N次方"><a href="#整数的N次方" class="headerlink" title="整数的N次方"></a>整数的N次方</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static double powerWithUnsignedExponent(double base, int exponent) &#123;</div><div class="line">		if(exponent==0)</div><div class="line">			return 1;</div><div class="line">		if(exponent==1)</div><div class="line">			return base;</div><div class="line">		double result = powerWithUnsignedExponent(base, exponent&gt;&gt;1);</div><div class="line">		result *= result;</div><div class="line">		if((exponent &amp; 0x1)==1)</div><div class="line">			result *= base;</div><div class="line">		return result;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="从1打印到N组成的数字"><a href="#从1打印到N组成的数字" class="headerlink" title="从1打印到N组成的数字"></a>从1打印到N组成的数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Print1ToMxt &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		 Print1ToMax(5);</div><div class="line">	&#125;</div><div class="line">	public static void Print1ToMax(int n)&#123;</div><div class="line">		if(n &lt;= 0)</div><div class="line">			return ;</div><div class="line">		int[] arr = new int[n];</div><div class="line">		for(int i=0;i&lt;10;i++)&#123;</div><div class="line">			arr[0]=i;</div><div class="line">			printRecursively(arr,n,0);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private static void printRecursively(int[] arr, int length, int index) &#123;</div><div class="line">		if(index == length-1)&#123;</div><div class="line">			print(arr);</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		for(int i=0;i&lt;10;i++)&#123;</div><div class="line">			arr[index+1]=i;</div><div class="line">			printRecursively(arr, length, index+1);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private static void print(int[] arr) &#123;</div><div class="line">		for(int i=0;i&lt;arr.length;i++)&#123;</div><div class="line">			System.out.print(arr[i]);</div><div class="line">		&#125;</div><div class="line">		System.out.println();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[约瑟夫两种解法(数组和链表)]]></title>
      <url>http://yoursite.com/2016/03/04/%E7%BA%A6%E7%91%9F%E5%A4%AB%E4%B8%A4%E7%A7%8D%E8%A7%A3%E6%B3%95-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，</div><div class="line"> * 问最后留下的是原来第几号的那位</div><div class="line"> */</div><div class="line">public class YueSeFu &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Scanner s = new Scanner(System.in);</div><div class="line">		System.out.println(&quot;please input :\n&quot;);</div><div class="line">		int n = s.nextInt();</div><div class="line">		boolean[] arr = new boolean[n];</div><div class="line">		for(int i=0; i&lt;arr.length; i++) &#123;</div><div class="line">			arr[i] = true;</div><div class="line">		&#125;</div><div class="line">		int leftCount = n;</div><div class="line">		int countNum = 0;</div><div class="line">		int index = 0;</div><div class="line">		while(leftCount &gt; 1) &#123;</div><div class="line">			if(arr[index] == true) &#123;</div><div class="line">				countNum ++;</div><div class="line">				if(countNum == 3) &#123;</div><div class="line">					countNum =0;</div><div class="line">					arr[index] = false;</div><div class="line">					leftCount --;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			index ++;</div><div class="line">			if(index == n) &#123;</div><div class="line">				index = 0;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		for(int i=0; i&lt;n; i++) &#123;</div><div class="line">			if(arr[i] == true) &#123;</div><div class="line">				System.out.println(&quot;原排在第&quot;+(i+1)+&quot;位的人留下了。&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class JoseRing &#123;</div><div class="line">	static class Node &#123;</div><div class="line">		public int data;</div><div class="line">		public Node next;</div><div class="line">		public Node(int data) &#123;</div><div class="line">			this.data = data;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Node first = new Node(1);</div><div class="line">		Scanner scanner = new Scanner(System.in);</div><div class="line">		int n = scanner.nextInt();</div><div class="line">		int m = scanner.nextInt();</div><div class="line">		//first.next = first;</div><div class="line">		Node p = first;</div><div class="line">		for (int i = 2; i &lt;= n; i++) &#123;</div><div class="line">			Node temp = new Node(i);</div><div class="line">			//temp.next = p;</div><div class="line">			p.next = temp;</div><div class="line">			p = p.next;</div><div class="line">		&#125;</div><div class="line">		p.next = first;</div><div class="line">		while(p != p.next)</div><div class="line">        &#123;</div><div class="line">            //下面for循环后，p是第m个结点的前一个结点</div><div class="line">            for(int i=1; i&lt;m; i++)</div><div class="line">                p = p.next;</div><div class="line">            //删除第m个结点</div><div class="line">            System.out.print(p.next.data+&quot; &quot;);</div><div class="line">            p.next = p.next.next;</div><div class="line">        &#125;</div><div class="line">        System.out.print(&quot;\n幸运者是:&quot;+p.data);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[单例模式]]></title>
      <url>http://yoursite.com/2016/03/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="如何正确地写出单例模式"><a href="#如何正确地写出单例模式" class="headerlink" title="如何正确地写出单例模式"></a>如何正确地写出单例模式</h1><p>转自 <a href="https://github.com/biezhi/java-bible" target="_blank" rel="external">reference</a><br>单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。</p>
<h3 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h3><p>当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">         instance = <span class="keyword">new</span> Singleton();</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p>
<h3 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h3><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">        instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。</p>
<h3 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h3><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 <code>instance == null</code>，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         <span class="comment">//Single Checked</span></div><div class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                 <span class="comment">//Double Checked</span></div><div class="line">                instance = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>
<ol>
<li>给 instance 分配内存</li>
<li>调用 Singleton 的构造函数来初始化成员变量</li>
<li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li>
</ol>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
<p>我们只需要将 instance 变量声明成 volatile 就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; <span class="comment">//声明成 volatile</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p>
<p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。</p>
<h3 id="饿汉式-static-final-field"><a href="#饿汉式-static-final-field" class="headerlink" title="饿汉式 static final field"></a>饿汉式 static final field</h3><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="comment">//类加载时就初始化</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p>
<h3 id="静态内部类-static-nested-class"><a href="#静态内部类-static-nested-class" class="headerlink" title="静态内部类 static nested class"></a>静态内部类 static nested class</h3><p>我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>
<h3 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举 Enum"></a>枚举 Enum</h3><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，文章开头给出的第一种方法不算正确的写法。</p>
<p>就我个人而言，一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）会倾向于使用静态内部类，如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p>
<h3 id="Read-More"><a href="#Read-More" class="headerlink" title="Read More"></a>Read More</h3><ul>
<li><a href="http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html" target="_blank" rel="external">Double Checked Locking on Singleton Class in Java</a></li>
<li><a href="http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html" target="_blank" rel="external">http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html</a></li>
<li><a href="http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html" target="_blank" rel="external">How to create thread safe Singleton in Java</a></li>
<li><a href="http://javarevisited.blogspot.com/2011/03/10-interview-questions-on-singleton.html" target="_blank" rel="external">10 Singleton Pattern Interview questions in Java</a></li>
</ul>
<p>由于作者这篇文章写的非常好，我也就没有重写 <a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/#from=biezhi.me" target="_blank" rel="external">原文出处</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程学习笔记]]></title>
      <url>http://yoursite.com/2016/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="查询CPU核数和线程数"><a href="#查询CPU核数和线程数" class="headerlink" title="查询CPU核数和线程数"></a>查询CPU核数和线程数</h3><p>grep ‘processor’ /proc/cpuinfo | sort -u | wc -l<br>grep ‘core id’ /proc/cpuinfo | sort -u | wc -l</p>
<h3 id="线程组和线程池的区别"><a href="#线程组和线程池的区别" class="headerlink" title="线程组和线程池的区别"></a>线程组和线程池的区别</h3><p>线程组是为了方便线程的管理，线程池是为了管理线程的生命周期，复用线程，减少创建、销毁线程的开销。<br>守护线程，可以简单理解为后台运行线程，进程结束，守护线程自然而然就会结束。JVM的垃圾回收，内存管理等都是守护线程。<br>调用线程对象的setDaemon(true)则可以将其设置为守护线程<br>注意：JRE 判断程序是否执行结束的标准是所有的前台执行线程执行完毕了，而不管后台线程的状态。<br>当使用Threadlocal维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本。<br>JMM(Java Memory Model) 内存管理模型<br>隐式锁的应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public synchronized void methodA();   // 同步方法</div><div class="line">public void methodA(); synchronized(this);  // 同步代码块</div></pre></td></tr></table></figure></p>
<h3 id="Lock-与-synchronized-区别："><a href="#Lock-与-synchronized-区别：" class="headerlink" title="Lock 与 synchronized 区别："></a>Lock 与 synchronized 区别：</h3><p>Lock 使用起来比较灵活，但是必须有释放锁的动作配合<br>Lock 必须手动释放和开启锁，而 synchronized 不需要手动释放和开启锁<br>Lock  只适用于代码块锁，而 synchronized 对象之间是互斥关系</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ConcurrentHashMap&lt;String, Integer&gt; map = new ConcurrentHashMap&lt;String,Integer&gt;();</div><div class="line">for (Map.Entry&lt;String,Integer&gt; entry : map.entrySet()) &#123;</div><div class="line">			System.out.println(entry.getKey() + &quot; = &quot; +entry.getValue());</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Java 线程池实现了一个Java高并发的、java多线程的、可管理的统一调度器Executors是个线程的工厂类，提供了一些静态方法，生成线程池常用方法三种：</li>
</ul>
<ol>
<li>newSingleThreadExecutor  创建一个单线程的线程池</li>
<li>newFieedThreadPool 创建固定大小的线程池</li>
<li>newCachedThreadPool 创建一个可缓存的线程池</li>
</ol>
<ul>
<li>线程安全的集合类 ：<br>Set : CopyOnWriteArraySet<br>List : CopyOnWriteArrayList   Vector(synchronized方法修饰)<br>Map : Hashtable(synchronized方法修饰)   ConcurrentMap -&gt; ConcurrentHashMap</li>
</ul>
</blockquote>
<h3 id="Runnable和Thread的区别"><a href="#Runnable和Thread的区别" class="headerlink" title="Runnable和Thread的区别"></a>Runnable和Thread的区别</h3><p>只要是多线程肯定永远以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类有如下好处<br>1.避免单继承的局限，一个类可以实现多个接口<br>2.适合资源的共享</p>
<p>synchronized 可以在任意对象及方法上加锁<br>虽然println() 在内部是同步的，但i–的操作是在进入println()之前发生的，所以有发生非线程安全问题的概率。<br>MyThread.java 类的构造函数是被main线程调用的，而run方法是被名为Thread-0 的线程调用的，run方法是自动调用的方法。</p>
<p>java中有3种方法可以终止正在运行的线程：<br>1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止<br>2.使用stop方法强行终止线程，不推荐，使用它们可能产生不可预料的结果<br>3.使用interrupt方法中断线程</p>
<p>调用interrupte() 方法仅仅是在当前线程中打了一个停止的标记。</p>
<h3 id="interrupted-amp-amp-isInterrupted？"><a href="#interrupted-amp-amp-isInterrupted？" class="headerlink" title="interrupted &amp;&amp; isInterrupted？"></a>interrupted &amp;&amp; isInterrupted？</h3><p>1.this.interrupted() 测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false功能<br>2.this.isInterrupted()  测试线程Thread对象是否已经是中断状态，但不清楚状态标识。</p>
<p>当进程中不存在非守护线程了，则守护线程自动销毁。典型的守护线程就是垃圾回收线程。<br>只有当最后一个非守护线程结束时，守护线程才随着JVM一同结束工作。<br>调用synchronized方法一定是排队运行的; 另外，只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本没有同步的必要。</p>
<p>当A线程调用anyObject对象调用synchronized方法修饰的X方法时，A线程就获得了X方法所在<strong>对象的锁</strong>，所以其他线程必须等A线程执行完毕才可以调用X方法，但B线程可以调用其他的非synchronized同步方法。<br>而B线程如果调用了synchronized修饰的<strong>非X方法</strong>时，必须等到A线程将X方法执行完，也就是释放对象锁之后才可以调用。</p>
<p>synchronized锁重入（自己可以再次获取自己的内部锁）<br>当一个线程得到一个对象锁后，再次请求此对象锁时可以再次得到该对象的锁。<br>这也证明在一个synchronized方法/块的内部调用本类的其他synchronized方法时，是永远可以得到锁的。</p>
<p>当存在父子类继承关系时，子类是完全可以通过“可重入锁”调用父类的同步方法的。<br>出现异常的锁被自动释放了。<br>同步不能继承。所以还得在子类的方法中添加synchronized关键字<br>同步synchronized是锁定当前对象的。</p>
<p>锁非this对象具有一定的优点：如果在一个类中有很多个 synchronized 方法，这时虽然能实现同步，但会受到阻塞，影响运行效率；但如果使用同步代码块<br>锁非this对象，则 synchronized(非this)代码块中的程序与同步方法是异步的，不与其他锁this同步方法争抢this锁，可以大大提高运行效率。</p>
<p>synchronized 关键字加到static静态方法上是给Class上锁(加锁之后若其他线程只需要对象锁也不能获取到必须等待)，而 synchronized加到非static<br>静态方法上是给对象上锁。</p>
<p>若字符串作为锁，涉及到常量池，导致两个线程持有相同的锁，其中一个线程不能运行<br>volatile 的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值<br>volatile 关键字增加了实例变量在多个线程之间的可见性。但缺点是不支持原子性。</p>
<h3 id="synchronized和volatile区别"><a href="#synchronized和volatile区别" class="headerlink" title="synchronized和volatile区别"></a>synchronized和volatile区别</h3><p>1.volatile属于线程同步逇轻量级实现，性能好。只能修饰变量，synchroinzed可以修饰方法及代码块。<br>2.多线程访问volatile不会阻塞，而synchronized会发生阻塞<br>3.volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存数据同步</p>
<p>线程安全包含原子性和可见性两个方面，java的同步机制都是围绕这两个方面来确保线程安全的。<br>除了在i++操作时使用synchronized关键字实现同步，还可以使用 AtomicInteger 原子类进行实现（java.util.concurrent.atomic.AtomicInteger）。</p>
<p>方法 boolean hasQueuedThread(Thread thread) 查询指定的线程是否正在等待获取此锁定<br>方法 boolean hasQueuedThreads()  查询是否有线程正在等待获取此锁定<br>方法 boolean hasWaiters(Condition condition)  查询是否有线程正在等待与此锁定有关的condition条件<br>eg： service.lock.hasQuedThread(threadA)    lock.hasWaiters(newCondition)   lock.getWaitQueueLength(newCondition)</p>
<h3 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h3><p>t1想中断t2的话只需要在线程t1中将线程t2对象的中断标志设置为true,然后线程2可以选择在合适的时候处理该中断请求，甚至可以不理会该请求。</p>
<h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void set(T value) &#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        // 获得一个和当前线程相关的ThreadLocalMap</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        if (map != null)</div><div class="line">        	// ThreadLocalMap 是ThreadLocal类的一个静态内部类，实现了键值对的获取</div><div class="line">        	// 键是this对象指向的ThreadLocal对象</div><div class="line">            map.set(this, value);</div><div class="line">        else</div><div class="line">            createMap(t, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public T get() &#123;</div><div class="line">Thread t = Thread.currentThread();</div><div class="line">ThreadLocalMap map = getMap(t);</div><div class="line">if (map != null) &#123;</div><div class="line">    ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">    if (e != null)</div><div class="line">        return (T)e.value;</div><div class="line">&#125;</div><div class="line">return setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进一步的，我们可以创建不同的ThreadLocal实例来实现多个变量在不同线程间的访问隔离，因为不同的ThreadLocal对象作为不同键，当然也可以在线程的ThreadLocalMap对象中设置不同的值了。</p>
<blockquote>
<p>ThreadLocal在处理线程的局部变量的时候比synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性<br>注意： 使用ThreadLocal，一般都是声明在静态变量中，如果不断的创建ThreadLocal而且没有调用其remove方法，将会导致内存泄漏，特别实在高并发的web容器中。</p>
</blockquote>
<h3 id="线程的异常处理"><a href="#线程的异常处理" class="headerlink" title="线程的异常处理"></a>线程的异常处理</h3><p>thread.setUncaughtExceptionHandler 语句来实现逻辑的注册<br>UncaughtExceptionHandler是一个接口，异常处理对象需要实现这个接口才能处理异常<br>对于checked exception 推荐try/catch 块来处理；对于unchecked exception,注册一个实现UncaughtExceptionHandler接口对象该实例来处理。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList 中的set,add,remove等方法，都使用了ReentrantLock的lock来加锁，unlock来解锁。当增加元素的时候用Arrays.copyOf()拷贝副本，在副本上增加元素，然后改变原引用指向副本。读操作不需要加锁，而写操作类实现中对其进行了加锁。因此CopyOnWriteArrayList是一个线程安全的List接口的实现，可以提供高并发读取。<br>CopyOnWrite 机制也是一种读写分离的思想<br><strong>CopyOnWrite缺点：1）内存占用问题，回收。   2）数据一致性问题，只能保证最终一致性，不能保证实时一致性</strong></p>
<h3 id="线程阀"><a href="#线程阀" class="headerlink" title="线程阀"></a>线程阀</h3><h4 id="阻塞队列-BlockingQueue"><a href="#阻塞队列-BlockingQueue" class="headerlink" title="阻塞队列 BlockingQueue"></a>阻塞队列 BlockingQueue</h4><p>支持两个附加操作的队列，在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，存储元素的线程会等待队列可用。<br>包括 DelayQueue/ArrayBlockingQueue/LinkedBlockingQueue/LinkedBlockingQueue/SynchronousQueue/PriorityBlockingQueue/LinkedBlockingDeque<br>ArrayBlockingQueue 是一个由数组支持的有界的阻塞队列。<br>LinkedBlockingQueue是基于链表的阻塞队列，对于生产者和消费者分别采用了独立的锁来控制数据同步。若构造对象的时候没有指定初始化大小，默认一个类似无限大小的容量。<br>PriorityBlockingQueue 是一个支持优先级排序的无界阻塞队列，它并不会阻塞数据生产者只会在没有可消费的数据时，阻塞数据的消费者</p>
<p>SynchronousQueue 同步队列是一个不存储元素的阻塞队列，每一个put操作必须等待一个take操作，否则不能继续添加元素。<br>CountDownLatch同步计数器：在完成一组正在其他线程中执行的操作之前，允许一个或多个线程一直等待，用给定的计数初始化CountDownLatch，由于调用了countDown方法，所以在当前计数器到达零之前，await方法会一直受阻塞，之后，会释放所有等待的线程，await的所有后续调用都立即返回。<br>使用场景： 同时当线程都完成后触发事件事件。比如：开5个多线程去下载，当5个线程都执行完了才算下载成功。</p>
<blockquote>
<p>ReentrantLock、CountDownLatch、Semaphore、FutureTask、ThreadPoolExecutor都会发现有个叫Sync的静态内部类，继承自AbstractQueuedSynchronizer。AbstractQueuedSynchronizer是java.util.concurrent的核心组件之一，它为并发包中的其他synchronizers提供了一组公共的基础设施。<br>Semaphore 是一个计数信号量，信号量维护了一个许可集合，在许可可用前会阻塞每一个acquire，然后再获取该许可，每个release添加一个许可，从而可能释放一个正在阻塞的获取者。</p>
</blockquote>
<p>线程池任务拒绝策略： 直接丢弃任务 不用线程池线程运行  丢弃队列中最旧任务 抛出异常<br>线程池一定要在合理的单例模式下才有效。<br>在某些情况情况下，可以简单的抛弃请求，依靠更高级别的协议稍后重试请求，也可以指出服务器暂时很忙的响应来拒绝请求。</p>
<h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(int i=0;i&lt;arr.length-1;i++)&#123;</div><div class="line">			for(int j=0;j&lt;arr.length-i-1;j++)&#123;</div><div class="line">				if(compareArr(arr[j],arr[j+1]) &gt; 0)&#123;</div><div class="line">					swap(arr,j,j+1);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h3 id="线程监控工具"><a href="#线程监控工具" class="headerlink" title="线程监控工具"></a>线程监控工具</h3><p>VisualVM 是JDK的一个集成的分析工具，监控应用程序的性能和内存占用情况、监控线程进行线程转储(Thread Dump)或堆转储(Heap Dump)<br>在线程一栏中，四种状态，其中监视(Monitor)表示线程想执行一端synchronized中的代码，但是发现其他线程正在执行，被block等待<br>有时候需要生产线程Dump进行那个时刻的线程分析，点击线程Dump即可生产Dump文件。可以在java VisualVM工具里面安装JTA插件，分析线程dump文件。正常阶段的dump文件与非正常的dump文件比较更容易分析问题。<br>使用JConsole进行应用程序性能监控<br>jmc(Oracle Java Mission Console)提供监控和分析</p>
<h3 id="linux线程分析监控"><a href="#linux线程分析监控" class="headerlink" title="linux线程分析监控"></a>linux线程分析监控</h3><p>获取进程ID之后(top -p 8442 -H) 用jstack打印出给定的java进程ID或core file或远程调试服务的java堆栈信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstack 8442 &gt; ./8442_dump.txt</div></pre></td></tr></table></figure></p>
<h3 id="Eclipse-里面调试并发程序"><a href="#Eclipse-里面调试并发程序" class="headerlink" title="Eclipse 里面调试并发程序"></a>Eclipse 里面调试并发程序</h3><p>默认情况下，Eclipse调试的时候debugger找到断点，只是把有断点的线程停止，其他线程都在继续他们的运行。<br>Window-&gt;preference 把 Default suspend policy for new breakpoints 改为 Suspend VM ,这样遇到断点就会暂停所有线程的运行</p>
<blockquote>
<p>利用Badboy或者Jmeter进行服务器抗压能力的测试</p>
</blockquote>
<h3 id="内存溢出三种情况"><a href="#内存溢出三种情况" class="headerlink" title="内存溢出三种情况"></a>内存溢出三种情况</h3><ol>
<li>堆溢出。解决：手动设置JVM Heap 的大小</li>
<li>永久代溢出。 设置永久代大小</li>
<li>栈溢出。优化程序，或者通过-Xss来设置每个线程的栈大小</li>
</ol>
<h3 id="ReentrantReadWriteLock-读写锁有两个锁，一个是读操作相关的锁，也成为共享锁-另一个是写操作相关的锁，也叫排它锁。多个Thread可以同时进行读取"><a href="#ReentrantReadWriteLock-读写锁有两个锁，一个是读操作相关的锁，也成为共享锁-另一个是写操作相关的锁，也叫排它锁。多个Thread可以同时进行读取" class="headerlink" title="ReentrantReadWriteLock 读写锁有两个锁，一个是读操作相关的锁，也成为共享锁;另一个是写操作相关的锁，也叫排它锁。多个Thread可以同时进行读取"></a>ReentrantReadWriteLock 读写锁有两个锁，一个是读操作相关的锁，也成为共享锁;另一个是写操作相关的锁，也叫排它锁。多个Thread可以同时进行读取</h3><p>操作，但是同一时刻只允许一个Thread进行写入操作。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池处理流程"><a href="#线程池处理流程" class="headerlink" title="线程池处理流程"></a>线程池处理流程</h4><ol>
<li>如果当前运行的线程少于corePoolSize,则创建新线程来执行任务（执行这一步骤需要获取全局锁）</li>
<li>如果运行的线程等于或多于corePoolSize,则将任务加入BlockingQueue</li>
<li>如果无法将任务加入BlockingQueue(队列已满)，则创建新的线程来处理任务u（需要获取全局锁你）</li>
<li>如果创建新线程将使得当前运行的线程超出maximumPoolSize,任务将被拒绝。<blockquote>
<p>在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤</p>
<h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4></blockquote>
</li>
<li>ArrayBlockingQueue 是一个基于数组结构的有界阻塞队列，此队列按FIFO原则对元素进行排序</li>
<li>LinkedBlockingQueue 一个基于链表结构的阻塞队列FIFO排序元素，静态工厂方法Executors.newFixedThreadPool()使用这个队列</li>
<li>SynchronousQueue 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，静态工厂方法 Executors.newCachedThreadPool使用了这个队列</li>
<li>PriorityBlockingQueue 一个具有优先级的无限阻塞队列<h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4></li>
<li>AbortPolicy 直接抛出异常</li>
<li>CallerRunsPolicy 只用调用者所在线程来运行任务</li>
<li>DiscardOldestPolicy 丢弃队列最近的一个任务，并执行当前任务</li>
<li><p>DiscardPolicy 不处理，丢弃</p>
<h4 id="execute-amp-amp-submit-区别"><a href="#execute-amp-amp-submit-区别" class="headerlink" title="execute &amp;&amp; submit 区别"></a>execute &amp;&amp; submit 区别</h4><p>execute() 方法用于提交不需要返回值的任务</p>
<ul>
<li><p>submit()方法用于提交需要返回值的任务 ，返回一个future对象，通过future的get()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">threadPool.execute(new Runnable()&#123;</div><div class="line">   public void run()&#123; ... &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>方法来获取返回值，get方法会阻塞当前线程一段时间后立即返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Future&lt;Object&gt; future = executor.submit(harrReturnValuetask);</div><div class="line">Object s = future.get();</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="shutdown-amp-amp-shutdownNow-区别"><a href="#shutdown-amp-amp-shutdownNow-区别" class="headerlink" title="shutdown &amp;&amp; shutdownNow 区别"></a>shutdown &amp;&amp; shutdownNow 区别</h3><ul>
<li>shutdownNow 首先将线程池的状态设置为STOF，然后尝试停止所有的正在执行或暂停执行的线程，并返回等待执行任务的列表</li>
<li>shutdown 只是将线程池的状态设置为SHUTDOWN状态，然后中断所有没有正在执行的线程</li>
</ul>
<blockquote>
<p>编译器优化重排序和处理器冲排序会导致多线程出现内存可见性问题<br>两个操作之间具有happens-before关系，并不意味这前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作对后一个操作可见。</p>
</blockquote>
<h3 id="Thread-join的使用"><a href="#Thread-join的使用" class="headerlink" title="Thread.join的使用"></a>Thread.join的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        Thread previous = Thread.currentThread();</div><div class="line">        for(int i=0;i&lt;10;i++)&#123;</div><div class="line">            Thread t = new Thread(new TestA(previous),String.valueOf(i));</div><div class="line">            t.start();</div><div class="line">            previous = t;</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName()+&quot; terminated!&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="游标的使用"><a href="#游标的使用" class="headerlink" title="游标的使用"></a>游标的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Declare cursor CURSOR for</div><div class="line">select stuID from student</div><div class="line">open cursor</div><div class="line">fetch next from cursor</div><div class="line">while @@fetch_status =0</div><div class="line">begin</div><div class="line">if (@ID=15)</div><div class="line">	delete from student where id=@ID</div><div class="line">	fetch next from cursor into @ID</div><div class="line">end</div><div class="line">close cursor</div><div class="line">deallocate cursor</div></pre></td></tr></table></figure>
<h3 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h3><p>TCP是传输控制协议，提供的面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。<br>TCP提供超时重发、丢弃重复数据、校验数据、流量控制等功能，保证数据能从一端传到另一端。<br>UDP是用户数据报协议，无连接的面向数据包的传输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据包发送出去，但是并不保证他们能到达目的地。由于UDP在传输数据前不需要建立链接，且没有超时重发机制，所以传输速度快。</p>
<h3 id="编写Socket套接字"><a href="#编写Socket套接字" class="headerlink" title="编写Socket套接字"></a>编写Socket套接字</h3><p>调用socket()创建一个套接字，调用bind()绑定IP地址和端口，然后启动一个死循环，循环中调用accept接受链接。对于每个接受的连接，可以启动多线程<br>方式进行处理，在线程中调用send(),recv()发送和接受数据。客户端只需要调用socket()创建套接字，连接服务器，就可以发送和接受数据了。</p>
<h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><p>SQL注入攻击 就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串中，欺骗服务器执行恶意的SQL命令。在某些表单中，用户输入的内容<br>直接用来构造动态SQL命令，或作为存储过程的输入参数。<br>防范SQL注入攻击：替换单引号，连字符   检查用户输入的合法性    将用户登录名称密码等数据加密保存   存储过程执行所有的查询</p>
<h3 id="数据库四范式"><a href="#数据库四范式" class="headerlink" title="数据库四范式"></a>数据库四范式</h3><p>1NF  所有属性值域中每一个值都是不可再分解的值<br>2NF  如果关系模式R为第一范式，并且R中每一个非主属性完全函数依赖于R的某个候选键<br>3NF  如果关系模式R是第二范式，且每个非主属性都不传递依赖于R的候选键<br>BCNF 如果关系模式R是第一范式，且每个属性都不传递依赖于R的候选键，那么成R为BCNF的模式</p>
<p>死锁的4个必要条件是： 互斥 请求与保持  不剥夺条件  循环等待条件</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java面试基础]]></title>
      <url>http://yoursite.com/2016/03/02/java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>布尔类型的默认初始值是false<br>main方法是静态的，不能访问一个非静态的变量<br>main函数不能调用静态方法是指不能通过this调用非静态方法<br>需要读比较大的文本文件 new BufferedReader(new InputStreamReader(new FileInputStream(“file.txt”)))<br>如何实现java的序列化？<br>实现Serializable接口，要想创建序列化对象，先创建一个OutputStream，然后把它嵌进ObjectOutputStream，用writeObject()<br>方法把对象写入OutputStream。读的时候需要把InputStream嵌到OjbectInputStream中，然后再调用readObject()方法。不过<br>这样读出来的只是一个Object的reference，使用之前，强制转换类型。<br>调用System类中的静态gc()方法可以运行垃圾收集器，但这样并不能保证立即回收指定对象</p>
<h3 id="查看jar包源码"><a href="#查看jar包源码" class="headerlink" title="查看jar包源码"></a>查看jar包源码</h3><p>添加jar包源码<br>建立libs-src ,复制volley-source.jar<br>在libs目录中，新建 volley.jar.properties文件<br>添加 src=..\libs-src\volley-sources.jar，重启项目<br>判断一块内存空间是否符合垃圾收集器标准是：</p>
<ol>
<li>给对象赋予了控制null，以后再也没掉用过</li>
<li>给对象赋予了新值，即重新分配了内存空间<h3 id="Object-基类方法包含"><a href="#Object-基类方法包含" class="headerlink" title="Object 基类方法包含"></a>Object 基类方法包含</h3>clone()  创建并返回对象的一个副本<br>equals()  notify()  notifyAll()   wait()  toString()<br>finalize()   当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法<br>hashCode()   返回该对象的哈希值</li>
</ol>
<h3 id="不通过构造函数能创建对象吗？"><a href="#不通过构造函数能创建对象吗？" class="headerlink" title="不通过构造函数能创建对象吗？"></a>不通过构造函数能创建对象吗？</h3><p>1.用new语句创建<br>2.运用反射，调用java.lang.Class 或者  java.lang.reflect.ConStruct 类的newInstance()实例方法<br>3.调用对象的clone() 方法<br>4.运用反序列手段，调用java.io.ObjectInputStream 对象的readObject() 方法<br>重点题目 P100<br>Collection(List Set Queue)   Map(HashMap  HashTable  TreeMap )</p>
<h3 id="遍历HashMap的两种方式"><a href="#遍历HashMap的两种方式" class="headerlink" title="遍历HashMap的两种方式"></a>遍历HashMap的两种方式</h3><p>第一种:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　Map map = new HashMap();</div><div class="line">　　Iterator iter = map.entrySet().iterator();</div><div class="line">　　while (iter.hasNext()) &#123;</div><div class="line">　　    Map.Entry entry = iter.next();</div><div class="line">System.out.println(entry.getKey()+&quot; &quot;+entry.getValue());</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>第二种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</div><div class="line">		System.out.println(entry.getKey()+&quot; &quot;+entry.getValue());</div><div class="line">			&#125;</div></pre></td></tr></table></figure></p>
<p>如果只是遍历key而无需value，可以直接用  for(String key : map.keySet()){ … }<br>URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。<br>URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位</p>
<h3 id="HashMap-和-HashTable-区别-？"><a href="#HashMap-和-HashTable-区别-？" class="headerlink" title="HashMap 和 HashTable 区别 ？"></a>HashMap 和 HashTable 区别 ？</h3><p>HashMap 线程不安全的，允许一个null键和多个null值<br>HashTable 线程安全的，不允许null键和null值，比HashMap慢，因为它是同步的。<br>HashMap 把Hashtable的contains()方法替换为了 containsValue()和containsKey()</p>
<p>构造函数是没有返回值的。<br>当创建一个子类的时候，会调用父类的构造方法<br>什么是多态 ？</p>
<h3 id="重载和重写有什么不同？"><a href="#重载和重写有什么不同？" class="headerlink" title="重载和重写有什么不同？"></a>重载和重写有什么不同？</h3><p>具有不同参数列表（参数的类型、个数、顺序不同）的同名函数，程序胡根据不同的参数列来确定具体调用那个函数，这种机制<br>叫做重载，重载不关心函数的返回值类型。覆盖是指派生类中存在重新定义的函数，其函数名、参数列、返回值类型必须同父类<br>中对应被覆盖的的函数严格一致，但派生类对象调用子类中该同名方式时会自动调用子类中的覆盖版本。<br>子类的构造函数如果引用super，必须把super放在函数的首位<br>this关键字使用在一个成员函数的内部，指向当前对象，当前对象指的是调用当前正在执行方法的那个对象。super关键字是直接<br>指向超类的构造函数，用来引用超类中的变量和方法。</p>
<h3 id="什么是Java虚拟机？"><a href="#什么是Java虚拟机？" class="headerlink" title="什么是Java虚拟机？"></a>什么是Java虚拟机？</h3><p>Java 虚拟机是一个可以执行Java字节码的虚拟机进程。Java 源文件被编译成能被Java虚拟机执行的字节码文件。<br>Java 虚拟机知道底层硬件平台的指令长度和其他特性。<br>static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？<br> static 关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。<br>Java 中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类<br>的任何实例都不相关<br>java的8种数据类型 byte short  boolean char  int long float double</p>
<h3 id="有哪几种存储结构？"><a href="#有哪几种存储结构？" class="headerlink" title="有哪几种存储结构？"></a>有哪几种存储结构？</h3><p>1.随机存取。可以任意存取任意一个元素<br>2.顺序存取。只能从前到后逐个访问，比如链表结构<br>3.索引存取。索引存取是为某个关键字建立索引表，从所有的表中得到地址，在直接访问<br>4.散列存取。建立散列表，根据key计算出存储位置，相当于一种索引</p>
<p>有1千万条有重复的短信，用五分钟时间找出重复出现最多的10条短信。<br>方法1：</p>
<p>方法2：</p>
<p>方法3：</p>
<p>百度或淘宝搜索时，出现搜索建议，采用什么数据结构实现？<br>字典树，是一种噶洗漱的变种，一种用于快速检索的多叉树结构。用于统计和排序大量的字符串，经常被搜索引擎用于文本词频<br>统计。核心思想是空间换时间。利用该字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<p>排序：<br>在待排序的文件中，若存在多个关键字相同的记录，经过排序后，这些具有相同关键字的记录之间的相对次序保持不变，该排序<br>方法是稳定的；若具有相同关键字的记录之间的相对次序发生变化，则称这种排序方法是不稳定的。<br>排序时不涉及数据的内外存交换，称之为内部排序；反之，排序过程要进行数据的内外存交换，称之为外部排序。</p>
<p>冒泡排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void bublbleSort(int[] source) &#123;</div><div class="line">		for(int i = source.length-1;i &gt; 0;i --) &#123;</div><div class="line">			for(int j = 0; j &lt; i; j ++) &#123;</div><div class="line">				if(source[j] &gt; source[j+1]) &#123;</div><div class="line">					swap(source,j,j+1);</div><div class="line">				&#125;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>选择排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void selectSort(int[] source) &#123;</div><div class="line">		for(int i = 0;i&lt;source.length;i++) &#123;</div><div class="line">			for(int j = i+1;j&lt;source.length;j++) &#123;</div><div class="line">				if(source[i] &gt; source[j]) &#123;</div><div class="line">					swap(source, j, i);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>插入排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static void insertSort(int[] source) &#123;</div><div class="line">		for(int i = 0;i&lt;source.length;i++) &#123;</div><div class="line">			for(int j =i;(j&gt;0 &amp;&amp; source[j] &lt; source[j-1]);j--) &#123;</div><div class="line">					swap(source, j, j-1);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>快速排序</p>
<p>String s = “a”+”b”+”c”+”d”+”e”  产生了一个对象，因为赋值符号右边的字母都是常量，对于常量，编译时就直接存储他们<br>的字面值，而不是他们的引用。在编译时就把他们连接的结果提取出来变成了”abcde”<br>new String(“jinder”) 实际创建了2个对象，一个是”jinder”通过””双引号创建的，另一个是通过new创建的，只不过他们创建<br>的时期不同，一个是编译期，一个是运行期。<br>运行期调用String类型的intern()方法可以向StringPool中动态添加对象</p>
<p>简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？<br>Lock 能完成synchronized所实现的所有功能。主要不同点是，Lock 有比synchronized更精确的线程语义和更好的性能。synchronized<br>会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。</p>
<p>只要当前JVM实例尚存在任何一个非守护线程没有结束，守护线程就全部工作;只有当最后一个非守护线程结束时，守护线程随着JVM一同<br>结束任务。守护线程最典型的应用就是GC。</p>
<h3 id="存储过程和函数的区别是什么？"><a href="#存储过程和函数的区别是什么？" class="headerlink" title="存储过程和函数的区别是什么？"></a>存储过程和函数的区别是什么？</h3><p>存储过程是用户定义的一系列SQL语句的集合，设计特定表或其他对象的任务，用户可以调用存储过程，而函数通常是数据库已经定义的<br>方法，它接受参数并返回某种类型的值，而且不涉及特定用户表。<br>游标作用是什么？怎样判断游标到了最后？<br>游标用来定位结果集中的行，通过判断@@FETCH_STATUS，可以判断游标是否到了最后，通常此变量不等于0表示出错或者到了最后。<br>行级触发器在所影响的每一行触发一次。</p>
<h3 id="数据库查询优化"><a href="#数据库查询优化" class="headerlink" title="数据库查询优化"></a>数据库查询优化</h3><p>执行数据库查询时，如果要查询的数据有很多，假设1000万，用什么办法可以提高查询效率？在数据库方面或java代码方面优化 ？<br>1.在数据库方面<br>建立索引   分区（MySQL，比如按时间分区）   尽量使用固定长度的字段    限制字段长度<br>2.在数据库 I/O 方面<br>增加缓冲区    如果涉及表的级联，不同的表存储在不同的磁盘上，以增加IO速度<br>3.在SQL方面<br>优化sql语句，减少比较次数     限制返回的条目数（MySQL 里面用limit）<br>4.在java方面<br>对于反复查询使用的查询，使用PreparedStatement 减少查询次数</p>
<p>unique 约束能够约束一列保证该列值唯一，但允许有空值</p>
<h3 id="NAT技术"><a href="#NAT技术" class="headerlink" title="NAT技术"></a>NAT技术</h3><p>NAT 技术（网络地址转换）是一种将一个IP地址域映射到另一个IP地址域的技术，从而为终端主机提供透明路由。NAT 包括静态网络地址<br>转换、动态网络地址转换、端口映射等。NAT 常用语私有地址域与工友地址的转换，解决IP地址匮乏的问题、在防火墙上实现了NAT以后<br>可以隐藏受保护网络的内部拓扑结构，在一定程度上提高网络的安全性。</p>
<h3 id="IP-地址分配"><a href="#IP-地址分配" class="headerlink" title="IP 地址分配"></a>IP 地址分配</h3><p>A 类地址 １-127      0<br>B 类地址 128 - 191   10<br>C 类地址 192-223     110<br>FTP 是有连接的服务，必须基于TCP协议</p>
<h3 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h3><p>第一次握手：建立连接时，客户端发送SYN包到服务器，并进入SYN_SEND状态，等待服务器确认。<br>第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器<br>进入SYN_RECV状态。<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认宝ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED<br>状态，完成三次握手。<br>完成三次握手后，客户端和服务器开始传送数据。<br>未连接队列：在三次握手协议中，服务器维护一个未连接队列，该队列未每个客户端的SYN包开设一个条目，该条目表明服务器已收到SYN<br>包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于SYN_RECV状态，当服务器收到客户端的确认包，<br>删除该条目，服务器进入ESTABLISHED状态。</p>
<h3 id="ping命令基于什么协议？"><a href="#ping命令基于什么协议？" class="headerlink" title="ping命令基于什么协议？"></a>ping命令基于什么协议？</h3><p>ICMP Internet 控制消息协议是TCP/IP 协议族的一个自协议，用于在IP主机、路由器之间传递控制消息，控制消息是指网路通不通，<br>主机是否可达，路由是否可用等网络本身的消息。ping命令向指定的IP地址发送一定长度的数据包，按照约定，若指定的IP存在的话，<br>会返回同样大小的数据包，若在特定的时间没有返回，超时，则认为IP不存在。</p>
<p>子网掩码是用来判断任意两台计算机的IP地址是否属于同一子网络的根据。两台计算机各自的IP地址域子网掩码进行AND运算之后，<br>如果得出的结果是相同的额，则说明两台计算机是处于同一个子网络的，可以进行直接的通信。</p>
<h3 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h3><p>Iterator 接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的<br>过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。<br>如何确保N个线程可以访问N个资源同时又不导致死锁？<br>指定获取锁的顺序，并强制线程按照指定的顺序获取锁。</p>
<h3 id="在监视器-Monitor-内部，是如何做线程同步的？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？"></a>在监视器(Monitor)内部，是如何做线程同步的？</h3><p>监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个<br>对象引用相关联。线程在获取锁之前不允许执行同步代码。</p>
<h3 id="同步方法和同步代码块的区别？"><a href="#同步方法和同步代码块的区别？" class="headerlink" title="同步方法和同步代码块的区别？"></a>同步方法和同步代码块的区别？</h3><p>同步方法默认用this或者当前类class对象作为锁；<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；</p>
<p>应用程序可以使用Executor框架来创建线程池 (创建线程的方式还有 继承Thread类，实现Runnable接口 )</p>
<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><p>重载发生在同一个类里面，多个方法名相同但是形参列表不同的情况，返回类型可以相同也可以不同。<br>重写发生在父类子类里面，子类重新定义了父类方法，方法重写（覆盖）必须有相同的方法名、形参列表和返回类型。</p>
<h3 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h3><p>Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：<br>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。<br>类可以实现很多个接口，但是只能继承一个抽象类<br>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。<br>抽象类可以在不提供接口方法实现的情况下实现接口。<br>Java 接口中声明的变量默认都是final的。抽象类可以包含非final的变量。<br>Java 接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。<br>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。<br>也可以参考JDK8中抽象类和接口的区别</p>
<h3 id="HashMap和Hashtable区别？"><a href="#HashMap和Hashtable区别？" class="headerlink" title="HashMap和Hashtable区别？"></a>HashMap和Hashtable区别？</h3><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：<br>HashMap允许键和值是null，而Hashtable不允许键或者值是null。<br>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。</p>
<h3 id="Java中的HashMap的工作原理？"><a href="#Java中的HashMap的工作原理？" class="headerlink" title="Java中的HashMap的工作原理？"></a>Java中的HashMap的工作原理？</h3><p>Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合<br>/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key<br>已经存在了，value会被更新成新值;若计算出来的索引位置相同，形成Entry链。</p>
<p>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？<br>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，<br>而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全<br>失败的迭代器永远不会抛出这样的异常。</p>
<h3 id="ArrayList和LinkedList区别？"><a href="#ArrayList和LinkedList区别？" class="headerlink" title="ArrayList和LinkedList区别？"></a>ArrayList和LinkedList区别？</h3><p>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：<br>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。<br>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p>
<h3 id="Array和ArrayList区别？"><a href="#Array和ArrayList区别？" class="headerlink" title="Array和ArrayList区别？"></a>Array和ArrayList区别？</h3><p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。<br>Array大小是固定的，ArrayList的大小是动态变化的。<br>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</p>
<h3 id="Iterator和ListIterator的区别？"><a href="#Iterator和ListIterator的区别？" class="headerlink" title="Iterator和ListIterator的区别？"></a>Iterator和ListIterator的区别？</h3><p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引</p>
<h3 id="Comparable和Comparator接口"><a href="#Comparable和Comparator接口" class="headerlink" title="Comparable和Comparator接口"></a>Comparable和Comparator接口</h3><p>Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。<br>Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序。</p>
<h3 id="Java优先级队列-Priority-Queue-？"><a href="#Java优先级队列-Priority-Queue-？" class="headerlink" title="Java优先级队列(Priority Queue)？"></a>Java优先级队列(Priority Queue)？</h3><p>PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供<br>一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，<br>riorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。</p>
<p>什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？<br>CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励<br>用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是：CallableStament.prepareCall();</p>
<p>PreparedStatement比Statement有什么优势？<br>PreparedStatements是预编译的，因此，性能会更好。同时，不同的查询参数值，PreparedStatement可以重用。</p>
<h3 id="URL编码和URL解码？"><a href="#URL编码和URL解码？" class="headerlink" title="URL编码和URL解码？"></a>URL编码和URL解码？</h3><p>URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。</p>
<h3 id="doGet-方法和doPost-方法区别？"><a href="#doGet-方法和doPost-方法区别？" class="headerlink" title="doGet()方法和doPost()方法区别？"></a>doGet()方法和doPost()方法区别？</h3><p>doGet: GET 方法会把键值对追加在请求的URL后面。因为URL对字符数目有限制， 限制了用在客户端请求的参数值的数目。并且请求中<br>的参数值是可见的 ，不够安全。<br>doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。<br>最后，通过POST请求传递的敏感信息对外部客户端是不可见的。</p>
<h3 id="解释下Servlet的生命周期。"><a href="#解释下Servlet的生命周期。" class="headerlink" title="解释下Servlet的生命周期。"></a>解释下Servlet的生命周期。</h3><p>对每一个客户端的请求，Servlet引擎 载入Servlet，调用它的init()方法，完成Servlet的初始化。然后，Servlet 对象通过为每一个<br>请求单独调用service()方法来处理所有随后来自客户端的请求，最后，调用Servlet的destroy()方法把Servlet卸载掉。</p>
<h3 id="什么是Servlet？"><a href="#什么是Servlet？" class="headerlink" title="什么是Servlet？"></a>什么是Servlet？</h3><p>Servlet 是用来处理客户端请求并产生动态网页内容的Java类。Servlet 主要是用来处理或者是存储HTML表单提交的数据，产生动态内容</p>
<h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>Java 程序可以加载一个运行时才得知名称的 class，获悉其完整构造（但不包括methods定义），并生成其对象实体、<br>或对其fields设值、或唤起其methods。</p>
<h3 id="匿名内部类的变量必须final修饰？"><a href="#匿名内部类的变量必须final修饰？" class="headerlink" title="匿名内部类的变量必须final修饰？"></a>匿名内部类的变量必须final修饰？</h3><p>首先内部类的生命周期是成员级别的，而局部变量的生命周期是在方法体之类，当mRun方法执行，new<br>的线程运行，新线程里面会睡一秒。主线程会继续执行，mRun执行完毕，name属性生命周期结束，Java就是为了杜绝这种错误，严格要求<br>内部类中方位局部变量，必须使用final关键字修饰。局部变量被final修饰之后，此时会在内存中保有一份局部变得的复制品，当内部类<br>访问的时候其实访问的是这个复制品。</p>
<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test() &#123;</div><div class="line">	Integer a = new Integer(1000) ; int b = 1000;</div><div class="line">	Integer c = new Integer(10); Integer d = new Integer(10);</div><div class="line">	System.out.println(a == b);    //true   自动拆箱为int</div><div class="line">	System.out.println(c == d);    //false</div><div class="line">&#125;</div><div class="line">//Integer.java valueOf 方法中把-128-127 缓存了下来。官方解释是小的数字使用的频率比较高， 为了优化性能，把这之间的数缓存了下来</div><div class="line">@Test</div><div class="line">public void testInteger()&#123;</div><div class="line">	Integer a = 1000,b=1000;</div><div class="line">	Integer c = 100,d=100;</div><div class="line">	System.out.println(a==b);   //false  new出来的</div><div class="line">	System.out.println(c==d);   //true   缓存中的</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>[reference] <a href="http://www.imooc.com/article/2964" target="_blank" rel="external">http://www.imooc.com/article/2964</a></p>
<h3 id="调用三种方式"><a href="#调用三种方式" class="headerlink" title="调用三种方式"></a>调用三种方式</h3><p>模块之间都存在一定的调用关系，从调用方式上看，可以分为三类同步调用、异步调用和回调。同步调用是一种阻塞式调用，异步调用是一种<br>类似消息或事件的机制解决了同步阻塞的问题，回调是一种双向的调用模式，也就是说，被调用的接口被调用时也会调用对方的接口，例如A<br>要调用B,B在执行完又要调用A。<br>public interface FileNameFilter{<br>    boolean accept(File dir,String name);<br>}</p>
<h3 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h3><p>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。<br>一个接口能继承另一个接口，这和类之间的继承比较相似。也就是说实现某一个接口之后，可能要实现的方法不是直接接口定义的方法，<br>可能是该接口继承于另外一个接口的方法。<br>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：<br>1.建立一个公共的父接口<br>2.向一个类添加数据类型</p>
<h3 id="SQL三范式"><a href="#SQL三范式" class="headerlink" title="SQL三范式"></a>SQL三范式</h3><p>SQL语言支持关系数据库的三级模式结构，其中，视图对应外模式，基本表对应模式，存储文件对应内模式。<br>通过分解，可以将一个低一级别的关系模式转换成若干个高一级范式的关系模式，这种过程叫做规范化。<br>eg: FIRST(Sno,Sname,Status,City,Pno,Qty)<br>依赖关系： F={ Sno-&gt; Sname,Sno-&gt;Status,Status-&gt;City,(Sno,Pno)-&gt;Qty}</p>
<ul>
<li>1NF(第一范式)<br>定义：若关系模式R的每一个分量是不可再分的数据项，则关系模式R属于第一范式<br>FIRST属于第一范式，但1NF存在4个问题：<br>冗余度大，每个Sno,Sname,Status,City 要与其供应的零件的种类一样多<br>引起修改操作的不一致性<br>插入异常，若某个供应者某些信息没有提供(比如没有Pno)则不能进行插入操作</li>
<li>2NF(第二范式)<br>定义：若关系模式R属于1NF,且每一个非主属性完全依赖于码，则关系模式R属于2NF<br>也就是说，当1NF消除了非主属性对码的部分函数依赖，则成为2NF<br>将FIRST分解为 FIRST1(Sno,Sname,Status,City) 和 FIRST2(Sno,Pno,Qty) 分解后，FIRST1 的 非主属性 Sname,Status,City 完全依赖<br>于码 Sno,FIRST2的非主属性 Qty 完全依赖于码 Sno,Pno,所以属于2NF</li>
<li>3NF(第三范式)<br>若关系模式中不存在这样的码X，属性组Y以及非主属性Z，使得X-&gt;Y,Y-Z成立，则关系模式R属于3NF<br>即当2NF消除了非主属性对码的传递函数依赖，则成为3NF<br>分解为 FIRST1(Sno,Sname,Status)  FIRST2(Status,City)   FIRST3(Sno,Pno,Qty)<br>3NF的模式肯定是2NF,产生冗余和异常的两个重要原因是部分依赖和传递依赖，因为3NF模式中不存在非主属性对码的部分函数依赖和<br>传递函数依赖，所以具有较高的性能，通常变换为3NF或更高级别的凡是，这种变化过程成为“关系模式的规范化处理”<h3 id="Webservice"><a href="#Webservice" class="headerlink" title="Webservice"></a>Webservice</h3>W  ebService是一种跨编程语言和跨操作系统平台的远程调用技术。<br>远程调用，就是一台计算机a上的一个程序可以调用到另外一台计算机b上的一个对象的方法，譬如，银联提供给商场的pos刷卡系统，<br>商场的POS机转账调用的转账方法的代码其实是跑在银行服务器上。再比如，amazon，天气预报系统，淘宝网，校内网，百度等把自己的<br>系统服务以webservice服务的形式暴露出来，让第三方网站和程序可以调用这些服务功能，这样扩展了自己系统的市场占有率，就是<br>所谓的SOA应用。<br> WebService是建立可互操作的分布式应用程序的新平台，是一个平台，是一套标准。它定义了应用程序如何在Web上实现互操作性<br>Web service平台必须提供一种标准来描述Web service，让客户可以得到足够的信息来调用这个Web service<br>XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术。<br>WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务<br>对象的返回结果是什么）。XML是WebService平台中表示数据的格式。<br>SOAP协议 = HTTP协议 + XML数据格式<br>WSDL(Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。<br>它是WebService客户端和服务器端都能理解的标准格式。<h3 id="Java-String-split-用法"><a href="#Java-String-split-用法" class="headerlink" title="Java String.split()用法"></a>Java String.split()用法</h3>String.split(“\.”) //用 . 分割字符串<br>acount=?and uu =? or n=?”,把三个都分隔出来可以用String.split(“and|or”); //分割多个</li>
</ul>
<p>需要在程序中存储许多字符串常量，所以就想到了枚举</p>
<h3 id="获取用户IP"><a href="#获取用户IP" class="headerlink" title="获取用户IP"></a>获取用户IP</h3><p>public static String getIpAddr(HttpServletRequest request) {<br>        String ip = request.getHeader(“x-forwarded-for”);<br>        if (ip == null || ip.length() == 0 || “unknown”.equalsIgnoreCase(ip)) {<br>            ip = request.getHeader(“Proxy-Client-IP”);<br>        }<br>        if (ip == null || ip.length() == 0 || “unknown”.equalsIgnoreCase(ip)) {<br>            ip = request.getHeader(“WL-Proxy-Client-IP”);<br>        }<br>        if (ip == null || ip.length() == 0 || “unknown”.equalsIgnoreCase(ip)) {<br>            ip = request.getRemoteAddr();<br>        }<br>        return ip;<br>    }</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[markdown语法]]></title>
      <url>http://yoursite.com/2016/01/17/markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">* hello world           *代表项目编号</div><div class="line">``` System.out.println()</div><div class="line">```                      代码风格</div><div class="line">[on GitHub](https://github.com/jbt/markdown-editor)  超链接</div><div class="line">[StackEdit][6]   [6]: https://github.com/benweet/stackedit    超链接</div><div class="line">- **hello world**   **xxx** 加粗 等同于 ctrl+B,斜体 ctrl+I</div><div class="line"> - 加粗    `Ctrl + B`</div><div class="line"> - 斜体    `Ctrl + I`</div><div class="line"> - 引用    `Ctrl + Q`</div><div class="line"> - 插入链接    `Ctrl + L`</div><div class="line"> - 插入代码    `Ctrl + K`</div><div class="line"> - 插入图片    `Ctrl + G`</div><div class="line"> - 提升标题    `Ctrl + H`</div><div class="line"> - 有序列表    `Ctrl + O`</div><div class="line"> - 无序列表    `Ctrl + U`</div><div class="line"> - 横线    `Ctrl + R`</div><div class="line"> - 撤销    `Ctrl + Z`</div><div class="line"> - 重做    `Ctrl + Y`</div><div class="line"></div><div class="line">表格</div><div class="line">项目  |  价格  | 总结</div><div class="line">------|--------| -------</div><div class="line">使用冒号对齐</div><div class="line">| :-------- | --------:| :--: |</div><div class="line">项目1</div><div class="line">	定义A     : 定义A</div><div class="line">hello world [^footnote]  生成脚注</div><div class="line">[TOC]  生成目录</div><div class="line">公式 $$E=mc^2$$</div><div class="line"></div><div class="line">```flow                 --流程图</div><div class="line">st=&gt;start: Start</div><div class="line">op=&gt;operation: Your Operation</div><div class="line">cond=&gt;condition: Yes or No?</div><div class="line">e=&gt;end</div><div class="line"></div><div class="line">st-&gt;op-&gt;cond</div><div class="line">cond(yes)-&gt;e</div><div class="line">cond(no)-&gt;op</div></pre></td></tr></table></figure>
<p><del>helloworld</del> 删除线</p>
<p>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DesignPattern]]></title>
      <url>http://yoursite.com/2016/01/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="设计模式学习笔记"><a href="#设计模式学习笔记" class="headerlink" title="设计模式学习笔记"></a>设计模式学习笔记</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class SchoolGirl &#123;</div><div class="line">	private String name;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>接口（代理类和真实类实现同一个接口，代理持有一个真实类对象的引用，具体实现由真实类完成）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface GiveGift &#123;</div><div class="line">	void GiveDolls();</div><div class="line">	void GiveFlowers();</div><div class="line">	void GiveChocolate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>真实类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Pursuit implements GiveGift&#123;</div><div class="line">	SchoolGirl mm;</div><div class="line">	public Pursuit(SchoolGirl mm) &#123;</div><div class="line">		this.mm = mm;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void GiveDolls() &#123;</div><div class="line">		System.out.println(&quot;give dolls&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void GiveFlowers() &#123;</div><div class="line">		System.out.println(&quot;give flowers&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void GiveChocolate() &#123;</div><div class="line">		System.out.println(&quot;give cholocate&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Proxy implements GiveGift &#123;</div><div class="line">	Pursuit gg;</div><div class="line">	public Proxy(SchoolGirl mm) &#123;</div><div class="line">		this.gg = new Pursuit(mm);   //代理类就是持有一个真实类的引用</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void GiveDolls() &#123;</div><div class="line">		gg.GiveDolls();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void GiveFlowers() &#123;</div><div class="line">		gg.GiveFlowers();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void GiveChocolate() &#123;</div><div class="line">		gg.GiveChocolate();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SchoolGirl jiaojiao = new SchoolGirl();</div><div class="line">		jiaojiao.setName(&quot;jiaojiao&quot;);</div><div class="line">		Proxy daili = new Proxy(jiaojiao);</div><div class="line">		daili.GiveChocolate();</div><div class="line">		daili.GiveFlowers();</div><div class="line">		daili.GiveDolls();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">public class Operation &#123;</div><div class="line">	public double numberA=0;</div><div class="line">	public double numberB=0;</div><div class="line"></div><div class="line">	public double getNumberA() &#123;</div><div class="line">		return numberA;</div><div class="line">	&#125;</div><div class="line">	public void setNumberA(double numberA) &#123;</div><div class="line">		this.numberA = numberA;</div><div class="line">	&#125;</div><div class="line">	public double getNumberB() &#123;</div><div class="line">		return numberB;</div><div class="line">	&#125;</div><div class="line">	public void setNumberB(double numberB) &#123;</div><div class="line">		this.numberB = numberB;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public double GetResult()&#123;</div><div class="line">		double result=0;</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class OperationAdd extends Operation&#123;</div><div class="line">	@Override</div><div class="line">	public double GetResult() &#123;</div><div class="line">		return numberA+numberB;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public class OperationMinus extends Operation&#123;</div><div class="line">	 @Override</div><div class="line">	public double GetResult() &#123;</div><div class="line">		 return numberA - numberB;</div><div class="line">	 &#125;</div><div class="line">&#125;</div><div class="line">public class OperationFactory &#123;</div><div class="line">	public static Operation createOperation(String operateString)&#123;</div><div class="line">		Operation operate = null;</div><div class="line">		switch(operateString)&#123;</div><div class="line">		case &quot;+&quot;:</div><div class="line">			operate = new OperationAdd();</div><div class="line">			break;</div><div class="line">		case &quot;l&quot;:</div><div class="line">			operate = new OperationMinus();</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		return operate;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">测试代码</div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Operation operate = null;</div><div class="line">		operate = OperationFactory.createOperation(&quot;+&quot;);</div><div class="line">		operate.setNumberA(33);</div><div class="line">		operate.setNumberB(44);</div><div class="line">		System.out.println(operate.GetResult());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">public abstract class CashSuper &#123;</div><div class="line">	public abstract double acceptCash(double money);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CashNormal extends CashSuper&#123;</div><div class="line">	@Override</div><div class="line">	public double acceptCash(double money) &#123;</div><div class="line">		return money;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CashRebate extends CashSuper&#123;</div><div class="line">	public double moneyRebate=0.8;</div><div class="line">	public  CashRebate(String money) &#123;</div><div class="line">		this.moneyRebate = Double.parseDouble(money);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public double acceptCash(double money) &#123;</div><div class="line"></div><div class="line">		return money*moneyRebate;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CashReturn extends CashSuper &#123;</div><div class="line">	public double moneyCondition=0;</div><div class="line">	public double moneyReturn = 0;</div><div class="line">	public CashReturn(String moneyCondition, String moneyReturn) &#123;</div><div class="line">		this.moneyCondition = Double.parseDouble(moneyCondition);</div><div class="line">		this.moneyReturn = Double.parseDouble(moneyReturn);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public double acceptCash(double money) &#123;</div><div class="line">		if(money &gt; moneyCondition)</div><div class="line">			return money-Math.floor(money/moneyCondition)*moneyReturn;</div><div class="line">		else</div><div class="line">			return money;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CashContext &#123;</div><div class="line">	CashSuper cs = null;</div><div class="line">	public CashContext(String type) &#123;</div><div class="line">		switch(type)&#123;</div><div class="line">		case &quot;normal&quot;:</div><div class="line">			cs = new CashNormal();</div><div class="line">			break;</div><div class="line">		case &quot;cashRebate&quot;:</div><div class="line">			cs = new CashRebate(&quot;0.8&quot;);</div><div class="line">			break;</div><div class="line">		case &quot;caseReturn&quot;:</div><div class="line">			cs = new CashReturn(&quot;300&quot;, &quot;100&quot;);</div><div class="line">			break;</div><div class="line">		 &#125;</div><div class="line">	&#125;</div><div class="line">	public double GetResult(double money)&#123;</div><div class="line">		return cs.acceptCash(money);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">测试代码</div><div class="line">	public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		/*CashSuper cash;</div><div class="line">		cash = CashFactory.create(&quot;normal&quot;);</div><div class="line">		System.out.println(cash.acceptCash(300));</div><div class="line">		cash = CashFactory.create(&quot;cashRebate&quot;);</div><div class="line">		System.out.println(cash.acceptCash(300));</div><div class="line">		cash = CashFactory.create(&quot;cashReturn&quot;);</div><div class="line">		System.out.println(cash.acceptCash(310));*/   此段代码用来跟简单工厂模式区别，最好的设计就是对依赖的类保持最少的了解</div><div class="line">		CashContext csuper = new CashContext(&quot;normal&quot;);</div><div class="line">		System.out.println(csuper.GetResult(300));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>简单工厂和策略模式的区别<br>工厂模式是创建型模式，策略模式是行为性模式；一个关注对象创建，一个关注行为的封装；<br>在下面的情况下应当考虑使用策略模式：</p>
<ol>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li>
<li>一个系统需要动态地在几种算法中选择一种。那么这些算法可以包装到一个个的具体算法类里面，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体<br>算法类均有统一的接口，由于多态性原则，客户端可以选择使用任何一个具体算法类，并只持有一个数据类型是抽象算法类的对象。</li>
<li>一个系统的算法使用的数据不可以让客户端知道。策略模式可以避免让客户端涉及到不必要接触到的复杂的和只与算法有关的数据。</li>
</ol>
</blockquote>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public abstract class Component &#123;</div><div class="line">	public abstract void Operation();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteComponent extends Component&#123;</div><div class="line">	@Override</div><div class="line">	public void Operation() &#123;</div><div class="line">		System.out.println(&quot;具体对象的操作&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteDecoratorA extends Decorator&#123;</div><div class="line">	private String addedState;</div><div class="line">	@Override</div><div class="line">	public void Operation() &#123;</div><div class="line">		super.Operation();</div><div class="line">		addedState = &quot;New State&quot;;</div><div class="line">		System.out.println(&quot;具体装饰对象A的操作&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteDecortorB extends Decorator&#123;</div><div class="line">	@Override</div><div class="line">	public void Operation() &#123;</div><div class="line">		super.Operation();</div><div class="line">		AddedBehavior();</div><div class="line">		System.out.println(&quot;具体装饰B对象的操作&quot;);</div><div class="line">	&#125;</div><div class="line">	private void AddedBehavior() &#123;</div><div class="line">		System.out.println(&quot;hello world！&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Decorator extends Component&#123;</div><div class="line">	protected Component component;</div><div class="line"></div><div class="line">	public Component getComponent() &#123;</div><div class="line">		return component;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setComponent(Component component) &#123;</div><div class="line">		this.component = component;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Operation() &#123;</div><div class="line">		if(component!=null)&#123;</div><div class="line">			component.Operation();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Component c = new ConcreteComponent();</div><div class="line">		Decorator d1 = new ConcreteDecoratorA();</div><div class="line">		Decorator d2 = new ConcreteDecortorB();</div><div class="line">		d1.setComponent(c);</div><div class="line">		d2.setComponent(d1);</div><div class="line">		d2.Operation();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">定义 抽象Manager类，经理，总监，总经理都继承 Manager</div><div class="line">public abstract class Manager &#123;</div><div class="line">	protected String name;</div><div class="line">	protected Manager superior;</div><div class="line">	public Manager(String name)&#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public void setSuperior(Manager superior)&#123;</div><div class="line">		this.superior = superior;</div><div class="line">	&#125;</div><div class="line">	abstract public void RequestApplication(Request request);</div><div class="line">&#125;</div><div class="line">//经理</div><div class="line">public class CommonManager extends Manager &#123;</div><div class="line">	public CommonManager(String name)&#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void RequestApplication(Request request) &#123;</div><div class="line">		if(request.requestType==&quot;jiaxin&quot; &amp;&amp; request.number&lt;100)&#123;</div><div class="line">			System.out.println(name + &quot; agree&quot;);</div><div class="line">		&#125;else&#123;</div><div class="line">			if(superior!=null)&#123;</div><div class="line">				superior.RequestApplication(request);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//总监</div><div class="line">public class Zongjian extends Manager&#123;</div><div class="line">	public Zongjian(String name) &#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void RequestApplication(Request request) &#123;</div><div class="line">		 if(request.requestType==&quot;jiaxin&quot; &amp;&amp; request.number&lt;500)&#123;</div><div class="line">			 System.out.println(name + &quot; agreen&quot;);</div><div class="line">		 &#125;else&#123;</div><div class="line">			 superior.RequestApplication(request);</div><div class="line">		 &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//总经理</div><div class="line">public class GeneralManager extends Manager&#123;</div><div class="line">	public GeneralManager(String name) &#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void RequestApplication(Request request) &#123;</div><div class="line">		 if(request.requestType==&quot;jiaxin&quot; &amp;&amp; request.number &lt; 2000)&#123;</div><div class="line">			 System.out.println(name + &quot; agree&quot;);</div><div class="line">		 &#125;else&#123;</div><div class="line">			 System.out.println(name + &quot; not agree&quot;);</div><div class="line">		 &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//Test代码</div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		CommonManager commonManager = new CommonManager(&quot;CommonManager&quot;);</div><div class="line">		Zongjian zongjian = new Zongjian(&quot;Zongjian&quot;);</div><div class="line">		GeneralManager generalManager = new GeneralManager(&quot;GeneralManager&quot;);</div><div class="line">		commonManager.setSuperior(zongjian);</div><div class="line">		zongjian.setSuperior(generalManager);</div><div class="line">		Request request = new Request();</div><div class="line">		request.setRequestType(&quot;jiaxin&quot;);</div><div class="line">		request.setNumber(500);</div><div class="line">		commonManager.RequestApplication(request);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出</div><div class="line">GeneralManager agree</div></pre></td></tr></table></figure>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">public abstract class Unitednations &#123;</div><div class="line">	public abstract void Declare(String message,Country college);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class Country &#123;</div><div class="line">	protected Unitednations mediator;</div><div class="line">	public Country(Unitednations mediator) &#123;</div><div class="line">		this.mediator = mediator;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class USA extends Country&#123;</div><div class="line">	public USA(Unitednations mediator) &#123;</div><div class="line">		super(mediator);</div><div class="line">	&#125;</div><div class="line">	public void Declare(String message)&#123;</div><div class="line">		mediator.Declare(message, this);</div><div class="line">	&#125;</div><div class="line">	public void GetMessage(String message)&#123;</div><div class="line">		System.out.println(&quot;USA gains message &quot;+message);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Iraq extends Country &#123;</div><div class="line">	public Iraq(Unitednations mediator) &#123;</div><div class="line">		super(mediator);</div><div class="line">	&#125;</div><div class="line">	public void Declare(String message)&#123;</div><div class="line">		mediator.Declare(message, this);</div><div class="line">	&#125;</div><div class="line">	public void GetMessage(String message)&#123;</div><div class="line">		System.out.println(&quot;Iraq gains message &quot;+message );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class UnitedNationSecurityCouncil extends Unitednations &#123;</div><div class="line">	private USA colleague1;</div><div class="line">	private Iraq colleague2;</div><div class="line">	public void setUSA(USA colleague)&#123;</div><div class="line">		this.colleague1 = colleague;</div><div class="line">	&#125;</div><div class="line">	public void setIraq(Iraq colleague)&#123;</div><div class="line">		this.colleague2 = colleague;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Declare(String message, Country college) &#123;</div><div class="line">		if(college == colleague1)&#123;</div><div class="line">			colleague2.GetMessage(message);</div><div class="line">		&#125;else&#123;</div><div class="line">			colleague1.GetMessage(message);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//测试代码</div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		UnitedNationSecurityCouncil UNSC = new UnitedNationSecurityCouncil();</div><div class="line">		USA c1 = new USA(UNSC);</div><div class="line">		Iraq c2 = new Iraq(UNSC);</div><div class="line">		UNSC.setUSA(c1);</div><div class="line">		UNSC.setIraq(c2);</div><div class="line">		c1.Declare(&quot;do not &quot;);</div><div class="line">		c2.Declare(&quot;do&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">输出</div><div class="line">Iraq gains message do not</div><div class="line">USA gains message do</div></pre></td></tr></table></figure>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">1. class Singleton&#123;</div><div class="line">	private static Singleton instance;</div><div class="line">	private static byte[] lock = new byte[1];</div><div class="line">	private Singleton&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public static Singleton getInstance()&#123;</div><div class="line">		if(instance == null)&#123;</div><div class="line">			synchronized(lock)&#123;</div><div class="line">				if(instance==null)&#123;</div><div class="line">					instance = new Singleton();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">2. class Singleton&#123;</div><div class="line">	private static Singleton instance;</div><div class="line">	private static ReentrantLock lock = new ReentrantLock();</div><div class="line">	private Singleton()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	public static Singleton getInstance()&#123;</div><div class="line">		if(instance == null)&#123;</div><div class="line">			lock.lock;</div><div class="line">			if(instance == null)&#123;</div><div class="line">				instance = new Singleton();</div><div class="line">			&#125;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">public abstract class Player &#123;</div><div class="line">	protected String name;</div><div class="line">	public Player(String name)&#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public abstract void Attack();</div><div class="line">	public abstract void Defense();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Forwards extends Player&#123;</div><div class="line">	public Forwards(String name) &#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Attack() &#123;</div><div class="line"></div><div class="line">		System.out.println(name + &quot; Attack&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Defense() &#123;</div><div class="line">		System.out.println(name + &quot; Defense&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Center extends Player &#123;</div><div class="line">	public Center(String name) &#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Attack() &#123;</div><div class="line">		System.out.println(name + &quot; Attack&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Defense() &#123;</div><div class="line">		System.out.println(name + &quot; Attack&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Guards extends Player&#123;</div><div class="line">	public Guards(String name) &#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Attack() &#123;</div><div class="line">		System.out.println(name + &quot; Attack&quot;);</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Defense() &#123;</div><div class="line">		System.out.println(name + &quot; Attack&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ForeighCenter &#123;</div><div class="line">	public String name;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public void attack()&#123;</div><div class="line">		System.out.println(name + &quot; attack&quot;);</div><div class="line">	&#125;</div><div class="line">	public void defense()&#123;</div><div class="line">		System.out.println(name + &quot; defense&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Translator extends Player &#123;</div><div class="line">	private ForeighCenter foreigh = new ForeighCenter();</div><div class="line">	public Translator(String name) &#123;</div><div class="line">		super(name);</div><div class="line">		foreigh.name = name;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Attack() &#123;</div><div class="line">		foreigh.attack();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Defense() &#123;</div><div class="line">		foreigh.defense();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Player b = new Forwards(&quot;巴蒂尔&quot;);</div><div class="line">		b.Attack();</div><div class="line">		Player m = new Center(&quot;麦克格雷迪&quot;);</div><div class="line">		m.Attack();</div><div class="line">		Player ym = new Translator(&quot;姚明&quot;);</div><div class="line">		ym.Attack();</div><div class="line">		ym.Defense();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">输出</div><div class="line">巴蒂尔 Attack</div><div class="line">麦克格雷迪 Attack</div><div class="line">姚明 attack</div><div class="line">姚明 defense</div></pre></td></tr></table></figure>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public abstract class Subject &#123;</div><div class="line">	private List&lt;ObserverObj&gt; observers = new ArrayList&lt;ObserverObj&gt;();</div><div class="line">	public void Attach(ObserverObj observer)&#123;</div><div class="line">		observers.add(observer);</div><div class="line">	&#125;</div><div class="line">	public void Detach(ObserverObj observer)&#123;</div><div class="line">		observers.remove(observer);</div><div class="line">	&#125;</div><div class="line">	public void Nofity()&#123;</div><div class="line">		for (ObserverObj o : observers) &#123;</div><div class="line">			o.Update();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public abstract class ObserverObj &#123;</div><div class="line">	public abstract void Update();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteSubject extends Subject&#123;</div><div class="line">	private String subjectState;</div><div class="line">	public String getSubjectState() &#123;</div><div class="line">		return subjectState;</div><div class="line">	&#125;</div><div class="line">	public void setSubjectState(String subjectState) &#123;</div><div class="line">		this.subjectState = subjectState;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class ConcreteObserver extends ObserverObj &#123;</div><div class="line">	private String name;</div><div class="line">	private String observerState;</div><div class="line">	private ConcreteSubject subject;</div><div class="line">	public ConcreteObserver(String name, ConcreteSubject subject) &#123;</div><div class="line">		this.name = name;</div><div class="line">		this.subject = subject;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void Update() &#123;</div><div class="line">		observerState = subject.getSubjectState();</div><div class="line">		System.out.println(name+&quot; state is &quot; + observerState);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ConcreteSubject s = new ConcreteSubject();</div><div class="line">		s.Attach(new ConcreteObserver(&quot;X&quot;, s));</div><div class="line">		s.Attach(new ConcreteObserver(&quot;Y&quot;, s));</div><div class="line">		s.Attach(new ConcreteObserver(&quot;Z&quot;, s));</div><div class="line">		s.setSubjectState(&quot;ABC&quot;);</div><div class="line">		s.Nofity();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h3><table>
<thead>
<tr>
<th>排序方法</th>
<th>平均情况</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlog(n))</td>
<td>O(n^1.3)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog(n))</td>
<td>O(nlog(n))</td>
<td>O(nlog(n))</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog(n))</td>
<td>O(nlog(n))</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog(n))</td>
<td>O(nlog(n))</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
</tbody>
</table>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>可维护 克服用法 可扩展 灵活型号<br>通过封装、继承、多态把程序的耦合性降低<br>类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类<br>单一职责原则(SRP)：就一个类而言，应该仅有一个引起它变化的原因<br>依赖倒置原则： 针对接口编程，不要针对实现编程<br>A.高层模块不应该依赖低层模块，两个都应该依赖抽象<br>B.抽象不应该依赖细节，细节应该依赖抽象<br>装饰模式： 动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。<br>代理模式： 为其他对象提供一种代理以控制对这个对象的访问。<br>代理类就是持有一个真实类的引用，调用实际类的方法。 代理类和实际类通过实现相同接口达到统一。<br>远程代理：也就是为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实。</p>
<p>简单工厂模式 VS 工厂方法模式 IFactory factory = new UndergraduateFactory();  LeiFeng student = factory.CreateLeiFeng();<br>外观模式(Facade): 为子系统的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>适配器模式(Adapter)将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>就是说，需要的东西就在眼前，却不能使用，而短时间又无法改造它，只能想办法适配。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[飞鸟集]]></title>
      <url>http://yoursite.com/2015/12/22/%E9%A3%9E%E9%B8%9F%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>001﻿</p>
<p>夏天的飞鸟落在我的窗前﻿</p>
<p>歌唱之后便匆匆离去﻿﻿</p>
<p>深秋的落叶寂静不语﻿</p>
<p>叹息之后便落在了那里﻿﻿</p>
<p>002﻿﻿</p>
<p>流浪在世界的人﻿</p>
<p>请将你们的足记留在我的文字里﻿﻿</p>
<p>003﻿﻿</p>
<p>面对爱人﻿</p>
<p>世界无比真诚﻿﻿</p>
<p>然后它变小了﻿</p>
<p>如诗歌﻿</p>
<p>如深吻﻿﻿</p>
<p>004﻿﻿</p>
<p>大地流下的泪﻿</p>
<p>让她的笑容一直美丽﻿﻿</p>
<p>005﻿﻿</p>
<p>荒漠向绿草求爱﻿</p>
<p>而激情澎湃﻿</p>
<p>可它笑着摇头﻿</p>
<p>飞走离开﻿﻿</p>
<p>006﻿﻿</p>
<p>失去太阳流下流泪﻿</p>
<p>也会错过满天繁星﻿﻿</p>
<p>007﻿﻿</p>
<p>跳舞的流水﻿</p>
<p>你路过的泥沙渴望着﻿</p>
<p>你的歌声，你的舞姿﻿</p>
<p>而你愿意去接受他们﻿</p>
<p>不能远行的牵绊吗？﻿﻿</p>
<p>008﻿﻿</p>
<p>她满脸渴望着﻿</p>
<p>如深夜的雨﻿</p>
<p>惊扰着我的梦﻿﻿</p>
<p>009﻿﻿</p>
<p>曾经梦里我们形同陌路﻿</p>
<p>醒来发现彼此爱的深沉﻿﻿</p>
<p>010﻿﻿</p>
<p>忧郁沉寂在心﻿</p>
<p>正如﻿</p>
<p>黄昏在寂静的树林﻿﻿</p>
<p>011﻿﻿</p>
<p>无形的手指﻿</p>
<p>如同自在的微风﻿</p>
<p>随着潺潺的乐声﻿</p>
<p>在我的心上调皮﻿﻿</p>
<p>012﻿﻿</p>
<p>—大海，你要说什么？﻿</p>
<p>—还是那个问题。﻿﻿</p>
<p>—天空，你的回答呢？﻿</p>
<p>—还是保持沉默。﻿﻿</p>
<p>013﻿﻿</p>
<p>听听我的心﻿</p>
<p>听听世界的低语﻿</p>
<p>听他把深爱诉说给你﻿﻿</p>
<p>014﻿﻿</p>
<p>创造如夜的黑暗﻿</p>
<p>—伟大神秘﻿﻿</p>
<p>而虚渺的认知﻿</p>
<p>如尘雾中的黎明﻿﻿</p>
<p>015﻿﻿</p>
<p>不要让你的爱太过高耸﻿</p>
<p>如无法触及的悬崖峭壁</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python笔记]]></title>
      <url>http://yoursite.com/2015/10/24/python%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>import Image<br>def test():<br>im = Image.open(‘D:\111.png’)<br>(w,h)= im.size<br>im.thumbnail((w//2,h//2))<br>im.save(‘D:\thumbnail.jpg’,’jpeg’)<br>if name == ‘main‘:<br>test()</p>
<p>round(1.15,2) ===&gt; 1.2<br>ord(‘a’) ===&gt; 97 #### 字母和数字相互转换<br>chr(65) ===&gt; ‘A’<br>divmod(15,6) ===&gt;(2,3)</p>
<p>‘-‘*40 ===&gt; ‘———————————————-’<br>‘an’ in ‘Django’ ===&gt;True<br>‘xyz’ not in ‘Django’ ===&gt; True<br>字符串拼接用 join “;”.join[‘list1’,’list2’]<br>列表扩充 list1.extend(list2)</p>
<p>u’ABC’.encode(‘utf-8’) ####把unicode转为utf-8<br>‘abc’.decode(‘utf-8’) ####把utf-8转为unicode</p>
<p>保存python文件时，保存为utf-8格式</p>
<p>！/usr/bin/env python</p>
<p>–coding:utf-8 –</p>
<p>List列表 =[‘jack’,’mike’]<br>list.append(‘marry’)<br>list[0] list[1] ####根据下标访问制定元素<br>list.insert(1,’Jack’) ####插入<br>list.pop() ####弹出最后一个元素<br>list.pop(1) ####弹出制定元素<br>list[1]=’Sarah’ ####赋值<br>list 列表 =[‘jack’,’mike’,’marry’]<br>s = [‘python’,’java’,list,’scheme’] ####list元素也可以是另一个list<br>这样如果要取mike的值， s[2][1]</p>
<p>在序列中循环时，索引位置和对应值可以使用enumerate()函数同时得到<br>for i,v in enumerate([‘tic’,’tac’,’tom’]):<br>print i,v<br>同时循环两个或更多序列，可以使用zip()整体打包<br>questions = [‘name’,’quesst’,’favorite’]<br>answers = [‘lance’,’the’,’only’]<br>for q,a in zip(questions,answers):<br>print ‘what is your {0}?it is {1}’.format(q,a)<br>pass 语句</p>
<p>def fib(n):<br>result = []<br>a,b = 0,1<br>while a &lt; n:<br>result.append(b)<br>a,b = b,a+b<br>return result #### 返回一个包含数列的链表<br>f100 = fib(100)</p>
<p>tuple 元组的值不能变，更安全<br>tuple 当只有一个元素的时候定义： t=(1,)<br>当 tuple 中包含list时候，list的值是可以变化的<br>eg: t=(‘a’,’b’,[‘A’,’B’])<br>t[2][0]=’x’ t[2][1]=’y’</p>
<p>循环 for 语句<br>names = [‘mike’,’marry’,’java’]<br>for name in names:<br>print name<br>for x in [1,2,3,4,5]:<br>sum = sum+x<br>range(5) ===&gt; 0,1,2,3,4<br>1到100的和：<br>for x in range(101):<br>sum = sum+x</p>
<p>birth = raw_input(‘birth:’)</p>
<p>dict 和 set<br>d ={‘mick’:98,’Bob’:93,’marry’:88}<br>d[‘mick’]<br>d[‘mick’] = 90<br>d.pop(‘Bob’)</p>
<p>重复元素在 set 中自动被过滤<br>s = set([1,1,2,2,3,3])<br>s ===&gt; set([1,2,3])<br>s.add(4)<br>s.remove(4)<br>a = set(‘abc’) b = set(‘deab’)<br>a - b<br>a | b<br>a ^ b<br>a &amp; b</p>
<p>list 内容可变 比如： a = [‘c’,’b’,’a’]<br>a.sort() a===&gt; [‘a’,’b’,’c’] #### 值改变<br>tuple　内容不可变　比如：a = ‘abc’<br>b = a.replace(‘a’,’A’) b===&gt;’Abc’ a===&gt;’abc’ ####值不变</p>
<p>import math<br>def move(x, y, step, angle=0):<br>nx = x + step <em> math.cos(angle)<br>ny = y - step </em> math.sin(angle)<br>return nx, ny ####返回多个值，实质是返回一个tuple<br>x,y = move(100,100,60,math.pi/6)<br>print x,y</p>
<p>def add_end(L=None):<br>if L is None:<br>L = []<br>L.append(‘END’)<br>return L #### 默认参数必须指向不变对象</p>
<p>def calc(<em>numbers):<br>sum = 0<br>for n in numbers:<br>sum = sum + n </em> n<br>return sum #### 把函数参数变为可变参数</p>
<p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。<br>而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict</p>
<p>在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数<br><em>args是可变参数，args接收的是一个tuple<br>*</em>kw是关键字参数，kw接收的是一个dict</p>
<p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，<br>每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。<br>由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出<br>解决递归调用栈溢出的方法是通过尾递归优化</p>
<p>切片特性：<br>L=[‘mick’,’java’,’marry’,’hello’]<br>L[:3] L[-3:]<br>L = range(100)<br>L[:10:2] ####到10为止，步长为2<br>eg: ‘ABCDEFG’[::2]</p>
<p>Python的for循环抽象程度要高于Java的for循环<br>因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上</p>
<p>如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断<br>from collections import Iterable<br>isinstance(‘abc’, Iterable) ####str是否可迭代<br>True<br>isinstance([1,2,3], Iterable) #### list是否可迭代<br>True<br>isinstance(123, Iterable) #### 整数是否可迭代<br>False</p>
<p>Python内置的enumerate函数可以把一个list变成索引-元素对<br>这样就可以在for循环中同时迭代索引和元素本身<br>for i, value in enumerate([‘A’, ‘B’, ‘C’]):<br>print i, value</p>
<p>列表生成式 ：<br>[x<em>x for x in range(1,11) if x % 2]<br>[m + n for m in ‘ABC’ for n in ‘XYZ’]<br>squares = map(lambda x:x*</em>2,range(10))<br>[(x,y) for x in [1,2,3] for y in [2,3,1] if x != y]</p>
<p>列出当前目录下的所有文件和目录名<br>import os #### 导入os模块，模块的概念后面讲到<br>[d for d in os.listdir(‘.’)] #### os.listdir可以列出文件和目录</p>
<p>for循环其实可以同时使用两个甚至多个变量，比如dict的iteritems()可以同时迭代key和value<br>d = {‘x’:’A’,’y’:’B’,’z’:’C’}<br>for k,v in d.iteritems(): #### 或者[k+’=’+v for k,v in d.iteritems()]<br>print k,’=’,v<br>L = [‘Hello’,’World’,’IBM’,’Apple’]<br>[s.lower() for s in L]<br>isinstance(x, str) ####判断是否字符串</p>
<p>生成器：<br>g = (x * x for x in range(10))</p>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言<br>变量可以指向函数<br>如 f = abs<br>def add(x,y,f):<br>return f(x)+f(y)</p>
<p>Python 内建了 map() 和 reduce() 函数 函数式编程工具 filter(),map(),reduce()<br>map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回<br>educe把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，<br>reduce把结果继续和序列的下一个元素做累积计算，其效果就是： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</p>
<p>str 类型转化成 int 类型：<br>def fn(x, y):<br>return x <em> 10 + y<br>def char2num(s):<br>return {‘0’: 0, ‘1’: 1, ‘2’: 2, ‘3’: 3, ‘4’: 4, ‘5’: 5, ‘6’: 6, ‘7’: 7, ‘8’: 8, ‘9’: 9}[s]<br>reduce(fn, map(char2num, ‘13579’))<br>13579<br>def str2int(s):<br>return reduce(lambda x,y: x</em>10+y, map(char2num, s)) ####编写str–&gt;int 函数</p>
<p>和map()类似，filter()也接收一个函数和一个序列。和 map()不同的时，filter()把传入的函数依次作用于每个元素<br>eg:<br>def is_odd(n):<br>return n % 2 == 1<br>filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]) ==&gt;1,5,9,15</p>
<p>def not_empty(s):<br>return s and s.strip()<br>filter(not_empty, [‘A’, ”, ‘B’, None, ‘C’, ’ ‘])</p>
<p>[‘A’, ‘B’, ‘C’]</p>
<p>seq = range(8)<br>def add(x,y):<br>return x+y<br>map(add,seq,seq)<br>reduce(add,ra nge(1,11))</p>
<p>sorted([12,32,39,45])<br>sorted()函数也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序<br>eg： sorted([12,34,24,54],reversed_sort)<br>def reversed_sort(x,y):<br>if x &gt;y :<br>return -1<br>if x &lt; y:<br>return 1<br>return 0</p>
<p>sorted([‘bob’,’about’,’zo’,’bac’],cmp_ignore_cast)</p>
<p>字典：<br>cleese = {} 或者 palin = dict() 都可以创建字典，第二个属于工厂模式</p>
<p>默认字典排序<br>def cmp_ignore_case(s1,s2):<br>u1 = s1.upper()<br>u2 = s2.upper()<br>if u1 &lt; u2:<br>return -1<br>if u1 &gt; u2:<br>return 1<br>return 0;</p>
<p>在函数调用前后自动打印日志，但又不希望修改now()函数的定义，</p>
<p>这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p>
<p>字典： tel = {‘jack’:3089,’merry’:2309}<br>tel[‘jack’]<br>del tel[‘jack’]<br>tel.keys()<br>‘jack’ in tel</p>
<p>偏函数就是把某些参数固定<br>import functools<br>int2 = functools.partial(int,base = 2)</p>
<p>面向对象编程——Object Oriented Programming，简称OOP<br>“测试驱动开发”（TDD：Test-Driven Development）</p>
<p>我5分钟后到，如果没到，请再读一遍此短信…</p>
<p>os.path.abspath(‘.’)<br>‘D:\green\python’ ####得到当前目录</p>
<p>对文件重命名:</p>
<p>os.rename(‘test.txt’, ‘test.py’) </p>
<h4 id="删掉文件"><a href="#删掉文件" class="headerlink" title="删掉文件:"></a>删掉文件:</h4><p>os.remove(‘test.py’)</p>
<p>os.path.splitext()可以直接让你得到文件扩展名</p>
<p>os.path.splitext(‘/path/to/file.txt’)<br>(‘/path/to/file’, ‘.txt’)</p>
<p>把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名</p>
<p>os.path.split(‘/Users/michael/testdir/file.txt’)<br>(‘/Users/michael/testdir’, ‘file.txt’)</p>
<p>在某个目录下创建一个新目录，</p>
<p>首先把新目录的完整路径表示出来:</p>
<p>os.path.join(‘/Users/michael’, ‘testdir’)<br>‘/Users/michael/testdir’</p>
<p>然后创建一个目录:</p>
<p>os.mkdir(‘/Users/michael/testdir’)</p>
<p>删掉一个目录:</p>
<p>os.rmdir(‘/Users/michael/testdir’)</p>
<p>序列化：</p>
<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>
<p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>
<p>区别在于cPickle是C语言写的，速度快</p>
<p>pickle是纯Python写的，速度慢，跟cStringIO和StringIO一个道理</p>
<p>先尝试导入cPickle，如果失败，再导入pickle：</p>
<p>try:<br>import cPickle as pickle<br>except ImportError:<br>import pickle<br>d = dict(name = ‘Bob’,age = 20,score = 80)<br>f = open(‘dump.txt’,’wb’)</p>
<p>pickle.dump(d,f) 直接把对象序列化后写入一个file-like Object</p>
<p>pickle.dump(d,f)<br>f.close()</p>
<p>把任意对象序列化成一个str，然后可以把这个str写入文件</p>
<p>pickle.dumps(d)</p>
<p>import pickle<br>with open(‘mydata.pick1’,’wb’) as mysave: #### 以二进制文件打开写入<br>pickle.dump([1,2,’three’],mysave)<br>with open(‘mydata.pick1’,’rb’) as myread: #### 以二进制文件打开读取<br>a_list = pickle.load(myread) #### 腌制数据出现问题PickleError</p>
<p>with open(‘man.pick1’,’wb’) as mysave:<br>pickle.dump(man,mysave) </p>
<p>####包含写入内容和文件名<br>except IOError as err:<br>print(‘File error’+str(err))</p>
<p>with open(‘www.txt’,’rb’) as mysave:<br>data = mysave.readline()<br>dd = data.strip().split(‘,’) ####去除字符串的空格，且以“，”分割，存入列表中</p>
<p>list.sort() 改变列表<br>sorted(list) 不改变列表</p>
<p>强烈建议使用Python的r前缀，就不用考虑转义<br>s = r’ABC-001’ 、</p>
<p>对应的正则表达式字符串不变：</p>
<p>‘ABC-001’</p>
<p>正则表达式切分</p>
<p>如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。</p>
<p>re.split(r’\s+’, ‘a b c’)<br>[‘a’, ‘b’, ‘c’]<br>re.split(r’[\s,]+’, ‘a,b, c d’)<br>[‘a’, ‘b’, ‘c’, ‘d’]<br>re.split(r’[\s,\;]+’, ‘a,b;; c d’)<br>[‘a’, ‘b’, ‘c’, ‘d’]<br>分组<br>m = re.match(r’^(\d{3})-(\d{3,8})$’, ‘010-12345’)<br>-&gt; m </p>
<p><_sre.sre_match object="" at="" 0x1026fb3e8=""><br>-&gt; m.group(0)<br>‘010-12345’<br>-&gt; m.group(1)<br>‘010’<br>-&gt; m.group(2)<br>‘12345’</_sre.sre_match></p>
<p>正则表达式默认采用贪婪匹配</p>
<p>eg: re.match(r’^(\d+)(0*)′,‘102300′).groups()===&gt;(‘102300′,”)贪婪匹配re.match(r′(\d+?)(0∗)’, ‘102300’).groups() ===&gt; (‘1023’, ‘00’) ####非贪婪匹配</p>
<p>正则表达式编译优化：</p>
<p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式</p>
<p>import re</p>
<p>编译:</p>
<p>-&gt; re_telephone = re.compile(r’^(\d{3})-(\d{3,8})$’)</p>
<p>使用：</p>
<p>-&gt; re_telephone.match(‘010-12345’).groups()<br>(‘010’, ‘12345’)<br>-&gt; re_telephone.match(‘010-8086’).groups()<br>(‘010’, ‘8086’)<br>re_telephone.match(‘010-8086’).group(i) #### group(1)取得第一个</p>
<p>内建模块：<br>collections ==&gt; namedtuple deque OrderedDict<br>namedtuple 一个点的二维坐标<br>from collections import namedtuple<br>-&gt; Point = namedtuple(‘Point’, [‘x’, ‘y’])<br>-&gt; p = Point(1, 2)<br>-&gt; p.x<br>1</p>
<p>isinstance(p, Point)<br>Circle = namedtuple(‘Circle’, [‘x’, ‘y’, ‘r’])</p>
<p>deque<br>deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈</p>
<p>from collections import deque ####要用到collection.deque<br>-&gt; q = deque([‘a’, ‘b’, ‘c’])<br>-&gt; q.append(‘x’)<br>-&gt; q.appendleft(‘y’)<br>-&gt; q<br>deque([‘y’, ‘a’, ‘b’, ‘c’, ‘x’])<br>deque除了实现list的append()和pop()外，还支持appendleft()和popleft()<br>这样就可以非常高效地往头部添加或删除元素。</p>
<p>OrderedDict 在对dict做迭代时，我们无法确定Key的顺序。<br>如果要保持Key的顺序，可以用OrderedDict<br>od = OrderedDict()<br>-&gt; od[‘z’] = 1<br>-&gt; od[‘y’] = 2<br>-&gt; od[‘x’] = 3<br>-&gt; od.keys() #### 按照插入的Key的顺序返回<br>[‘z’, ‘y’, ‘x’]</p>
<p>hashlib</p>
<p>摘要算法之所以能指出数据是否被篡改过，就是因为摘要函数是一个单向函数</p>
<p>计算f(data)很容易，但通过digest反推data却非常困难</p>
<p>import hashlib<br>md5 = hashlib.md5()<br>md5.update(‘how to use’) ####多次调用md5.update()<br>md5.update(’ python’)<br>a = md5.hexdigest()</p>
<p>md5 = hashlib.md5()<br>md5.update(‘how to use python’) ####单次调用md5.update()<br>b = md5.hexdigest()<br>print a == b #### 计算出md5的值<br>from math import pi<br>[str(round(pi,i)) for i in range(1,6)]</p>
<p>sha1 用法类似于md5<br>与 C++ 语言不通，python中没有定义构造函数new的概念。python会为你完成对象构建<br>然后你可以使用init()方法定制对象的初始状态<br>目标标识符赋值至self参数</p>
<p>好的web应用应当遵循 模型-试图-控制器(Model-View-Controller) 模式</p>
<p>eg:交换变量<br>x = 6<br>y = 7<br>x, y = y,x</p>
<p>eg:if语句在行内<br>print ‘hello’ if True else ‘world’<br>eg:连接<br>print str(1) + ‘world’<br>eg:两个列表同时迭代<br>nfc = [‘packet’,’hello’]<br>afc = [‘River’,’world’]<br>for teama,teamb in zip(nfc,afc):<br>print teama,teamb<br>eg:索引迭代<br>for index,team in enumerate(nfc):<br>print index,team<br>eg:筛选出偶数：<br>even=[num for num in nums if num % 2 == 0]<br>eg:字典推导：<br>teams = [‘packet’,’www’,’river’]<br>print {key:value for value,key in enumerate(teams)}<br>{‘www’:1,’river’:2,’packet’:0}<br>eg:将列表转换成字符串：<br>print “,”.join(teams)<br>eg:从字典中获取元素：<br>data = {‘user’:1,’name’:2,’three’:4}<br>print data.get(‘user’,False)<br>eg:<br>若是3的倍数则打印”Fizz”替换3的倍数，5的倍数打印”Buzz”,既是3的倍数又是5的倍数打印”FizzBuzz”<br>for x in range(101):<br>print ‘Fizz’[x%3<em>4:] + ‘Buzz’[x%5</em>4:] or x</p>
<p>eg：统计次数 Counter库<br>from collections import Counter<br>print Counter(‘hello’)<br>-&gt;Counter({‘l’:2,’h’:1,’e’:1,’o’:1})<br>select top(3) with ties * from tablename order by name desc</p>
<p>遍历目录方法：<br>import os<br>fileList = []<br>rootdir = “/data”<br>for root, subFolders, files in os.walk(rootdir):<br>if ‘.svn’ in subFolders: subFolders.remove(‘.svn’)<br>for file in files:<br>if file.find(“.t2t”) != -1:#### 查找特定扩展名的文件<br>file_dir_path = os.path.join(root,file)<br>fileList.append(file_dir_path)<br>print fileList<br>print “;”.join(fileList)</p>
<p>列表按列排序<br>a = [(‘2011-03-17’, ‘2.26’, 6429600, ‘0.0’), (‘2011-03-16’, ‘2.26’, 12036900, ‘-3.0’),<br>(‘2011-03-15’, ‘2.33’, 15615500,’-19.1’)]<br>-&gt; print a[0][0]<br>2011-03-17<br>-&gt; b = sorted(a, key=lambda result: result[1],reverse=True) //第二列排序<br>-&gt; print b<br>[(‘2011-03-15’, ‘2.33’, 15615500, ‘-19.1’), (‘2011-03-17’, ‘2.26’, 6429600, ‘0.0’),<br>(‘2011-03-16’, ‘2.26’, 12036900, ‘-3.0’)]<br>-&gt; c = sorted(a, key=lambda result: result[2],reverse=True) //同理，第三列排序</p>
<p>列表去重(list uniq)<br>-&gt; lst= [(1,’sss’),(2,’fsdf’),(1,’sss’),(3,’fd’)] //列表里面是元组<br>-&gt; set(lst)<br>set([(2, ‘fsdf’), (3, ‘fd’), (1, ‘sss’)])<br>-&gt; lst = [1, 1, 3, 4, 4, 5, 6, 7, 6] //列表里面是基本类型<br>-&gt; set(lst)<br>set([1, 3, 4, 5, 6, 7])</p>
<p>字典,列表,字符串互转<br>字典转化为字符串<br>-&gt; params = {“server”:”mpilgrim”, “database”:”master”, “uid”:”sa”, “pwd”:”secret”}<br>-&gt; [“%s=%s” % (k, v) for k, v in params.items()]<br>[‘server=mpilgrim’, ‘uid=sa’, ‘database=master’, ‘pwd=secret’]<br>-&gt; “;”.join([“%s=%s” % (k, v) for k, v in params.items()])<br>‘server=mpilgrim;uid=sa;database=master;pwd=secret’</p>
<p>字符串转化为字典<br>-&gt; a = ‘server=mpilgrim;uid=sa;database=master;pwd=secret’<br>-&gt; aa = {}<br>-&gt; for i in a.split(‘;’):aa[i.split(‘=’,1)[0]] = i.split(‘=’,1)[1]<br>-&gt; aa<br>{‘pwd’: ‘secret’, ‘database’: ‘master’, ‘uid’: ‘sa’, ‘server’: ‘mpilgrim’}</p>
<p>Python调用系统命令或者脚本<br>使用 os.system() 调用系统命令 , 程序中无法获得到输出和返回值<br>-&gt; import os<br>-&gt; os.system(‘ls -l /proc/cpuinfo’)<br>-&gt; os.system(“ls -l /proc/cpuinfo”)<br>-r–r–r– 1 root root 0 3月 29 16:53 /proc/cpuinfo<br>使用 os.popen() 调用系统命令, 程序中可以获得命令输出，但是不能得到执行的返回值<br>-&gt; out = os.popen(“ls -l /proc/cpuinfo”)<br>-&gt; print out.read()<br>-r–r–r– 1 root root 0 3月 29 16:59 /proc/cpuinfo<br>使用 commands.getstatusoutput() 调用系统命令, 程序中可以获得命令输出和执行的返回值<br>-&gt; import commands<br>-&gt; commands.getstatusoutput(‘ls /bin/ls’)<br>(0, ‘/bin/ls’)<br>Python读写文件<br>一次性读入文件到列表，速度较快，适用文件比较小的情况下<br>track_file = “track_stock.conf”<br>fd = open(track_file)<br>content_list = fd.readlines()<br>fd.close()<br>for line in content_list:<br>print line<br>逐行读入，速度较慢,适用没有足够内存读取整个文件(文件太大)<br>fd = open(file_path)<br>fd.seek(0)<br>title = fd.readline()<br>keyword = fd.readline()<br>uuid = fd.readline()<br>fd.close()</p>
<p>写文件 write 与 writelines 的区别<br>Fd.write(str) : 把str写到文件中，write()并不会在str后加上一个换行符<br>Fd.writelines(content) : 把content的内容全部写到文件中,原样写入，不会在每行后面加上任何东西</p>
<p>import math<br>dir(math) 列出math模块包含的函数<br>dir(builtins)列出python内置函数<br>查询字符串都包含哪些函数 dir(”)<br>print(math.tanh.doc) 打印模块函数的说明文档<br>将整数和字符串转换为浮点数 float(3) float(‘3.3’)<br>将整数和浮点数转换为字符串 str(88) str(9.7)<br>字符串转换为整数 int(‘5’)<br>全局变量 局部变量<br>在函数里面改变全局变量，需要先 global name 声明当前引用的是全局变量</p>
<p>默认值：<br>def great(name,greeting = ‘hello’)<br>关键字参数<br>def shop(where = ‘store’,what = ‘pasta’,howmuch=’10 pounds’)<br>shop() shop(what = ‘towels’) shop(howmuch = ‘a ton’,what = ‘towels’,where = ‘bakery’)</p>
<p>模块 引入模块后，import shapes 使用 dir(shapes) 来列出其中的函数</p>
<p>返回文件名的扩展名：<br>dot = fname.rfind(‘.’)<br>if dot == -1:<br>return ”<br>else:<br>return fname[dot+1:]</p>
<p>字符串函数<br>ss.find(‘ee’)<br>ss.rfind(‘.’) 从右往左搜索<br>ss.index(‘ee’)<br>ss.rindex(‘ee’)<br>设置格式的函数：<br>‘{0} like {1}’.format(‘Jack’,’Ice Cream’) ==&gt;’Jack like Ice Cream’<br>‘{who} {pet} has fleas’.format(pet=’dog’,who=’my’) ==&gt; ‘my dog has fleas’</p>
<p>strip函数<br>s.strip(ch) 从s开头和末尾删除在ch中出现的字符<br>s.lstrip(ch) 从左侧<br>s.rstrip(ch) 从右侧<br>name.lstrip()<br>name.strip(‘_- ‘)</p>
<p>拆分函数：<br>s.partition(t) 将s拆分成3个字符串，head,t,tail<br>s.rpartition(t)<br>url = ‘www.google.com’<br>url.partition(‘.’)<br>(‘www’, ‘.’, ‘google.com’)<br>url.rpartition(‘.’)<br>(‘www.google’, ‘.’, ‘com’)</p>
<p>s.split() 以t为分隔符，将s划分为一系列字符串，并返回由这些字符串组成的列表。<br>s.rsplit()<br>s.splitlines()<br>url.split(‘.’)<br>[‘www’, ‘google’, ‘com’]<br>ss = ‘a long time ago, princess ate an apple’<br>ss.split </p>
<p>ss.split()<br>[‘a’, ‘long’, ‘time’, ‘ago,’, ‘princess’, ‘ate’, ‘an’, ‘apple’]</p>
<p>替换函数：<br>s = ‘up,up and away’<br>s.replace(‘up’,’down’)<br>s.replace(old,new) 将S中的每个old替换为new<br>s.expandtabs(n) 将 s中的每个制表符号替换为n个空格</p>
<p>正则表达式<br>def is_done(s):<br>return re.match(‘done|quit’,s)!=None<br>re.match(regex,s)不匹配时返回None，否则返回一个特殊的正则表达式匹配对象</p>
<p>列表函数：<br>s.append(x)<br>s.count(x)<br>s.extend(lst)<br>s.insert(i,x)<br>s.pop(i)<br>s.remove(x)<br>s.reverse() 就地反转<br>s.sort() 就地排序<br>还可以为包含元组的列表进行排序，自然排序<br>pst = [(1,2),(1,-1),(2,5),(4,1)]<br>pst.sort()</p>
<p>使用列表解析<br>cap_name = [n.capitalize() for n in name]<br>使用列表解析进行筛选<br>result = [n for n in nums if n &gt; 0]</p>
<p>字典中键是唯一的，否则会产生覆盖</p>
<p>字典函数：<br>d.items()<br>d.keys()<br>d.values()<br>d.get(key) 获取key对应的value<br>d.pop(key) 删除键key并返回与之相关联的值<br>d.clear()<br>d.copy() d = dict.copy()<br>d.fromkeys(s,t)<br>d.setdefault(key,v) 如果键包含在字典中，则返回其值；否则返回V并将(key,v)添加到字典中<br>d.update(e) 将e中的键值对添加到字典中，e可能是字典，也可能是键值对序列</p>
<p>设置字符串格式：<br>print(‘value %.2f’ % x) 如果要在字符串中包含%,必须使用%%。<br>格式化字符串<br>‘My {pet} has {prob}’.format(pet=’dog’,prob=’fleas’)<br>‘My{0} has {1}’.format(‘dog’,’fleas’)<br>‘1/81={x}’.format(x=1/81)<br>‘1/81={x:.3f}’.format(x=1/81)</p>
<p>os.getcwd() 返回当前目录<br>os.lilstdir(p) 返回一个字符串列表，其中包括p指定的文件夹中所有的文件和文件夹的名称<br>os.chdir(p) 将当前工作目录设置为p<br>os.path.isfile(p) 当p指向一个文件名称是，返回True<br>os.path.isdir(p) 目录时，返回True<br>os.stat(fname) 返回有关fname的信息，如大小和最后一次修改时间</p>
<p>若提示找不到模块 sys.path.append() 将包含py文件的路径加入到path中即可<br>若提示找不到函数 则 使用 模块.函数的方式执行函数<br>调用f.read()之后，文件指针指向文件末尾，通过调用f.seek(0),让文件指针重新指向了文件开头，这样写入f时，从开头开始。</p>
<p>若输入年龄不符合要求一直循环，符合要求则返回<br>def getAge():<br>while True:<br>try:<br>n = int(raw_input(‘how old are you’))<br>return n<br>except ValueError:<br>print(‘please input an integer’)<br>if name == ‘main‘:<br>getAge()</p>
<p>注意int()讲一个书转化为整数 int(‘12’,16) –&gt; 18 意思是把16进制的12转换为10进制的数字</p>
<p>把字符串中单词的出现频次转化为字典####3</p>
<p>keep = {‘a’,’b’,’c’,’d’,”,’-‘,”’”}<br>def normalize(s):<br>result = ”<br>for c in s.lower():<br>if c in keep:<br>result += c<br>return result</p>
<p>def make_dict(s):<br>s = normalize(s)<br>words = s.split()<br>d = {}<br>for w in words:<br>if w in d:<br>d[w] += 1<br>else:<br>d[w] = 1<br>return d</p>
<p>计算字典的value的和<br>num = sum(d[w] for w in d)</p>
<p>s.swapcase() #####大小写变换<br>s.upper() s.lower()<br>s.capitalize() #####句首大写<br>s.title() #####首字母大写<br>print s1.ljust(20)<br>print s1.rjust(20,’t’) #####以t填充<br>print s1.center(20,’*’)</p>
<p>s1.find(‘of’) #####返回第一次出现的位置<br>s1.find(‘of’,6,len(s1))</p>
<p>print s1.rfind(‘of’)<br>print rindex(‘of’)<br>print s1.count(‘of’)<br>print s1.replace(‘of’,’new’)</p>
<p>print s1.strip() #####去除字符串前后空格<br>print s1.lstrip()<br>print s1.rstrip()</p>
<p>s1.split() ##### 把字符串分开存到列表中<br>print s1.split()[2] ##### 访问列表中下标为2的项<br>s1.splitlines() #####把一行作为列表中的一个元素</p>
<p>list = [‘mick’,’jerry’,’hello’]<br>print ‘+’.join(list)</p>
<p>print s2.startswith(’ ‘) ##### 以某些字符开始<br>print s2.endswith(’ ‘) ##### 以某些字符结束</p>
<p>help(‘sys’) #####查看sys模块内置函数<br>s4.isalnum() ##### 检查字符串是否由字母和数字组成<br>s4.isalpha() #####检查字符串是否只由字母组成<br>s4.isdigit() #####检查字符串是否只由数字组成<br>s4.isapace()<br>s4.isupper()<br>s4.islower()</p>
<p>list 不能直接赋值，可以通过列表元素赋值<br>eg: list[1:3]=[22,34]</p>
<p>n = [(‘tom’,12,170),(‘jerry’,11,180)]<br>for name,age,high in n:<br>print ‘name is:’,name</p>
<p>for i in ‘happy’:<br>list1.append(ord(i))<br>print list1 &lt;===&gt; list1 = [ord(x) for x in ‘happy’]</p>
<p>tt = [x*y for x in range(10) for y in range(10)]<br>str1 = [x+y for x in ‘happy’ for y in ‘good’]<br>tuple1 = [(x,y) for x in range(4) for y in range(3)]</p>
<p>访问字典：<br>print ‘the is %(a)s,%(b)s’ % {‘a’:123,’b’:456}<br>d.clear() #####删除全部元素<br>del d[‘a’] #####根据键删除相应值</p>
<p>三种方法：<br>for k in d:<br>print ‘d[%s]=’%k,d[k] ##### 访问字典的键值<br>for(k,v) in d.items():<br>print ‘d[%s]=’%k,v ##### 访问字典的键值<br>for (k,v) in zip(d.iterkeys(),d.itervalues()):<br>print ‘d[%s]=’%k,v ##### 访问字典的键值</p>
<p>复杂的字典</p>
<p>dict2 = {‘a’:’aa’,’b’:(‘apple’,’orange’),’c’:{‘d’:’dd’,’f’:’ff’}}<br>里面嵌套元组，字典<br>print dict2[‘c’][‘d’]<br>print dict2[‘b’][0]</p>
<p>dict.keys()<br>dict.values()<br>dict.get(‘a’) #####根据键得到值<br>dict2.get(‘f’,’exitst’) ##### 不存在则返回’exitst’</p>
<p>dict1 = {‘a’:’bpp’,’b’:’cpp’,’c’:’app’}<br>print sorted(dict1.items(),key = lambda d:d[0]) ##### 以键排序<br>print sorted(dict1.items(),key = lambda d:d[1]) ##### 以值排序</p>
<p>import copy<br>dict2 = {‘a’:123,’b’:456}<br>dict3 = copy.deepcopy(dict2) ##### dict3改变不改变dict2的值<br>dict4 = copy.copy(dict2) ##### dict4改变会改变dict2的值</p>
<p>import os<br>os.getcwd() ##### 当前工作目录<br>os.chdir(‘../python’) ##### 改变工作目录</p>
<p>data = open(‘sketch.txt’)<br>print(data.readline(),end = ’ ‘)<br>data.seek(0) ##### 使用seek方法返回到文件起始位置<br>data.close()</p>
<p>print x, 在变量后面加逗号可以使得print不换行</p>
<p>help(s.split) 查询split()的用法，或者help–&gt;python DOCS</p>
<p>import os<br>if os.path.exitst(‘www.txt’)</p>
<p>out = open(‘data.out’,’w’)<br>print (‘Norwegian Blues ‘,file = out)<br>out.close() ##### 刷新输出</p>
<p>w模式会清除已有内容<br>a模式不清除已有内容，追加文件<br>w+ 读写，不清除<br>若文件不存在，则创建，再进行读写</p>
<p>import os<br>def test():<br>man= []<br>other = []<br>try:<br>data = open(‘www.txt’)<br>for each_line in data:<br>try:<br>(role,line) = each_line.split(‘:’,1)<br>line = line.strip()<br>if role == ‘man’:<br>man.append(line)<br>else:<br>other.append(line)<br>except ValueError:<br>pass<br>data.close()<br>except IOError as err2:<br>print (‘{0}’.format(err2))<br>try:<br>man_file = open(‘man_data.txt’,’w’)<br>other_file = open(‘other_data.txt’,’w’) </p>
<h5 id="print-man-file-man-file"><a href="#print-man-file-man-file" class="headerlink" title="print(man,file=man_file)"></a>print(man,file=man_file)</h5><h5 id="print-other-file-other-file"><a href="#print-other-file-other-file" class="headerlink" title="print(other,file=other_file)"></a>print(other,file=other_file)</h5><p>man_file.writelines(‘%s’% x for x in man)<br>other_file.writelines(‘%s’ % y for y in other)<br>except IOError as err:<br>print(‘File open error{0}’ % str(err))<br>finally:<br>man_file.close()<br>other_file.close()<br>if name == ‘main‘:<br>print(os.getcwd())<br>test()</p>
<p>with语句利用了一种名为上下文管理协议的python技术<br>try:<br>with open(‘its.txt’,’w’) as data:<br>print (‘it\’s ..’,file = data)<br>except IOError as err:<br>print (‘file error’+str(err))</p>
<p>except IOError as err2:<br>print(‘error’+str(err2))<br>print(‘error{0}’.format(err2))</p>
<p>def santi(time_string):<br>if ‘:’ in time_string:<br>sep = ‘:’<br>elif ‘-’ in time_string:<br>sep = ‘-’<br>else:<br>return time_string<br>(mins,seconds) = time_string.split(sep)<br>return mins+’.’+seconds<br>def test():<br>data = [‘2.13’,’2:38’,’2-23’]<br>list = [santi(ti) for ti in data]<br>list.sort()<br>print list ##### 对不规则数据进行统一变换</p>
<p>sorted(list2,reverse=True) ##### 逆序排列<br>sorted(set(list2),reverse = True)[2:7] ##### 去除重复数据，逆序排列，取2-7个数据</p>
<p>类：<br>def santi(time_string):<br>if ‘:’ in time_string:<br>sep = ‘:’<br>elif ‘-’ in time_string:<br>sep = ‘-’<br>else:<br>return time_string<br>(mins,seconds) = time_string.split(sep)<br>return mins+’,’+seconds<br>def get_coach_data(filename):<br>try:<br>with open(filename) as f:<br>data = f.readline()<br>temp = data.strip().split(‘,’)<br>return Athlete(temp.pop(0),temp.pop(0),temp)<br>except IOError as ioerr:<br>print (‘File error:’+str(ioerr))<br>class Athlete:<br>def init(self,a_name,a_dob=None,a_time=[]):<br>self.name = a_name<br>self.dob = a_dob<br>self.times = a_time<br>def top3(self):<br>return (sorted(set([santi(t) for t in self.times]))[0:3])<br>if name == ‘main‘:<br>james = get_coach_data(‘james.txt’)<br>print(james.name+“‘s fastest times are:”+str(james.top3()))</p>
<p>.pyc 文件的内容是平台独立的，所以 Python 模块目录可以在不同架构的机器之间共享。</p>
<p>import sys<br>sys.path.append(‘utf/guido/lib/python’)</p>
<p>内置函数 dir() 用于按模块名搜索模块定义，返回一个字符串类型的存储列表</p>
<p>对齐方式，rjust(n) n位右对齐，同理 ljust(n)</p>
<p>print str(x).rjust(4),repr(x<em>x).rjust(4),repr(x</em>x*x).rjust(4)</p>
<p>str.zfill(6) 向字符串左侧添加0<br>eg ‘12’.zfill(5) ===&gt; ‘00012’</p>
<p>str.format() 用法</p>
<p>print ‘{0} and {1}’ . format(‘spam’ , ‘eggs’ )</p>
<p>JPEG 或 EXE 这样的二进制文件，在操作这些文件时一定要记得以二进制模式打开</p>
<p>import os<br>os.getcwd() ##### 返回当前工作目录</p>
<p>os.chdir(‘../xx’) ##### 改变当前工作目录<br>os.system(‘mkdir today’) ##### 执行命令</p>
<p>应该用 import os 风格而非 from os import * 。这样可以保证随操作系统不</p>
<p>同而有所变化的 os.open() 不会覆盖内置函数 open()</p>
<p>针对日常的文件和目录管理任务， shutil 模块提供了一个易于使用的高级接口</p>
<p>-&gt; import shutil<br>-&gt; shutil. copyfile(‘data.db’ , ‘archive.db’ )<br>-&gt; shutil. move(‘/build/executables’ , ‘installdir’ )</p>
<p>glob 模块提供了一个函数用于从目录通配符搜索中生成文件列表</p>
<p>import glob<br>-&gt; glob. glob(‘*.py’ )<br>[‘primes.py’, ‘random.py’, ‘quote.py’]</p>
<p>在命令行中执行</p>
<p>python demo.py one two three 后可以得到以下输出结果<br>-&gt; import sys<br>-&gt; print sys. argv<br>[‘demo.py’, ‘one’, ‘two’, ‘three’]</p>
<p>import re<br>re. findall(r’ \bf[a-z]*’ , ‘which foot or hand fell fastest’ )<br>[‘foot’, ‘fell’, ‘fastest’]<br>re. sub(r’(\b[a-z]+) \1’ , r’ \1’ , ‘cat in the the hat’ )<br>‘cat in the hat’</p>
<p>相对于 timeit 的细粒度， profile 和 pstats 模块提供了针对更大代码块的时间度量工具。</p>
<p>使用元组封装和拆封来交换元素看起来要比使用传统的方法要诱人的多</p>
<p>def f(a,L= []):<br>L.append(a)<br>return L<br>print f(1)<br>print f(2)<br>print f(3) #####会累积</p>
<p>python fibo.py 50<br>if name ==’main‘:<br>import sys<br>fib(int(sys.argv[1]))</p>
<p>以同样的方式，可以使用<strong>操作符分拆关键字参数为字典<br>def parrot(voltage,state=’a stiff’,action=’voom’):<br>print ‘this parrot’,action,<br>print ‘if you put’,voltage,’hello’,<br>print ‘eswe would’,state<br>d={‘voltage’:’four mill’,’state’:’Blues’,’action’:’acc’}<br>parrot(</strong>d)</p>
<p>python文件操作：<br>chmod+x hello.py 为文件添加执行权限 ./hello.py<br>文件读取方式<br>read([size) 读取size个字节<br>readline([size]) 读取一行<br>readlines([sizes]) 读取完文件（受buffer大小限制），返回每一行组成的列表；一定要读完的话可以用迭代器<br>文件写入方式<br>write(str) 将字符串写入文件<br>writelines(sequence_of_string) 写多行到文件</p>
<p>mode:<br>r 只读方式，文件必须存在<br>w 只写方式，文件不存在则创建；存在则清空文件内容<br>a 追加方式，文件不存在则创建<br>r+/w+ 读写方式打开<br>a+ 追加和读写方式打开</p>
<p>type(f) 查看f属性 help(file) 查看file所有方法 help(f.tell) 查看f的tell方法<br>f. tab 补齐命令 查看f可以使用哪些命令<br>vim yy -》 1000p 产生足够大的数据量<br>f = open(‘imooc.txt’)<br>itedr_f = iter(f) //使用迭代器对文件进行操作，不消耗大量内存的情况下对文件进行遍历<br>lines = 0<br>for line in iter_f:<br>lines += 1<br>python写磁盘时机：<br>1.主动调用close()或者flush方法，写缓存同步到磁盘 f.close() f.flush()<br>2.写入数据量大于或者等于写缓存，写缓存同步到磁盘<br>eg:<br>f = open(‘yuchuan.txt’,’w’)<br>for i in range(10000):<br>f.writelines(‘test write’ + str(i) + ‘\n’)<br>此时调到后台执行<br>vim yuchuan.txt<br>f.close()<br>vim yuchuan.txt</p>
<p>python文件为什么要关闭：<br>1.将写缓存同步到磁盘<br>2.linux系统中每个进程打开文件的个数是有限的<br>3.如果打开文件数到了系统限制，在打开文件就会失败</p>
<p>linux下，ps得到PID之后， cat /proc/20384(PID) 列出该进程详细信息<br>for i in range(1025):<br>list_f.append(open(‘imooc.txt’,’w’))<br>print “%d:%d” % (i,list_f[i].fileno()) //提示打开文件过多<br>Seek<br>os.SEEK_SET 相对文件起始位置<br>os.SEEK_CUR 相对文件当前位置<br>os.SEEK_END 相对文件结尾位置</p>
<p>f.read(3) 读入三个字节<br>f.tell() 返回当前相对于文件头的偏移位置<br>f.seek(0.os.SEEK_SET) 返回文件头<br>f.seek(0,os.SEEK_END) 返回文件尾<br>f.seek(-5,os.SEEK_CUR) 从当前位置前5个开始读取</p>
<p>python标准文件：<br>标准输入： sys.stdin<br>标准输出：sys.stdout<br>标准错误：sys.stderr</p>
<p>sys模块提供sys.argv属性，通过该属性可以得到命令行参数； sys.argv:字符串组成的列表</p>
<p>f.encoding //查看文件编码<br>import codec<br>//创建指定编码格式文件<br>f = codec.open(‘test.txt’,’w’,’utf-8’,errors,buffering)</p>
<p>使用os模块对文件进行操作<br>os.read(fd,buffersize)<br>os.write(fd,string)<br>os.lseek(fd,pos,how) 文件指针操作<br>os.close(fd)</p>
<p>fd = os.open(‘imooc.txt’,os.O_CREAT | os.O_RDWR)<br>n = os.write(fd,’imooc’)<br>l = os.lseek(fd,0,os.SEEK_SET)<br>str1 = os.read(fd,5)<br>os.close(fd)<br>OS模块常用方法介绍：<br>access(path,mode) 判断该文件权限 eg: os.access(‘imooc.txt’,os.F_OK) os.R_OK os.W_OK os.X_OR<br>listdir(path) 返回当前目录下所有文件组成的列表 eg: os.listdir(‘./’)<br>remove(path) eg: os.remove(‘imooc.txt’)<br>rename(old,new) eg: os.rename(‘test/’,’test1’)<br>mkdir(path[,mode]) 创建目录 eg:<br>mkdirs(path[,mode]) 创建多级目录<br>removedirs(path)<br>rmdir(path)</p>
<p>os.path 模块方法介绍：<br>exists(path) 当前路径是否存在<br>isdir(s) 是否是一个目录<br>isfile(path) 是否是一个文件<br>getsize(filename) 返回文件大小<br>dirname(p) 返回路径的目录<br>basename(p) 返回路径的文件名</p>
<p>练习<br>import ConfigParser<br>cfg = ConfigParser.ConfigParser()<br>help(cfg.read)<br>cfg.read(‘study.txt’)<br>help(cfg.sections)<br>cfg.sections()<br>help(cfg.items)<br>for se in cfg.sections():<br>print se<br>print cfg.items(se)<br>cfg.set(‘userinfo’,’email’,’user@163.com’)<br>cfg.set(‘userinfo’,’pwd’,’123456’)<br>cfg.remove_option(‘userinfo’,’email’)</p>
<p>Case:<br>import os<br>import os.path<br>import ConfigParser<br>”’<br>dump ini<br>del section<br>del item<br>modify item<br>add section<br>save modify<br>”’<br>class student_info(object):<br>def init(self,recordfile):<br>self.logfile = recordfile<br>self.cfg = ConfigParser.ConfigParser()<br>def cfg_load(self):<br>self.cfg.read(self.logfile)<br>def cfg_dump(self):<br>se_list = self.cfg.sections()<br>print “—-&gt;”<br>for se in se_list:<br>print se<br>print self.cfg.items(se)<br>print “&lt;—-”<br>def delete_item(self,section,key):<br>self.cfg.remove_option(section,key)<br>def delete_section(self,section):<br>self.cfg.remove_section(section)<br>def add_section(self,section):<br>self.cfg.add_section(section)<br>def set_item(self,section,key,value):<br>self.cfg.set(section,key,value)<br>def save(self):<br>fp = open(logfile,’w’)<br>self.cfg.write(fp)<br>fp.close()<br>if name ==’main‘:<br>info = student_info(‘study.txt’)<br>info.cfg_load()<br>info.cfg_dump()<br>info.set_item(‘userinfo’,’pwd’,’123456’)<br>info.cfg_dump()<br>info.add_section(‘login’)<br>info.set_item(‘login’,’2015-7-14’,’20’)<br>info.cfg_dump()<br>info.save()</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[虚拟实验]]></title>
      <url>http://yoursite.com/2015/10/24/%E8%99%9A%E6%8B%9F%E5%AE%9E%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>《基于HLA的自行高炮CGG的研究与设计》<br>随着计算机网络技术和军事需求的不断提高，作战模拟逐步由单机环境转向网络环境，分布交互式作战仿真成为研究的重点，各种支撑技术相继出台，最具代表性和发展潜力的是基于高层体系结构(High Level Architecture，HLA)框架下构建的作战仿真系统。<br>它通过一定的协议把分布在模拟器中的个体联入同一个虚拟战场环境中实现综合仿真。通过对人类作战行为足够的建模，这些实体能不需要人为的交互而自动地对仿真战场环境中的事件和状态做出反应。它不仅具有构建各种不同类型和功能的高炮的重用能力，更重要的是通过给定不同的初始化数据可快速重构出高炮作战训练所需要的具有不同层次的指挥决策能力和战术行为的仿真智能高炮。<br>仿真对象模型(Simulation Object Model，SOM)</p>
<h2 id="HLA主要由规则-Rules-、对象模型模板-OMT，Object-Model-Template-和接口规范-Interface-Specification-3部分组成。在HLA中将仿真应用与底层的通信和分布仿真基本功能相分离，由运行时间框架-Run-Time-Infrastructure，RTI-提供的服务来实现底层的通信和基本功能，即在一个联邦的执行过程中，所有的联邦成员按照HLA的接口规范说明所要求的方式同RTI进行数据交换，实现成员间的互操作。"><a href="#HLA主要由规则-Rules-、对象模型模板-OMT，Object-Model-Template-和接口规范-Interface-Specification-3部分组成。在HLA中将仿真应用与底层的通信和分布仿真基本功能相分离，由运行时间框架-Run-Time-Infrastructure，RTI-提供的服务来实现底层的通信和基本功能，即在一个联邦的执行过程中，所有的联邦成员按照HLA的接口规范说明所要求的方式同RTI进行数据交换，实现成员间的互操作。" class="headerlink" title="HLA主要由规则(Rules)、对象模型模板(OMT，Object Model Template)和接口规范(Interface Specification)3部分组成。在HLA中将仿真应用与底层的通信和分布仿真基本功能相分离，由运行时间框架(Run Time Infrastructure，RTI)提供的服务来实现底层的通信和基本功能，即在一个联邦的执行过程中，所有的联邦成员按照HLA的接口规范说明所要求的方式同RTI进行数据交换，实现成员间的互操作。"></a>HLA主要由规则(Rules)、对象模型模板(OMT，Object Model Template)和接口规范(Interface Specification)3部分组成。在HLA中将仿真应用与底层的通信和分布仿真基本功能相分离，由运行时间框架(Run Time Infrastructure，RTI)提供的服务来实现底层的通信和基本功能，即在一个联邦的执行过程中，所有的联邦成员按照HLA的接口规范说明所要求的方式同RTI进行数据交换，实现成员间的互操作。</h2><p>HLA规则<br>RTI规范 按照HLA的接口协议进行开发，提供了一系列用于仿真互联的服务，是HLA仿真系统进行分层管理控制、实现分布仿真可扩充性的基础。<br>TENA 试验与训练时能体系结构，迫切需要一种能克服当前靶场烟囱式设计，能实现靶场资源之间的互操作、重用和可组合的机制，TENA由此产生。一个逻辑靶场行将分布在许多设施中的试验、训练、仿真、高性能的计算技术继承起来，采用公共的体系结构将他们连接在一起互操作。在一个逻辑靶场中，真实的军事装备及其他模拟的武器和兵力之间能彼此交互，无论在什么地方。TENA最重要的技术驱动需求是可互操作、重用和可组合。<br>可互操作是某个独自开发的组件、应用或系统能与其他的元素朝着某个共同目标一起工作的特性，对于TENA来说，最重要的互操作就是语义互操作，他是一种建立在有公共语言和通信上下文组成的基础之上的互操作。重用是在某种不同于某个给定的组件，应用或系统原始设计的上下文下使用它的能力，关注多次使用。可组合是指可重用、可互操作的元素能组成一个集合的特性。</p>
<h2 id="IDL接口定义语言是不同程序和语言的粘合剂，基于IDL丰富的数据类型集和定义值对象的能力，使用互联网内部对象请求代理协议（Internet-Inter-ORB-Protocol）作为从IDL接口和数据类型到线路上的流数据的形式化映射。使用IIOP和生成IDL的能力使得新模型可以无缝集成到CORBA基础设施中。使用远程方法激活（Remote-Method-Invocation-RMI）接口联合Java和CORBA。"><a href="#IDL接口定义语言是不同程序和语言的粘合剂，基于IDL丰富的数据类型集和定义值对象的能力，使用互联网内部对象请求代理协议（Internet-Inter-ORB-Protocol）作为从IDL接口和数据类型到线路上的流数据的形式化映射。使用IIOP和生成IDL的能力使得新模型可以无缝集成到CORBA基础设施中。使用远程方法激活（Remote-Method-Invocation-RMI）接口联合Java和CORBA。" class="headerlink" title="IDL接口定义语言是不同程序和语言的粘合剂，基于IDL丰富的数据类型集和定义值对象的能力，使用互联网内部对象请求代理协议（Internet Inter-ORB Protocol）作为从IDL接口和数据类型到线路上的流数据的形式化映射。使用IIOP和生成IDL的能力使得新模型可以无缝集成到CORBA基础设施中。使用远程方法激活（Remote Method Invocation,RMI）接口联合Java和CORBA。"></a>IDL接口定义语言是不同程序和语言的粘合剂，基于IDL丰富的数据类型集和定义值对象的能力，使用互联网内部对象请求代理协议（Internet Inter-ORB Protocol）作为从IDL接口和数据类型到线路上的流数据的形式化映射。使用IIOP和生成IDL的能力使得新模型可以无缝集成到CORBA基础设施中。使用远程方法激活（Remote Method Invocation,RMI）接口联合Java和CORBA。</h2><p>《复杂信息系统网络脆弱性分析与仿真验证技术研究》<br>从复杂网络拓扑结构和行为脆弱性分析技术、关键协议脆弱性分析技术以及仿真验证三方面展开研究<br>提出了基于复杂网络理论的静态和动态结合的分析方法。静态脆弱性研究使用度、介数、紧密度、聚集系数、熵等参数进行仿真计算和比较，动态级联故障研究中，使用容量-负载模型对示例网在不同攻击策略下的级联故障过程进行仿真分析。</p>
<p>设计实现了一个基于网络靶场技术的脆弱性仿真验证平台，归纳并提出了面向网络脆弱性分析的通用网络靶场架构，设计了一套满足网络靶场可控性安全性要求的控制系统方案，以及基于灰色聚类方法的CTR能力成熟度量化评估模型。</p>
<p>基于XML-RPC组件间通信技术</p>
<h2 id="XML-RPC-XML-Remote-Procedure-Call-XML远程方法调用，是基于XML格式的跨平台RPC技术-一个XML-RPC消息就是一个用XML描述的http-post-请求，通过XML标签描述过程调用的参数和返回结果，为连接不同系统，不同设备发布的可读信息提供了简单实用的应用层协议，实现系统不同部分的集成。"><a href="#XML-RPC-XML-Remote-Procedure-Call-XML远程方法调用，是基于XML格式的跨平台RPC技术-一个XML-RPC消息就是一个用XML描述的http-post-请求，通过XML标签描述过程调用的参数和返回结果，为连接不同系统，不同设备发布的可读信息提供了简单实用的应用层协议，实现系统不同部分的集成。" class="headerlink" title="XML-RPC(XML Remote Procedure Call)XML远程方法调用，是基于XML格式的跨平台RPC技术,一个XML-RPC消息就是一个用XML描述的http-post 请求，通过XML标签描述过程调用的参数和返回结果，为连接不同系统，不同设备发布的可读信息提供了简单实用的应用层协议，实现系统不同部分的集成。"></a>XML-RPC(XML Remote Procedure Call)XML远程方法调用，是基于XML格式的跨平台RPC技术,一个XML-RPC消息就是一个用XML描述的http-post 请求，通过XML标签描述过程调用的参数和返回结果，为连接不同系统，不同设备发布的可读信息提供了简单实用的应用层协议，实现系统不同部分的集成。</h2><p>《工控设备的安全保密风险评估》<br>工控系统与办公系统不同，系统中使用智能设备、嵌入式操作系统和各种专用协议、尤其是智能设备具有集成度高、行业性强、内核不对外开放、数据交互接口无法进行技术管控等。<br>工控系统的安全风险评估方法、标准还在不断探索中，本文介绍工控设备安全保密风险评估模型和评估流程</p>
<hr>
<p>《工控网中的安全应用》<br>工控安全目标：通讯可控  区域隔离   报警追踪<br>入侵检测部署：<br>1.实时性。实时入侵检测可以避免常规情况下，管理员对系统日志进行审计以辨别入侵行为时的低效和延迟。<br>2.可扩展性<br>3.事件记录</p>
<h2 id="网络控制及应用层控制，可有效防止内部终端访问网络时被植入病毒，也可防止内部用户将资料传播给非法组织。"><a href="#网络控制及应用层控制，可有效防止内部终端访问网络时被植入病毒，也可防止内部用户将资料传播给非法组织。" class="headerlink" title="网络控制及应用层控制，可有效防止内部终端访问网络时被植入病毒，也可防止内部用户将资料传播给非法组织。"></a>网络控制及应用层控制，可有效防止内部终端访问网络时被植入病毒，也可防止内部用户将资料传播给非法组织。</h2><p>重点《工业控制系统脆弱性分析与建模研究》<br>使得ICS安全面临严重威胁的因素：1）此阿勇带有已知脆弱性的标准化协议和技术<br>2）控制系统与其他网络的连接 3）不安全和无认证的访问 4） 控制系统缺乏安全技术等<br>攻击树和攻击图<br>把攻击图中边的权值抽象成攻击者网络组建需要付出的服用，攻击者可以通过统计网络组件获得收益，攻击者的目标就是将攻击过程中必须付出的费用最小，同时获取收益最大化</p>
<p>网络攻击建模可以理解为，通过使用数学的方法来描述整个网络的拓扑结构、组件信息、网络连接、攻击者的知识能力和最终目的等</p>
<p>信息系统一般提取出一下网络要素：<br>1）主机要素<br>2）网络连接要素<br>3）网络服务要素<br>4）用户权限要素</p>
<hr>
<p>赛博靶场六个方面的任务：<br>1.典型的网络环境中对信息保障能力和信息生存工具进行定量、定性评估<br>2.对目前和未来的武器系统，与作战行动中复杂的大规模异构网络和用户进行逼真模拟<br>3.在同一基础设施上，同时进行多项独立实验<br>4.实现针对因特网、全球信息栅格等大规模网络的逼真测试<br>5.开发具有创新性的网络测试能力并部署相应的工具和设备<br>6.通过科学方法对各种网络进行全方位严格测试</p>
<hr>
<p>高级持续性威胁（ Advanced Persistent Threat，简称 APT）<br>针对 PLC 的进行编程控制和诊断通常通过下位机软件（即常见的 WINCC、 Unity Pro）来实现，下位机软件存在的<br>安全漏洞将直接导致 PLC 产生安全风险，特定的可编程逻辑控制器（如西门子6ES7-417 、 6ES7-315-2）也面临诸如拒绝服务等风险 。<br>数据采集与监视控制系统（ Supervisory Control And Data Acquisition ，简写为SCADA），国内也称之为组态监控软件</p>
<p>人机界面（ Human Machine Interface，简称 HMI）<br>因此考虑工业控制系统安全时， 除了重视其核心系统组件的安全属性外，也要了解并重视其网络环境的安全相关属性的影响，如网<br>络开放程度、网络结构、协议安全性等。</p>
<p>工业控制网络与传统网络区别<br>体系架构（ICS系统由PLC、RTU、SCADA等工控设备系统各组成）<br>操作系统（广泛使用VxWorks、uClinux、Wince等）<br>数据交换协议（OPC、Modbus、DNP3）<br>实时性要求高</p>
<p>专有通信协议、规约在设计时通常只强调通信的实时性及可用性，对安全性普遍考虑不足：比如缺少足够强度的认证、加密、<br>授权等</p>
<p>分析任何协议时，区分安全问题的种类是非常有用的：一类是协议自身的设计和描述引起的，另一类是协议的不正确实现引起的<br>本文将与工控协议相关的安全问题分为两类：一类是工控协议自身特点所造成的固有安全问题；另一类是演化到基于通用计算机、通用操作系统和TCP/IP后继承的安全问题。</p>
<p>利用现场无线网络或企业办公网进行渗透攻击</p>
<h2 id="绿盟科技发布工控漏洞扫描系统ICSScan"><a href="#绿盟科技发布工控漏洞扫描系统ICSScan" class="headerlink" title="绿盟科技发布工控漏洞扫描系统ICSScan"></a>绿盟科技发布工控漏洞扫描系统ICSScan</h2><p>航天靶场的测量数据库的建设和应用涉及用户在数据录入、处理、管理、交换中的各项活动，统一的标准数据存取接口，是满足数据采集和数据集成应用要求的前提。数据接口技术中采用XML技术，以数据库为存贮手段，以XML为交换载体的数据管理模式。</p>
<p>基于支持向量机的故障诊断<br>马尔科夫链<br>入侵检测</p>
<p>IEEE1394是IEEE标准化组织制定的一项具有视频数据传输速度的串行接口标准<br>现有的产品1394协议支持100Mbps、200Mbps、400mbps的数据传输率，将来将达到800Mbps、1600Mbps、3200mbps的数据传输率。<br>因为1394能够处理高速数据传输率，它促使外设向计算机传输更多的数据</p>
<p>1394a FireWire 400             视频采集卡<br>1394b FireWire 800<br>1394和USB这类串行总线和PCI这类并行总线不一样，1394和USB这类总线，两个设备之间如果必须经过第三个设备，那么数据必须也从第三个设备穿过，也就是说第三个设备也要参与传输. 而PCI这类并行总线，就象一条大马路铺到各家的门口，两个设备如果商量好传输数据，并申请到了总线，就可以直接在两个设备间传输，不用经过第三家. 当然更本质的区别是，1394是串行的，而PCI是并行的.<br>USB与IEEE1394的区别在于USB是一一种主从式架构,IEEE1394则为对等架构</p>
<h2 id="相对于模拟视频接口，1394技术在采集和回录过程中没有任何信号的损失，正是由于这个优势，1394更多地是被人们当做视频采集卡来使用"><a href="#相对于模拟视频接口，1394技术在采集和回录过程中没有任何信号的损失，正是由于这个优势，1394更多地是被人们当做视频采集卡来使用" class="headerlink" title="相对于模拟视频接口，1394技术在采集和回录过程中没有任何信号的损失，正是由于这个优势，1394更多地是被人们当做视频采集卡来使用 "></a>相对于模拟视频接口，1394技术在采集和回录过程中没有任何信号的损失，正是由于这个优势，1394更多地是被人们当做视频采集卡来使用 </h2><p>【1394特点】<br>多媒体应用的实时数据传输<br>现在数据传输率为100，200，&amp;400Mbits/s；将来达到800Mbits/s或Gbits/s<br>实时连接或断开时数据不丢失或中断<br>支持即插即用自动配置<br>实时应用的宽带宽<br>不同设备和应用的通用连接<br>遵循IEEE1394高性能串行总线标准</p>
<p>networkworldweixin<br>目前数控系统正朝着开放式、网络化及智能化等方向发展[3-5]，数控总线作为工业通信网络的一种[用于连接数控系统装置间数字式、双向、多<br>点的通信，其采用了同步和异步两种通信机制，在<br>这两种机制下如何保证消息的安全通信是本文研究<br>重点。<br>总线满足周期性、实时性、同步性、可靠性及安全性等要求。</p>
<p>安全现场总线技术是在现有标准总线的基础上发展起来的具有安全总线协议的新型的安全控制系统技术。安全现场总线能够确保在应用中有很高级别的完整性、包括报文冗余，交叉核对，确保安全信息能够在预定时间内，可靠的从一个设备传输到另一个设备，并能保证数据内容的完整性。</p>
<p>现在90％以上的车用CAN总线来实现控制用的通信。已经发现CAN总线有  高错帧漏检  和  长的等效离线与真正离线的   机制性隐患，本文对这2种隐患的发生概率及其后果作了进一步分析，漏检的错帧可能最多是原数据的33倍或1／33，等效离线造成的失效概率在误码率为10-5时可达到16．8／h(总线利用率40％，速率500 kbps、平均帧长100位)。如先发生错帧漏检，应用收下错帧，又发生离线，阻断正确帧的改正作用，应用将长时间工作于错误状态下，是十分危险的。</p>
<p>作为车辆控制设备间的信息传递，当前的车辆中主要是CAN总线，CAN总线帧的丢失、错帧漏检、送达次序的错误、超过时限等带来的风险均应定量地分析。   [<a href="http://www.21ic.com/app/auto/201304/179767_2.htm" target="_blank" rel="external">http://www.21ic.com/app/auto/201304/179767_2.htm</a>]</p>
<h2 id="http-www-baidu-com-s-wd"><a href="#http-www-baidu-com-s-wd" class="headerlink" title="http://www.baidu.com/s?wd="></a><a href="http://www.baidu.com/s?wd=" target="_blank" rel="external">http://www.baidu.com/s?wd=</a></h2><p>AFDX 航空总线仿真测试  –&gt; AFDX 网络测试系统实例 –&gt; 航空电子系统仿真测试<br>测试分为两个阶段 : 独立的端系统测试和交换式以太网中的端系统测试<br>AFDX 测试系统应当具备 : 1) 网络流量产生功能 ; 2) 网络流量监控功能 ; 3) 网络流量接收功能 。<br>流量生成器必须实现一个健壮的调度器以便能有序的发送多个虚拟链路帧 。<br>流量产生器能对网络延迟进行测试 。要实现这个功能 , 就必须在发送数据时在帧有效负载中加上精确的时间戳 。接收这个帧的端系统可以通过该时间戳来确定这个帧在网络传输上所消耗的时间 。流量产生器应该能在 UDP 层加入时间戳 ,并据此计算出数据通过整个软件层的时间开销 。对比一个新系统和旧系统之间的性能差异 ,这种测试非常有价值 。</p>
<h2 id="AIM-公司的-API-FDX-2-双端口仿真测试板卡被用来对基于-AFDX-的网络系统进行仿真、监控和注入协议错误-。"><a href="#AIM-公司的-API-FDX-2-双端口仿真测试板卡被用来对基于-AFDX-的网络系统进行仿真、监控和注入协议错误-。" class="headerlink" title="AIM 公司的 API -FDX -2 双端口仿真测试板卡被用来对基于 AFDX 的网络系统进行仿真、监控和注入协议错误 。"></a>AIM 公司的 API -FDX -2 双端口仿真测试板卡被用来对基于 AFDX 的网络系统进行仿真、监控和注入协议错误 。</h2><p>机载1394总线的应用需求和实现<br>1394总线通信模式分为异步通信和等时通信。异步通信寻址和等时通信寻址<br>机载网络应用一般包含如下需求：</p>
<ul>
<li>网络的同步机制、网络的拓扑结构、各节点状态、消息通信量、网络容错机制、</li>
<li>消息错误处理机制、网络管理机制、支持多播组播和广播、节点的物理形式、供电功耗、元器件的国产化情况<br>为实现同步功能，设定了一种特殊的包–STOF包，STOF消息传输时STOF包中的字4,5将填充当前的RTC值。RN收到正确的STOF消息时，将收到的RTC值与自身的RTC值做差，用于修正自身的RTC，从而实现网络的全局同步。<br>容错： a.使用冗余的CC分支 b.设置备份CC，在CC失效后，由RN接管CC工作，管理网络</li>
</ul>
<p>Petri网作为一种建模工具，适用于描述系统中的并发、同步、冲突及顺序关系。随机Petri网适用于对连续或离散事件复杂系统进行建模，而且可利用与其同构的马尔科夫链对系统进行性能和可靠性分析。采用随机Petri网对漏洞进行形式化的建模和分析。<br>Petri–&gt;马尔科夫链的转换<br>WireShark 网络包分析软件，截获网络数据包<br>sysinternal工具包，用于监视程序和操作系统之间所有文件系统级通信的File Mon,监控所有活动TCP和UDP网络连接的TCPView，用于监控系统中所有进程执行的套接字发送和接受操作的TDI Mon,用于监控所有并行和串行物理端口通信的Port Mon等。<br>漏洞验证工具<br>免费扫描工具 Nessus</p>
<p>常见的特征码分为广谱特征码、关键区位码和跳转便宜多区段特征码三种类型<br>PDF是概率密度（函数）<br>CDF是（累积）分布函数</p>
<p>故障树分析（FTA）是一种自顶向下识别系统故障的方法。贝尔实验室提出，民兵导弹计划中的一部分。故障树是对FMEA方法很好的补充。他们都需要采用推理方法来找出问题所在。故障树非常适合找出造成问题的多个故障，且有助于发现一次分析一种类型的故障。故障树有助于发现系统的哪一部分与特定的故障相关。<br>网络建模–&gt; 网络建模   定量网络评估<br>马尔科夫模型评估平局故障时间、可靠度<br>可靠性与安全性模型的构建—</p>
<p>2.6 Linux内核有用日志记录事件的能力，比如记录系统调用和文件访问。然后，管理员可以评审这些日志，确定可能存在的安全裂口，比如失败的登录尝试，或者用户对系统文件不成功的访问。这种功能称为Linux审计系统</p>
<hr>
<p>NetMAX-LTE<br>随着移动通讯市场竞争的持续加剧，如何降低用户离网率，有效提升用户感知，继而提高用户APRU值成为在网络运维阶段新<br>课题。传统的网络优化手段如DT/CQT，关注的仅仅是点，线，无法评估全网用户的感知情况，尤其是占全网60%以上的室内用户的业务情况。且随着车辆，燃油，人工成本的持续增加，DT/CQT的成本也呈逐年上升态势。而基于KPI指标的网络优化关注的是网元的指标和性能，亦无法真实反映网络用户的感知情况，运营商普遍面临的问题是网络KPI指标在改善的同时，用户满意度却在逐年下降，离网用户持续增加, 指标与用户感知不一致、问题终端多，用户投诉处理慢、一些工程问题缺少排查手段等等。为切实解决运营商在维护优化中碰到的上述问题，中兴通讯投入大量前后台系统研发以及网络优化工具研发的力量，开发出以用户感知为基础的ZTE UniPOS NETMAX智能网优解决方案。<br>　　ZTE UniPOS NetMAX，作为网优专家系统，基于MR/CDT数据的无线网络分析及优化方法，其数据来源于用户的所有呼叫话单以及小区、UE上报的测量结果，可以形象的称之为“全民路测”，其贴近用户感知、数据量大、统计全面、准确，数据获取方便、能够及时发现网络问题并对单一用户进行分析等特点，因而对网络质量的评估结果更加全面、准确。<br>    NetMAX产品覆盖LTE/GSM/UMTS/TDS-CDMA多制式。用于快速定位现网问题，大大提升优化分析效率，如TOP处理，VIP用户<br>保障、投诉处理分析等；应用于用户感知度分析；网络评估分析报告。同时为后续的产品定制提供便利条件。</p>
<p>[MR]测量<br>是TD-LTE系统的一项重要功能。物理层上报的测量结果可以用于系统中无线资源控制子层完成诸如小区选择重选及切换等<br>事件的触发，也可以用于系统操作维护，观察系统的运行状态。网络设备应具有测量所规定测量报告数据的能力。测量方式采用周期测量时，可在测量任务定制时对上报周期进行配置。对一个测量，报告触发方式可以是事件触发或周期性触发。如果是周期性触发，需要配置上报周期；如果是事件触发，则利用网络已开启的事件测量，不需另外开启测量</p>
<p>信任边界与攻击面– </p>
<p>STRIDE是几个词的首字母缩写，代表 假冒（Spoofing）、篡改（Tampering）、否认（Repudiation）、信息暴露（Information Disclosure）、拒绝服务（Denial of Service）、权限提升（Elevation of Privilege）</p>
<p>建模工具<br>Threat Modeler<br>Little-JIL<br>Corporate Threat Modeler</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[paper小记]]></title>
      <url>http://yoursite.com/2015/10/18/paper%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>基于Xen的虚拟机实例之间的通信以及共享数据的交换<br>宿主操作系统  客户操作系统<br>虚拟机监控器的作用就是提供一种抽象，使得多个虚拟实例运行在一个硬件平台上。</p>
<p>“国家网络靶场”项目源于2008年1月8日由美国总统布什签署的“国家网络安全综合计划”<br>该靶场的建设目标是，模拟真实的网络攻防作战提供虚拟环境，针对敌对电子攻击和网络攻击等电子作战手段进行试验，以实现网络战能力的重大变革，打赢网络战争。</p>
<p>大规模异构系统（节点），并可快速集成新加节点。<br>用于论证的高质量数据采集、分析与演示。<br>快速生成与集成新设备复件的能力。<br>集成最新标准与协议的能力。<br>攻击软件工具集。<br>战术网络：可能包括移动自组织分组无线网络（adhoc）</p>
<p>VMI：即VirtualMachineIntrospection,VMI虚拟机自省技术，是一种用于在外部监测系统级虚拟机运行状态的技术<br>paper–网络攻击流量信息熵特征研究<br>paper–信息熵在入侵检测中的应用<br>基于相对熵理论的网络DoS攻击检测算法<br>基于熵权的传感反应网络任务分派算法<br>基于故障检测的无线传感器反应网络故障恢复策略<br>BP神经网络matlab实现和matlab工具箱使用实例</p>
<p>熵是用来对一个系统可以达到的状态数的一个度量，能达到的状态数越多熵越大。<br>只考虑字频的话英文是4.46比特/字符的信息熵，汉字是9.6比特/字符，直观上很容易理解，英文字母只有26个，所以描述一个字母所需要的信息表示不多，而中文字却很多，就需要更多的信息量才能表示<br>信息熵衡量了一个系统的复杂度,信息熵大的就说明那门课的信息量大，更加复杂。<br>——-最大熵原理(保留尽可能大的不确定性而作出最佳的尽量无偏差的决定)<br>在香农1948年的那篇文章里就可以看到，这个公式是推导出来的<br>信息是用来消除随机不定性的东西<br>平均信息熵(<a href="http://wenku.baidu.com/link?url=cYS9vIJkNnZEo8xm_8Q09JiC7GaGM9Zdhe9npIUWTjL3okk9lDM0t-hUccHrec_5OyKrtMxO3uPmJHBXdROJON26HcOoMFkeH4YWYXN1JV7" target="_blank" rel="external">http://wenku.baidu.com/link?url=cYS9vIJkNnZEo8xm_8Q09JiC7GaGM9Zdhe9npIUWTjL3okk9lDM0t-hUccHrec_5OyKrtMxO3uPmJHBXdROJON26HcOoMFkeH4YWYXN1JV7</a>)</p>
<p>BP神经网络是通过输入和输出的样本集（即网络的阈值和权值）对网络进行训练，从而使网络完成给定的输入/输出映射关系</p>
<p>在信息论中，熵被定义为一种不确定性的度量或是与随机变量相关的随机性。一个大小为n的样本的熵的阈值范围是[0，logn]。数据项没有变化时值为0，当所有的数据项都不相同或变化最大时值为logn。</p>
<p>熵值的规律是：流量特征值的微小变化产生低熵值，而流量特征值的显著变化则导致较高的熵值。</p>
<p>蜜网流量不同于其他类型的网络流量，因为流入或流出蜜网的每个数据包都被认为是恶意的；<br>语义重构模块的作用是对捕获到的数据进行语义重构，由于VMM处于客户虚拟机的底层，只能识别低级语义，两种之间存在语义鸿沟</p>
<p>系统采用VMI反省机制，将数据捕获模块部署在虚拟机监控器VMM内，实现了检测工具和蜜网系统的隔离，增强了数据捕获模块的安全性,提高了数据的可信度；</p>
<p>信息熵–&gt;BP神经网络（样本训练-&gt;映射）–&gt;K-Means算法–&gt; …</p>
<p>paper—&gt;无线传感器网络流量分析 无线传感器网络流量分析  (难点：工程实际、数据、仿真)<br>paper—&gt;项目–&gt; 工具开发<br>paper—&gt;信息熵 BP神经网络 （样本训练-&gt;映射） 模式识别  分类算法（K-Means）<br>paper—&gt; 原子攻击收益、单位路径收益 建模—-》攻击图生成算法—-》<br>paper—&gt; 已经发现CAN总线有  高错帧漏检  和  长的等效离线与真正离线的<br>paper–&gt;<br>基于系统仿真的飞行安全评估理论与方法/徐浩军, 刘东亮, 孟捷等编著<br>飞行风险的概率模型；飞行风险定量评估方法；基于支持向量机的飞行事故率预测<br>paper–&gt; 评估<br>安全指标 –&gt;攻击建模 – [可靠性与安全性模型的构建] – 网络拓扑、协议、实时性。身份认证、秘钥、篡改窃听、传输加密、容错)–&gt;仿真<br>paper –&gt; Petri –&gt; 马尔科夫链的转换<br>AFDX 航空总线仿真测试 </p>
<p>渗透测试–Reid创建了一套安全测试工具 eg:snort </p>
<p>AHP 层次分析法 结合了定性与定量，是一种多目标的决策分析法。包含三个阶段—分解系统个，判断安全性和综合进行判断，层次分析法提供了对系统的分层次、拟定量和规范化的处理。<br>OCTAVE评估 也是一种信息安全风险评估方法<br>攻击树模型</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java集合]]></title>
      <url>http://yoursite.com/2015/09/15/java%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<h2 id="Java-Collection"><a href="#Java-Collection" class="headerlink" title="Java Collection"></a>Java Collection</h2><h3 id="ArrayList-Vector都是-数组-实现"><a href="#ArrayList-Vector都是-数组-实现" class="headerlink" title="ArrayList Vector都是(数组)实现"></a>ArrayList Vector都是(数组)实现</h3><p>集合容器可以容纳任何对象，但是在实际应用中往往都是容纳同一类型的对象<br>泛型只是在编译阶段有效，防止错误产生。<br>避免扩容操作，因为会产生垃圾，影响性能<br>Iterator itor = list.iterator();<br>        while (itor.hasNext()) {<br>            System.out.println(itor.next());</p>
<pre><code>}
</code></pre><p>for(String str:list){<br>    …<br>}<br>Vector底层也是数组，支持一种老的遍历方式Enumeration,ArralyList遍历的方式也支持<br>ArrayList线程不安全，Vector线程安全</p>
<h3 id="LinkList-链表-实现"><a href="#LinkList-链表-实现" class="headerlink" title="LinkList(链表)实现"></a>LinkList(链表)实现</h3><p>提供了更为丰富的头尾操作</p>
<h3 id="Java-Eclipse无法查看源代码"><a href="#Java-Eclipse无法查看源代码" class="headerlink" title="Java Eclipse无法查看源代码"></a>Java Eclipse无法查看源代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.点 “window“-&gt; “Preferences”-&gt; “Java” -&gt; “Installed JRES”</div><div class="line">2.此时&quot;Installed JRES&quot;右边是列表窗格，列出了系统中的JRE 环境，选择你的JRE，然后点边上的“Edit...“， 会出现一个窗口(Edit JRE) </div><div class="line">3.选中rt.jar文件的这一项：“C:\Java\jdk1.5.0_04\jre\lib\rt.jar” 点 左边的“+”号展开它（JDK实际安装路径以你的为准）</div><div class="line">4.展开后，可以看到“Source Attachment:(none)”，点这一项，点右边的按钮“Source Attachment...“，选择你的JDK目录下的 “src.zip”文件</div><div class="line">5.一路点“ok”结束。</div></pre></td></tr></table></figure>
<h3 id="HashSet-无序集合"><a href="#HashSet-无序集合" class="headerlink" title="HashSet 无序集合"></a>HashSet 无序集合</h3><p>容纳的对象必须根据自己的唯一标识来重写equals和hashCode方法<br>对象一旦放入HashSet容器，那么对象的唯一标识属性的值不能再修改，否则导致对象移除不了<br>因为HashSet存放元素的时候，元素的位置是和对象HashCode算法得到的值相关的，查找元素时也要根据这个算法的值然后找到<br>相关位置，移除元素，没有则remove方法返回false,久而久之，产生内存泄露<br>HashSet底层用的是HashMap</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet容纳的对象有序，对象必须要能排序(排序方式自定义)<br>两种排序的比较器：<br>1.比较的对象实现Comparable接口，覆写compareTo方法<br>java.lang.Comparable,TreeSet使用无参数的构造函数，那么容纳的对象必须实现Comparable接口<br>implements Comparable<br>@Override<br>public int compareTo(User o){<br>    if(!this.name.equals(o.name))<br>        return this.name.compareTo(o.name);<br>    else<br>        return this.age-o.age; //名字相同，根据年龄排序<br>    return 0;<br>}<br>2.java.util.Comparator<br>TreeSet构造的时候使用Comparator作为构造函数的参数<br>TreeSet<user> ts = new TreeSet<user>(new MyComparator());<br>public class MyComparator implements Comparator<user>{<br>    @Override<br>    public int compare(User o1,user o2){<br>        return o1.getName().compareTo(o2.getName());<br>    }<br>}</user></user></user></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap hm = new HashMap()<br>//遍历Set集合，得到key，通过key获取value<br>Set set = hm.keySet();<br>for(Object obj:set){<br>    String key = (String)obj;<br>    User u = (User)hm.get(key);<br>}<br>//放入HashMap集合中的key，value都被包装成Map.Entry这个内部类的属性，有一个键值对，就存在一个Map.Entry的实例对象<br>//通过entrySet()方法就可以把这些实例对象都放入Set集合中<br>Set set1 = hm.entrySet();<br>for(Object obj:set1){<br>     Map.Entry me = (Map.Entry)object;<br>     System.out.println(me.getKey())+”=”+me.getValue();<br>}</p>
<p>HashMap<string,user> user2 = new HashMap<string,user>();<br>user2.put(u1.getId(),u1);<br>Set<string> set = User.keySet();<br>for(String key:set){<br>    user.get(key);<br>}</string></string,user></string,user></p>
<p>HashMap<map.entry<string,user>&gt; set1 = User.entrySet();<br>for(){}</map.entry<string,user></p>
<p>map.put(key,value)如果key相同，则后面的值会覆盖前面的值<br>使用HashMap来统计字符出现的频率：<br>HashMap<string,integer> hm = new HashMap<string,integer>();</string,integer></string,integer></p>
<pre><code>String s = &quot;abcdefghijklabcdiefabiddccdabffeg&quot;;
for (int i = 0; i &lt; s.length(); i++) {
    String str = s.substring(i, i+1);
    if(hm.containsKey(str)){
        hm.put(str, hm.get(str)+1);
    }else{
        hm.put(str, 1);
    }
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sybase学习小记]]></title>
      <url>http://yoursite.com/2015/09/15/sybase%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="Sybase-sql"><a href="#Sybase-sql" class="headerlink" title="Sybase_sql"></a>Sybase_sql</h2><h3 id="语法特点"><a href="#语法特点" class="headerlink" title="语法特点"></a>语法特点</h3><p>1.没有“ ”，字符串使用‘ ’包含<br>2.没有逻辑相等，赋值和逻辑相等都是=<br>3.类型不再是最严格的。任何数据都可以包含在‘ ’以内<br>4.没有bool值的概念，但是在视图中可以输入true/false<br>5.它也有关系运算符：&gt; &lt; &gt;= &lt;= = &lt;&gt; != ,它返回一个bool值<br>6.它也有逻辑运算符： ！(not) &amp;&amp;(and) ||(or)<br>7.它不区别大小写<br>8.数据库完整性（Database Integrity）是指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。</p>
<h3 id="事务的四个特点ACID"><a href="#事务的四个特点ACID" class="headerlink" title="事务的四个特点ACID"></a>事务的四个特点ACID</h3><p>A:原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。它是一个整体，不能再拆分<br>C：一致性：事务在完成时，必须使所有的数据都保持一致状态<br>I:隔离性：事务中隔离，每一个事务是单独的请求将单独的处理，与其它事务没有关系，互不影响<br>D：持久性：如果事务一旦提交，就对数据的修改永久保留</p>
<h3 id="存储过程功能"><a href="#存储过程功能" class="headerlink" title="存储过程功能"></a>存储过程功能</h3><p>存储过程为标准SQL增加了如下功能：<br>条件执行、循环控制结构、命名变量、命名过程、语句块（调用存储过程让DBMS执行一系列SQL语句）</p>
<h3 id="存储过程优点"><a href="#存储过程优点" class="headerlink" title="存储过程优点"></a>存储过程优点</h3><p>1）封装  只需要了解过程调用的输入输出就可以安全的使用数据库，防止用户跳过完整性检查<br>2）改善性能  调用存储过程时，DBMS可快速的执行存储过程中的语句，可直接转到语句的执行，无需分析，确认，优化和生成执行计划，这些步骤在预编译已经完成<br>3）减少网络流量，降低网络负载<br>4）标准组件化编程，极大的提高了程序的可移植性<br>5）安全性 系统管理员可向单独的用户授予对数据库对象的最小访问权限</p>
<h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><h3 id="索引优点-缺点"><a href="#索引优点-缺点" class="headerlink" title="索引优点/缺点"></a>索引优点/缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1.创建系统唯一性索引，可以保证每一行数据的唯一性<br>2.提高数据检索速度<br>3.加快表与表之间的连接，特别是具有主键外键关系的表之间<br>4.在针对order by 和 group by子句进行数据检索时，可以减少分组和排序的时间<br>5.查询优化器提高系统性能</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1.创建索引和维护索引要耗费时间<br>2.索引需要占用物理空间<br>3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护</p>
<p>###索引的类型</p>
<blockquote>
<ul>
<li>聚集索引：数据表的物理顺序与索引顺序相同</li>
<li>非聚集索引：数据表的物理顺序与索引顺序不同</li>
</ul>
</blockquote>
<h3 id="存储过程-VS-函数"><a href="#存储过程-VS-函数" class="headerlink" title="存储过程 VS 函数"></a>存储过程 VS 函数</h3><p>1.存储过程需要使用execute单独执行，而函数可以随处调用<br>2.用户自定义函数不能修改表中的数据，但是存储过程可以</p>
<h3 id="存储过程的执行过程"><a href="#存储过程的执行过程" class="headerlink" title="存储过程的执行过程"></a>存储过程的执行过程</h3><p>1.语法分析阶段，保证语法的正确性<br>2.解析阶段，检查该存储过程引用的对象名称是否存在<br>3.分析存储过程和生成存储过程执行计划的过程<br>4.执行阶段，执行主流在高速缓冲存储区的过程执行计划</p>
<blockquote>
<ul>
<li>注意,当存储过程引用的基础表发生结构变化时，该存储过程的执行计划将会自动优化。但是如果在表中添加了索引或者更改了索引列中<br>的数据之后，该执行计划不会自动优化，这时候应该重新编译存储过程，更新原有的执行计划。</li>
</ul>
</blockquote>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>SELECT CONCAT(Cname,Tnum) FROM course WHERE Cnum=03</p>
<h4 id="left-截取指定字符串的指定个数字符"><a href="#left-截取指定字符串的指定个数字符" class="headerlink" title="left 截取指定字符串的指定个数字符"></a>left 截取指定字符串的指定个数字符</h4><p>SELECT LEFT(Cname,5) FROM course WHERE Cnum=01<br>SELECT RIGHT(Cname,5) FROM course WHERE Cnum=01</p>
<h4 id="charIndex"><a href="#charIndex" class="headerlink" title="charIndex()"></a>charIndex()</h4><p>SELECT LOCATE(‘ne’,cname) FROM course WHERE cnum=01<br>SELECT SUBSTRING(Cname,1,3) FROM course</p>
<h3 id="delete-和-truncate"><a href="#delete-和-truncate" class="headerlink" title="delete 和 truncate"></a>delete 和 truncate</h3><p>delete from Teacher where Age&lt;20<br>–特点:<br>–1.删除是一条一条进行删除的<br>–2.每一条记录的删除都需要将操作写入到日志文件中<br>–3.标识列不会从种子值重新计算,以从上次最后一条标识列值往下计算<br>–4.这种删除可以触发delete触发器</p>
<p>–truncate table 表名 –没有条件，它是一次性删除所有数据<br>–特点：<br>–1.一次性删除所有数据，没有条件，那么日志文件只以最小化的数据写入<br>–2.它可以使用标识列从种子值重新计算<br>–3.它不能触发delete触发器<br>truncate table teacher</p>
<p>update Teacher set Salary=Salary+500 where ClassId=4 and Age&gt;20<br>–sign:正数==1  负数 ==-1  0=0<br>select SIGN(-100)</p>
<p>mysql不存在top关键词，使用limit<br>SELECT <em> FROM course WHERE cnum=(SELECT  cnum FROM sc ORDER BY cnum DESC LIMIT 0,1)<br>–使用top分页<br>select top 5 </em> from Student where StudentNo not in(select top 5 studentno from Student)</p>
<p>视图就是一张虚拟表，可以像使用子查询做为结果集一样使用视图<br>触发器:执行一个可以改变表数据的操作（增加删除和修改），会自动触发另外一系列（类似于存储过程中的模块）的操作。</p>
<p>SQL语法顺序是：<br>SELECT[DISTINCT]<br>FROM<br>WHERE<br>GROUP BY<br>HAVING<br>UNION<br>ORDER BY<br>执行顺序为：<br>FROM<br>WHERE<br>GROUP BY<br>HAVING<br>SELECT<br>DISTINCT<br>UNION<br>ORDER BY<br>The first thing that happens is loading data from the disk into memory, in order to operate on such data.<br>WITH a AS (<br>  SELECT first_name, last_name, current_date - date_of_birth age<br>  FROM author<br>)<br>SELECT *<br>FROM a<br>WHERE age &gt; 10000</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>SELECT 语句有很多特殊的规则，至少你应该熟悉以下几条<br>你仅能够使用那些能通过表引用而得来的字段<br>如果你有 GROUP BY 语句，你只能够使用 GROUP BY 语句后面的字段或者聚合函数<br>当你的语句中没有 GROUP BY 的时候，可以使用开窗函数代替聚合函数<br>当你的语句中没有 GROUP BY 的时候，你不能同时使用聚合函数和其它函数<br>有一些方法可以将普通函数封装在聚合函数中<br>存储过程要返回IQ系统错误信息 SQLCODE || ERRORMSG(*) ：(两者都为EXCEPTION后第一条SQL语句才有效果)<br>IQ中若采用 FULL JOIN 连接则不能使用 WHERE 条件，否则FULL JOIN将失效，要筛选条件则用子查询先过滤记录后再FULL JOIN；</p>
<h3 id="sybase常用SQL"><a href="#sybase常用SQL" class="headerlink" title="sybase常用SQL"></a>sybase常用SQL</h3><p>FROM后的子查询，要定义别名才可使用<br>IQ中若采用 FULL JOIN 连接则不能使用 WHERE 条件，否则FULL JOIN将失效，要筛选条件则用子查询先过滤记录后再FULL JOIN<br>根据SELECT 语句建立[临时]表的方法（ORACLE的CREATE TABLE）为 SELECT ..[*] INTO [‘#’]table_name FROM ..<br>其中如果在table_name加前缀’#’，则为会话级临时表，否则为实体表；<br>存储过程隐式游标语法：<br>FOR A AS B CURSOR FOR SELECT … FROM …<br>DO….<br>END FOR;<br>需要注意的时，这边的A 和 B 在 过程语句中都不能引用，所以为避免过程语句其他字段名与FOR SELECT 语句的字段名称重复，<br>FOR SELECT 语句的字段最好都定义别名区分<br>因Sybase为列存储模式，在执行上INSERT语句会比UPDATE语句慢，尤其表数据越多INSERT效率就越慢；所以在ETL时建议多用UPDATE而不是INSERT<br>空字符串’’在Sybase中也是个字符而不是null值，这点要注意<br>默认值和规则：Transact-SQL 提供维护实体完整性（确保为要求值得的每一列都提供值）和域完整性（确保列中的每个值都属于该列的合法值集合）的关键字</p>
<h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p>CONVERT(datetype,exp[,format-style])<br>CAST(exp AS data-type)</p>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>DAY(date_exp):返回日期天值，DAYS(date_exp,int):返回日期date_exp加int后的日期；MONTH与MONTHS、YEAR与YEARS同理；<br>DATE(exp):将表达式转换为日期，并删除任何小时、分钟或秒；兼容性：IQ<br>DATEPART(date-part,date-exp): 返回日期分量的对应值(整数)<br>GETDATE():返回系统时间<br>DATENAME(datepart,date_expr):以字符串形式返回date_expr指定部分的值,转换成合适的名字<br>DATEDIFF(datepart,date_expr1,date_expr2):返回date_expr2-date_expr1,通过指定的datepart度量<br>DATEADD（date-part,num-exp,date-exp）:返回按指定date-part分量加num-exp值后生成的date-exp值；</p>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>CEIL(num-exp)：返回大于或等于指定表达式的最小整数；兼容性：IQ&amp;ASE<br>FLOOR(numeric_expr):返回小于或等于指定值的最大整数<br>ABS(num-exp):返回数值表达式的绝对值；兼容性：IQ&amp;ASE<br>TRUNCNUM(1231.1251,2)：截取数值；不四舍五入<br>ROUND(numeric_expr,int_expr)：把数值表达式圆整到int_expr指定的精度<br>RAND([int_expr])：返回0-1之间的随机浮点数，可指定基值<br>SIGN(int_expr)：返回正+1，零0或负-1<br>SQRT(float_expr)：返回指定值的平方根<br>PI()：返回常数3.1415926<br>POWER(numeric_expr,power)：返回numeric_expr的值给power的幂<br>EXP(float_expr)：给出指定值的指数值</p>
<h3 id="常用DDL语句"><a href="#常用DDL语句" class="headerlink" title="常用DDL语句"></a>常用DDL语句</h3><p>1.删除列<br>ALTER TABLE table_name DELETE column_name<br>2.增加列<br>ALTER TABLE table_name ADD (column_name DATA_TYPE [NOT] NULL)<br>3.修改列的空与非空<br>ALTER TABLE table_name MODIFY column_name [NOT] NULL<br>4.修改列名<br>ALTER TABLE table_name RENAME old_column_name TO new_column_name<br>5.快速建立临时表<br>SELECT * INTO [#]table_name FROM …..<br>6、修改表名ALTER TABLE old_table_name RENAME new_table_name<br>7.增加主键约束<br>ALTER TABLE tb_name ADD CONSTRAINT pk_name PRIMARY KEY(col_name,..)<br>8.删除主键约束<br>ALTER TABLE tb_name DROP CONSTRAINT pk_name<br>9.建立自增长字段，与Oracle的SEQUENCE类似<br>CREATE TABLE TMP_001 (RES_ID INTEGER IDENTITY NOT NULL)<br>10.添加表注释<br>COMMENT ON TABLE table_name IS ‘….’<br>11.创建索引<br>CREATE INDEX index_name ON table_name(column_name)</p>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><p>常见瓶颈：<br>绝大多数瓶颈在于I/O子系统<br>若CPU很高，90%以上是因为索引不当<br>发生swap时，可能因为内存分配太小或过大<br>iowait太高时，想办法从索引角度入手优化，以及提高I/O设备性能，增加内存，减少排序，减少SELECT一次性读取数据量。<br>常见优化策略：<br>瞬间并发很高，采用thread pool<br>频繁order by\group by，索引入手<br>适当调整内存，不要太大或太小。一般ibp设置为50% ~ 70%为宜<br>iowait高，加内存，提高iops，减少数据读写。</p>
<p>SQL优化<br>多用简单SQL<br>少用子查询和复杂查询<br>少用复杂join，注意join驱动表是否最优<br>where不使用函数，避免无法使用索引<br>注意类型隐式转换<br>事务快速提交，但不要频繁反复提交</p>
<h3 id="查看执行计划"><a href="#查看执行计划" class="headerlink" title="查看执行计划"></a>查看执行计划</h3><p>查看语句的执行计划<br>set showplan on<br>set noexec on<br>go<br>select …….<br>go<br>set showplan off<br>set noexec off<br>go</p>
<p>查看存储过程执行计划：<br>set showplan on<br>go</p>
<p>exec sp_name<br>go<br>set showplan off<br>go</p>
<p>dbcc traceon(3604)是把dbcc的结果输出到屏幕上。<br>dbcc sqltext(spid)是看指定的sybase进程的操作语句。<br>查看其查询计划，可以用sp_showplan spid,null,null,null</p>
<h3 id="sybase系统函数"><a href="#sybase系统函数" class="headerlink" title="sybase系统函数"></a>sybase系统函数</h3><p>sp_iqtablesize ‘T1_table’  查看表的大小空间<br>select tablewidth(‘ConditionStyle’)   查看表的行宽<br>sp_iqcolumn  ‘ConditionData’  查看表中每一列的信息<br>select * from sp_table_size_statics();   此存储过程会输出所有用户表的大小</p>
<h3 id="bat启动"><a href="#bat启动" class="headerlink" title="bat启动"></a>bat启动</h3><p>dbisql -c “uid=netmax;pwd=SOPinUETZ” -host 10.89.160.6 -port 3000 -oneerror continue   -&gt; bat启动</p>
<p>###sql基础用法<br>drop table if exists tableA;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java面试题]]></title>
      <url>http://yoursite.com/2015/09/15/java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><ol>
<li>String类为什么是final的。<br>效率和安全，性能</li>
<li><p>HashMap的源码，实现原理，底层结构。</p>
</li>
<li><p>说说你知道的几个Java集合类：list、set、queue、map实现类咯。。。<br>List: ArrayList  LinkedList  Vector  Stack<br>Set : TreeSet  HashSet<br>Queur: BlockingQueue   Deque<br>Map : HashMap  Hashtable</p>
</li>
<li>描述一下ArrayList和LinkedList各自实现和区别<br>ArrayList 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。<br>LinkedList 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率低。</li>
<li><p>Java中的队列都有哪些，有什么区别。</p>
</li>
<li><p>反射中，Class.forName和classloader的区别<br>Class.forName(className)装载的class已经被初始化，而ClassLoader.loadClass(className)装载的class还没有被link。<br>一般情况下，这两个方法效果一样，都能装载Class。但如果程序依赖于Class是否被初始化，就必须用Class.forName(name)了。</p>
</li>
<li>Java7、Java8的新特性(baidu问的,好BT)<br>lambda 流式编程  函数式接口</li>
<li>Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高</li>
<li><p>Java内存泄露的问题调查定位：jmap，jstack的使用等等</p>
</li>
<li><p>string、stringbuilder、stringbuffer区别<br>StringBuilder &gt; StringBuffer &gt; String  速度<br>StringBuffer 线程安全的</p>
</li>
<li>hashtable和hashmap的区别<br>线程安全 &amp;&amp; null值两方面<br>13 .异常的结构，运行时异常和非运行时异常，各举个例子<br>1)非受检的：NullPointerException,ClassCastException,ArrayIndexsOutOfBoundsException,ArithmeticException(算术异常，除0溢出)<br>2)受检：Exception,FileNotFoundException,IOException,SQLException.</li>
<li>String a= “abc” String b = “abc” String c = new String(“abc”) String d = “ab” + “c” .他们之间用 == 比较的结果</li>
<li>String 类的常用方法<br>String.toCharArray()  String.getBytes()  String.length()   String.indexOf(String str)   String.subString()<br>String.split()    toUpperCase()   replace()</li>
<li>Java 的引用类型有哪几种</li>
<li><p>抽象类和接口的区别</p>
</li>
<li><p>java的基础类型和字节大小。<br>char  16bit  |   short   16bit  |   byte    8bit | int  32bit   |   long   64bit  |  floag   32bit  |  double  64bit</p>
</li>
<li>Hashtable,HashMap,ConcurrentHashMap 底层实现原理与线程安全问题</li>
<li>自己实现一个Map。</li>
<li><p>Hash冲突怎么办？哪些解决散列冲突的方法？</p>
</li>
<li><p>HashMap冲突很厉害，最差性能，你会怎么解决?从O（n）提升到log（n）咯，用二叉排序树的思路说了一通</p>
</li>
<li>rehash</li>
<li>hashCode() 与 equals() 生成算法、方法怎么重写</li>
</ol>
<h3 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h3><ol>
<li>讲讲IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞。</li>
<li>讲讲NIO。<br>Channels and Buffers（通道和缓冲区）：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中</li>
<li>String 编码UTF-8 和GBK的区别?<br>GBK占用两个字节；UTF8对于英文占用一个字节，对于中文占用两个字节</li>
<li>什么时候使用字节流、什么时候使用字符流?<br>字节流在操作时本身不会用到缓冲区；而字符流在操作时用到了缓冲区，通过缓冲区再操作文件<br>所有的文件在硬盘或在传输时都是以字节的方式进行的，包括图片等都是按字节的方式存储的，而字符是只有在内存中才会形成，所以在开发中，字节流使用较为广泛。<br>程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。<br>如果要java程序实现一个拷贝功能，应该选用字节流进行操作（可能拷贝的是图片），并且采用边读边写的方式（节省内存）</li>
<li>递归读取文件夹下的文件，代码怎么实现</li>
</ol>
<h3 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h3><ol>
<li><p>session和cookie的区别和联系，session的生命周期，多个服务部署时session管理。</p>
</li>
<li><p>servlet的一些相关问题</p>
</li>
<li>webservice相关问题</li>
<li>jdbc连接，forname方式的步骤，怎么声明使用一个事务。举例并具体代码</li>
<li>无框架下配置web.xml的主要配置内容</li>
<li>jsp和servlet的区别</li>
</ol>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ol>
<li>Java的内存模型以及GC算法</li>
<li>jvm性能调优都做了什么</li>
<li>介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明</li>
<li>介绍GC 和GC Root不正常引用。</li>
<li>自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展</li>
<li>jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析</li>
<li>数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）</li>
<li>老年代中数组的访问方式</li>
<li>GC 算法，永久代对象如何 GC ， GC 有环怎么处理</li>
<li>谁会被 GC ，什么时候 GC</li>
<li>如果想不被 GC 怎么办</li>
<li>如果想在 GC 中生存 1 次怎么办</li>
</ol>
<h3 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h3><ol>
<li>hibernate和ibatis的区别</li>
<li>讲讲mybatis的连接池。</li>
<li>spring框架中需要引用哪些jar包，以及这些jar包的用途</li>
<li>springMVC的原理</li>
<li>springMVC注解的意思</li>
<li>spring中beanFactory和ApplicationContext的联系和区别</li>
<li>spring注入的几种方式（循环注入）</li>
<li>spring如何实现事物管理的</li>
<li>springIOC</li>
<li>spring AOP的原理</li>
<li>hibernate中的1级和2级缓存的使用方式以及区别原理（Lazy-Load的理解）</li>
<li>Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。<br>六、多线程</li>
<li>Java创建线程之后，直接调用start()方法和run()的区别</li>
<li>常用的线程池模式以及不同线程池的使用场景</li>
<li>newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。</li>
<li>多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。</li>
<li>了解可重入锁的含义，以及ReentrantLock 和synchronized的区别</li>
<li>同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高</li>
<li>atomicinteger和volatile等线程安全操作的关键字的理解和使用</li>
<li>线程间通信，wait和notify</li>
<li>定时线程的使用</li>
<li>场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。</li>
<li>进程和线程的区别</li>
<li>什么叫线程安全？举例说明</li>
<li>线程的几种状态</li>
<li>并发、同步的接口或方法</li>
<li>HashMap 是否线程安全，为何不安全。 ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。</li>
<li>J.U.C下的常见类的使用。 ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。</li>
<li>简单介绍下多线程的情况，从建立一个线程开始。然后怎么控制同步过程，多线程常用的方法和结构</li>
<li>volatile的理解</li>
<li>实现多线程有几种方式，多线程同步怎么做，说说几个线程里常用的方法</li>
</ol>
<h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><ol>
<li>http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。</li>
<li>socket通信，以及长连接，分包，连接异常断开的处理。</li>
<li>socket通信模型的使用，AIO和NIO。</li>
<li>socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。</li>
<li>同步和异步，阻塞和非阻塞。<br>异步的概念和同步相对。当一个异步过程调用发出后，调用者不会立刻得到结果。实际处理这个调用的部件是在调用发出后，通过状态、通知来通知<br>调用者，或通过回调函数处理这个调用。<br>阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。<br>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。<br>有同步阻塞、异步阻塞、同步非阻塞、异步非阻塞</li>
<li>OSI七层模型，包括TCP,IP的一些基本知识</li>
<li>http中，get post的区别</li>
<li>说说http,tcp,udp之间关系和区别。</li>
<li>说说浏览器访问www.taobao.com，经历了怎样的过程。<br>本地缓存   DNS缓存  迭代查询和递归查询</li>
<li>HTTP协议、  HTTPS协议，SSL协议及完整交互过程；</li>
<li>tcp的拥塞，快回传，ip的报文丢弃</li>
<li>https处理的一个过程，对称加密和非对称加密</li>
<li>head各个特点和区别</li>
</ol>
<h3 id="数据库MySql"><a href="#数据库MySql" class="headerlink" title="数据库MySql"></a>数据库MySql</h3><ol>
<li>MySql的存 储引擎的不同</li>
<li>单个索引、联合索引、主键索引</li>
<li>Mysql怎么分表，以及分表后如果想按条件分页查询怎么办(如果不是按分表字段来查询的话，几乎效率低下，无解)</li>
<li>分表之后想让一个id多个表是自增的，效率实现</li>
<li>MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离</li>
<li>写SQL语句。。。</li>
<li><p>索引的数据结构，B+树</p>
</li>
<li><p>事务的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题</p>
</li>
<li><p>数据库的锁：行锁，表锁；乐观锁，悲观锁</p>
</li>
<li><p>数据库事务的几种粒度；<br>事务四个特性 ： 原子性  一致性  隔离性   持久性</p>
</li>
<li><p>关系型和非关系型数据库区别</p>
<blockquote>
<ul>
<li>非关系型数据库的优势：</li>
</ul>
</blockquote>
</li>
<li>性能<br>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li>
<li>可扩展性<br>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。<blockquote>
<ul>
<li>关系型数据库的优势：</li>
</ul>
</blockquote>
</li>
<li>复杂查询<br>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li>
<li><p>事务支持<br>使得对于安全性能很高的数据访问要求得以实现。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3></li>
<li><p>单例模式：饱汉、饿汉。以及饿汉中的延迟加载,双重检查</p>
</li>
<li>工厂模式、装饰者模式、观察者模式。</li>
<li>工厂方法模式的优点（低耦合、高内聚，开放封闭原则）</li>
</ol>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol>
<li>使用随机算法产生一个数，要求把1-1000W之间这些数全部生成。（考察高效率，解决产生冲突的问题）</li>
<li>两个有序数组的合并排序</li>
<li>一个数组的倒序</li>
<li>计算一个正整数的正平方根</li>
<li>说白了就是常见的那些查找、排序算法以及各自的时间复杂度</li>
<li>二叉树的遍历算法</li>
<li>DFS,BFS算法</li>
<li>比较重要的数据结构，如链表，队列，栈的基本理解及大致实现。</li>
<li>排序算法与时空复杂度（快排为什么不稳定，为什么你的项目还在用）</li>
<li>逆波兰计算器</li>
<li>Hoffman 编码</li>
<li>查找树与红黑树</li>
</ol>
<h3 id="并发与性能调优"><a href="#并发与性能调优" class="headerlink" title="并发与性能调优"></a>并发与性能调优</h3><ol>
<li>有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?</li>
<li>高并发情况下，我们系统是如何支撑大量的请求的</li>
<li>集群如何同步会话状态</li>
<li>负载均衡的原理<br>5 .如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）</li>
<li>如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。</li>
<li>假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。</li>
<li>如何查找 造成 性能瓶颈出现的位置，是哪个位置照成性能瓶颈。</li>
<li>你的项目中使用过缓存机制吗？有没用用户非本地缓存</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.常用的linux下的命令</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java习惯用法]]></title>
      <url>http://yoursite.com/2015/09/08/java%E4%B9%A0%E6%83%AF%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="java习惯用法"><a href="#java习惯用法" class="headerlink" title="java习惯用法"></a>java习惯用法</h2><h3 id="实现equals"><a href="#实现equals" class="headerlink" title="实现equals()"></a>实现equals()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">  String name;</div><div class="line">  int birthYear;</div><div class="line">  byte[] raw;</div><div class="line">  public boolean equals(Object obj) &#123;</div><div class="line"></div><div class="line">    if (!obj instanceof Person)</div><div class="line">      return false;</div><div class="line">    Person other = (Person)obj;</div><div class="line">    return name.equals(other.name)</div><div class="line">        &amp;&amp; birthYear == other.birthYear</div><div class="line">        &amp;&amp; Arrays.equals(raw, other.raw);</div><div class="line">  &#125;</div><div class="line">  public int hashCode() &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数必须是Object类型，不能是外围类。</p>
<p>foo.equals(null) 必须返回false，不能抛NullPointerException。（注意，null instanceof 任意类 总是返回false，<br>因此上面的代码可以运行。）</p>
<p>基本类型域（比如，int）的比较使用 == ，基本类型数组域的比较使用Arrays.equals()。</p>
<p>覆盖equals()时，记得要相应地覆盖 hashCode()，与 equals() 保持一致。</p>
<h3 id="实现hashCode"><a href="#实现hashCode" class="headerlink" title="实现hashCode()"></a>实现hashCode()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">  String a;</div><div class="line">  Object b;</div><div class="line">  byte c;</div><div class="line">  int[] d;</div><div class="line"></div><div class="line">  public int hashCode() &#123;</div><div class="line">    return a.hashCode() + b.hashCode() + c + Arrays.hashCode(d);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public boolean equals(Object o) &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当x和y两个对象具有x.equals(y) == true ，你必须要确保x.hashCode() == y.hashCode()。<br>根据逆反命题，如果x.hashCode() != y.hashCode()，那么x.equals(y) == false 必定成立。<br>你不需要保证，当x.equals(y) == false时，x.hashCode() != y.hashCode()。但是，如果你可以尽可能地使它成立的话，这会提高哈希表的性能。</p>
<h3 id="实现compareTo"><a href="#实现compareTo" class="headerlink" title="实现compareTo()"></a>实现compareTo()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Person implements Comparable&lt;Person&gt; &#123;</div><div class="line">  String firstName;</div><div class="line">  String lastName;</div><div class="line">  int birthdate;</div><div class="line"></div><div class="line">  // Compare by firstName, break ties by lastName, finally break ties by birthdate</div><div class="line">  public int compareTo(Person other) &#123;</div><div class="line">    if (firstName.compareTo(other.firstName) != 0)</div><div class="line">      return firstName.compareTo(other.firstName);</div><div class="line">    else if (lastName.compareTo(other.lastName) != 0)</div><div class="line">      return lastName.compareTo(other.lastName);</div><div class="line">    else if (birthdate &lt; other.birthdate)</div><div class="line">      return -1;</div><div class="line">    else if (birthdate &gt; other.birthdate)</div><div class="line">      return 1;</div><div class="line">    else</div><div class="line">      return 0;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实现clone"><a href="#实现clone" class="headerlink" title="实现clone()"></a>实现clone()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Values implements Cloneable &#123;</div><div class="line">  String abc;</div><div class="line">  double foo;</div><div class="line">  int[] bars;</div><div class="line">  Date hired;</div><div class="line"></div><div class="line">  public Values clone() &#123;</div><div class="line">    try &#123;</div><div class="line">      Values result = (Values)super.clone();</div><div class="line">      result.bars = result.bars.clone();</div><div class="line">      result.hired = result.hired.clone();</div><div class="line">      return result;</div><div class="line">    &#125; catch (CloneNotSupportedException e) &#123;  // Impossible</div><div class="line">      throw new AssertionError(e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 super.clone() 让Object类负责创建新的对象。<br>基本类型域都已经被正确地复制了。同样，我们不需要去克隆String和BigInteger等不可变类型。<br>手动对所有的非基本类型域（对象和数组）进行深度复制（deep copy）。<br>实现了Cloneable的类，clone()方法永远不要抛CloneNotSupportedException。因此，<br>需要捕获这个异常并忽略它，或者使用不受检异常（unchecked exception）包装它。</p>
<h3 id="使用StringBuilder或StringBuffer"><a href="#使用StringBuilder或StringBuffer" class="headerlink" title="使用StringBuilder或StringBuffer"></a>使用StringBuilder或StringBuffer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) -&gt; &quot;a and b and c&quot;</div><div class="line">String join(List&lt;String&gt; strs) &#123;</div><div class="line">  StringBuilder sb = new StringBuilder();</div><div class="line">  boolean first = true;</div><div class="line">  for (String s : strs) &#123;</div><div class="line">    if (first) </div><div class="line">    	first = false;</div><div class="line">    else </div><div class="line">    	sb.append(&quot; and &quot;);</div><div class="line">    sb.append(s);</div><div class="line">  &#125;</div><div class="line">  return sb.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不要像这样使用重复的字符串连接：s += item ，因为它的时间效率是O(n^2)。<br>使用StringBuilder或者StringBuffer时，可以使用append()方法添加文本和使用toString()方法去获取连接起来的整个文本。<br>优先使用StringBuilder，因为它更快。StringBuffer的所有方法都是同步的，而你通常不需要同步的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Random rand = new Random();</div><div class="line">System.out.println(rand.nextInt(6)+1);</div></pre></td></tr></table></figure>
<h3 id="使用Iterator-remove"><a href="#使用Iterator-remove" class="headerlink" title="使用Iterator.remove()"></a>使用Iterator.remove()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void filter(List&lt;String&gt; list) &#123;</div><div class="line">  for (Iterator&lt;String&gt; iter = list.iterator(); iter.hasNext(); ) &#123;</div><div class="line">    String item = iter.next();</div><div class="line">    if (...)</div><div class="line">      iter.remove();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串反转-逆序"><a href="#字符串反转-逆序" class="headerlink" title="字符串反转(逆序)"></a>字符串反转(逆序)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static String reverse(String s)&#123;</div><div class="line">		return new StringBuilder(s).reverse().toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>1)继承Thread类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class MyThread extends Thread&#123;</div><div class="line">	public void run()&#123;   ...   &#125;</div><div class="line">&#125;</div><div class="line">new MyThread.start();</div><div class="line">2) 实现Runnable接口</div><div class="line">class MyRunnable implements Runnable&#123;</div><div class="line">	public void run()&#123;   ...   &#125;</div><div class="line">&#125;</div><div class="line">new Thread(new MyRunnable()).start()</div></pre></td></tr></table></figure>
<p>不要直接调用run()方法。总是调用Thread.start()方法，这个方法会创建一条新的线程并使新建的线程调用run()。</p>
<p>如果try之前的语句运行失败并且抛出异常，那么finally语句块就不会执行<br>如果try语句块里面的语句抛出异常，那么程序的运行就会跳到finally语句块里执行尽可能多的语句，然后跳出这个方法（</p>
<h3 id="从输入流里读取字节数据"><a href="#从输入流里读取字节数据" class="headerlink" title="从输入流里读取字节数据"></a>从输入流里读取字节数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">InputStream in = (...);</div><div class="line">try &#123;</div><div class="line">  while (true) &#123;</div><div class="line">    int b = in.read();</div><div class="line">    if (b == -1)</div><div class="line">      break;</div><div class="line">    (... process b ...)</div><div class="line">  &#125;</div><div class="line">&#125; finally &#123;</div><div class="line">  in.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>read()方法要么返回下一次从流里读取的字节数（0到255，包括0和255），要么在达到流的末端时返回-1。</p>
<h3 id="从输入流里读取块数据"><a href="#从输入流里读取块数据" class="headerlink" title="从输入流里读取块数据"></a>从输入流里读取块数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">InputStream in = (...);</div><div class="line">try &#123;</div><div class="line">  byte[] buf = new byte[100];</div><div class="line">  while (true) &#123;</div><div class="line">    int n = in.read(buf);</div><div class="line">    if (n == -1)</div><div class="line">      break;</div><div class="line">    (... process buf with offset=0 and length=n ...)</div><div class="line">  &#125;</div><div class="line">&#125; finally &#123;</div><div class="line">  in.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要记住的是，read()方法不一定会填满整个buf，所以你必须在处理逻辑中考虑返回的长度。</p>
<h3 id="从文件里读取文本"><a href="#从文件里读取文本" class="headerlink" title="从文件里读取文本"></a>从文件里读取文本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BufferedReader in = new BufferedReader(</div><div class="line">    new InputStreamReader(new FileInputStream(...), &quot;UTF-8&quot;));</div><div class="line">try &#123;</div><div class="line">  while (true) &#123;</div><div class="line">    String line = in.readLine();</div><div class="line">    if (line == null)</div><div class="line">      break;</div><div class="line">    (... process line ...)</div><div class="line">  &#125;</div><div class="line">&#125; finally &#123;</div><div class="line">  in.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BufferedReader对象的创建显得很冗长。这是因为Java把字节和字符当成两个不同的概念来看待（这与C语言不同）。<br>你可以使用任何类型的InputStream来代替FileInputStream，比如socket。<br>当达到流的末端时，BufferedReader.readLine()会返回null。<br>要一次读取一个字符，使用Reader.read()方法。<br>你可以使用其他的字符编码而不使用UTF-8，但最好不要这样做。</p>
<h3 id="向文件里写文本"><a href="#向文件里写文本" class="headerlink" title="向文件里写文本"></a>向文件里写文本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PrintWriter out = new PrintWriter(</div><div class="line">    new OutputStreamWriter(new FileOutputStream(...), &quot;UTF-8&quot;));</div><div class="line">try &#123;</div><div class="line">  out.print(&quot;Hello &quot;);</div><div class="line">  out.print(42);</div><div class="line">  out.println(&quot; world!&quot;);</div><div class="line">&#125; finally &#123;</div><div class="line">  out.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Printwriter对象的创建显得很冗长。这是因为Java把字节和字符当成两个不同的概念来看待（这与C语言不同）。<br>就像System.out，你可以使用print()和println()打印多种类型的值。<br>你可以使用其他的字符编码而不使用UTF-8，但最好不要这样做。</p>
<h3 id="预防性检测（Defensive-checking）数值"><a href="#预防性检测（Defensive-checking）数值" class="headerlink" title="预防性检测（Defensive checking）数值"></a>预防性检测（Defensive checking）数值</h3><p>预防性检测对象<br>预防性检测数组索引<br>预防性检测数组区间</p>
<h3 id="填充数组元素"><a href="#填充数组元素" class="headerlink" title="填充数组元素"></a>填充数组元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">byte[] a =new byte[10];</div><div class="line">		Arrays.fill(a,(byte)123);</div><div class="line">		for (byte b : a) &#123;</div><div class="line">			System.out.println(b);</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h3 id="把4个字节包装（packing）成一个int"><a href="#把4个字节包装（packing）成一个int" class="headerlink" title="把4个字节包装（packing）成一个int"></a>把4个字节包装（packing）成一个int</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int packBigEndian(byte[] b) &#123;</div><div class="line">  return (b[0] &amp; 0xFF) &lt;&lt; 24</div><div class="line">       | (b[1] &amp; 0xFF) &lt;&lt; 16</div><div class="line">       | (b[2] &amp; 0xFF) &lt;&lt;  8</div><div class="line">       | (b[3] &amp; 0xFF) &lt;&lt;  0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int packLittleEndian(byte[] b) &#123;</div><div class="line">  return (b[0] &amp; 0xFF) &lt;&lt;  0</div><div class="line">       | (b[1] &amp; 0xFF) &lt;&lt;  8</div><div class="line">       | (b[2] &amp; 0xFF) &lt;&lt; 16</div><div class="line">       | (b[3] &amp; 0xFF) &lt;&lt; 24;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="把int分解（Unpacking）成4个字节"><a href="#把int分解（Unpacking）成4个字节" class="headerlink" title="把int分解（Unpacking）成4个字节"></a>把int分解（Unpacking）成4个字节</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">byte[] unpackBigEndian(int x) &#123;</div><div class="line">  return new byte[] &#123;</div><div class="line">    (byte)(x &gt;&gt;&gt; 24),</div><div class="line">    (byte)(x &gt;&gt;&gt; 16),</div><div class="line">    (byte)(x &gt;&gt;&gt;  8),</div><div class="line">    (byte)(x &gt;&gt;&gt;  0)</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">byte[] unpackLittleEndian(int x) &#123;</div><div class="line">  return new byte[] &#123;</div><div class="line">    (byte)(x &gt;&gt;&gt;  0),</div><div class="line">    (byte)(x &gt;&gt;&gt;  8),</div><div class="line">    (byte)(x &gt;&gt;&gt; 16),</div><div class="line">    (byte)(x &gt;&gt;&gt; 24)</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总是使用无符号右移操作符（&gt;&gt;&gt;）对位进行包装（packing），不要使用算术右移操作符（&gt;&gt;）。</p>
<p>eg<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class RightDef&#123;</div><div class="line">  int num1 = num2+2;</div><div class="line">  static int num2 = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>static 修饰的变量属于类，类变量会随着类初始化得到初始化，因此num2的初始化时机总是处于num1的初始化时机之前</p>
<p>使用 static 修饰的变量是类变量，没有使用 static 修饰的是实例变量<br>在同一个JVM中，每个类只对应一个Class对象，但每个类可以创建多个Java对象<br>同一个JVM内的类变量只需一块内存空间，但是该类每创建一次实例，就需要为实例变量分配内存空间<br>每个类初始化完成之后，系统都会为该类创建一个对应的Class实例，程序可以通过反射来获取某个类对应的Class实例。<br>eg: 要获取person类的Class实例。通过 Person.class 或者 Class.forName(“Person”);</p>
<p>通过实例来访问某个类变量的时候，底层依然会转换为通过类访问类变量。</p>
<h3 id="实例变量的初始化时机："><a href="#实例变量的初始化时机：" class="headerlink" title="实例变量的初始化时机："></a>实例变量的初始化时机：</h3><p>1）定义实例变量时指定初始值<br>2）非静态初始化块中对实例变量指定初始值<br>3）构造器中对实例变量指定初始值<br>1和2先于3执行，1,2的顺序与他们在源程序中的排列顺序相同<br>eg:</p>
<p>public Cat(String name,int age){ … }<br>{weight=2.0}<br>double weight = 2.3</p>
<p>每次执行之后weight都是 2.3，因为非静态代码块在前面，先执行</p>
<h3 id="类变量的初始化时机："><a href="#类变量的初始化时机：" class="headerlink" title="类变量的初始化时机："></a>类变量的初始化时机：</h3><p>1）定义类变量时指定初始值<br>2）静态初始化块中对类变量指定初始值<br>这两种方式的执行顺序与他们在源程序中的排列顺序相同</p>
<p>final 可修饰变量，被final修饰的变量被赋值后不能重新赋值<br>final 可修饰方法，被final修饰的方法不能被重写<br>final 可修饰类  ，被final修饰的类不能派生子类</p>
<h3 id="Java-Eclipse无法查看源代码"><a href="#Java-Eclipse无法查看源代码" class="headerlink" title="Java Eclipse无法查看源代码"></a>Java Eclipse无法查看源代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.点 “window“-&gt; “Preferences”-&gt; “Java” -&gt; “Installed JRES”</div><div class="line">2.此时&quot;Installed JRES&quot;右边是列表窗格，列出了系统中的JRE 环境，选择你的JRE，然后点边上的“Edit...“</div><div class="line">3.选中rt.jar文件的这一项：“C:\Java\jdk1.5.0_04\jre\lib\rt.jar” 点 左边的“+”号展开它（JDK实际安装路径以你的为准）</div><div class="line">4.展开后，可以看到“Source Attachment:(none)”，点这一项，点右边的按钮“Source Attachment...“，选择你的JDK目录下的 “src.zip”文件</div><div class="line">5.一路点“ok”结束。</div></pre></td></tr></table></figure>
<p>sublime text3<br>多处选择相同的词：Ctrl+D，回退选择Ctrl+U默认设置<br>逐词移动：Ctrl+左右键默认设置<br>显示类和方法提纲：Ctrl+R默认设置，可以很容易知道一个类中都有哪些方法。<br>显示n个窗口：alt+shift+1，或者2,3…显示n个窗口<br>格式化代码：alt+shift+f自己设置的，选择代码后按此快捷键可以格式化代码。修改 reindent<br>折叠代码：ctrl+shift+[自己设置的，可以折叠方法里面的代码  修改fold_by_level</p>
<p>（1）：“在Java里面参数传递都是按值传递”这句话的意思是：按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递。<br>（2）：在Java里面只有基本类型和按照下面这种定义方式的String是按值传递，其它的都是按引用传递。就是直接使用双引号定义字符串方式：String str = “Java私塾”;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[海量数据处理]]></title>
      <url>http://yoursite.com/2015/09/06/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>作者：July、youwang、yanxionglu。<br>出处：<a href="http://blog.csdn.net/v_JULY_v。" target="_blank" rel="external">http://blog.csdn.net/v_JULY_v。</a></p>
<h2 id="十道海量数据处理面试题"><a href="#十道海量数据处理面试题" class="headerlink" title="十道海量数据处理面试题"></a>十道海量数据处理面试题</h2><ul>
<li>提取出某日访问百度次数最多的那个IP。</li>
</ul>
<p>首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。<br>或者如下阐述（雪域之鹰）：<br>算法思想：分而治之+Hash<br>1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理；<br>2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址；<br>3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址；<br>4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；</p>
<ul>
<li>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。<br>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</li>
</ul>
<p>典型的Top K算法，还是在这篇文章里头有所阐述，详情请参见：十一、从头到尾彻底解析Hash表算法。<br>文中，给出的最终算法是：<br>第一步、先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计（之前写成了排序，特此订正。July、2011.04.27）；<br>第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。<br>  即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N’*O（logK），（N为1000万，N’为300万）。ok，更多，详情，请参考原文。<br>或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p>
<ul>
<li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</li>
</ul>
<p>方案：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。<br>如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。<br>对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。</p>
<ul>
<li>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</li>
</ul>
<p>还是典型的TOP K算法，解决方案如下：<br>方案1：<br>顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。<br>找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。<br>对这10个文件进行归并排序（内排序与外排序相结合）。<br>方案2：<br> 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。<br>方案3：<br>与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p>
<ul>
<li>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</li>
</ul>
<p>方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。<br>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。<br>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。<br>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。<br>方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</p>
<ul>
<li>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</li>
</ul>
<p>方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p>
<p>方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。</p>
<ul>
<li>腾讯面试题：给40亿个不重复的unsigned </li>
</ul>
<p>int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</p>
<p>与上第6题类似，我的第一反应时快速排序+二分查找。以下是其它更好的方法：<br>方案1：oo，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p>
<p>dizengrong：<br>方案2：这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下：<br>又因为2^32为40亿多，所以给定一个数可能在，也可能不在其中；<br>这里我们把40亿个数中的每一个用32位的二进制来表示<br>假设这40亿个数开始放在一个文件中。</p>
<p>然后将这40亿个数分成两类:<br>1.最高位为0<br>2.最高位为1<br>并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=20亿，而另一个&gt;=20亿（这相当于折半了）；<br>与要查找的数的最高位比较并接着进入相应的文件再查找</p>
<p>再然后把这个文件为又分成两类:<br>1.次最高位为0<br>2.次最高位为1</p>
<p>并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=10亿，而另一个&gt;=10亿（这相当于折半了）；<br>与要查找的数的次最高位比较并接着进入相应的文件再查找。<br>…….<br>以此类推，就可以找到了,而且时间复杂度为O(logn)，方案2完。</p>
<p>附：这里，再简单介绍下，位图方法：<br>使用位图法判断整形数组是否存在重复<br>判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。</p>
<p>位图法比较适合于这种情况，它的做法是按照集合中最大元素max创建一个长度为max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上1，如遇到5就给新数组的第六个元素置1，这样下次再遇到5想置位时发现新数组的第六个元素已经是1了，这说明这次的数据肯定和以前的数据存在着重复。这种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为2N。如果已知数组的最大值即能事先给新数组定长的话效率还能提高一倍。</p>
<ul>
<li>怎么在海量数据中找出重复次数最多的一个？</li>
</ul>
<p>方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p>
<ul>
<li>上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。</li>
</ul>
<p>方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第2题提到的堆机制完成。</p>
<ul>
<li>一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</li>
</ul>
<p>方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n</em>lg10)。所以总的时间复杂度，是O(n<em>le)与O(n</em>lg10)中较大的哪一个。</p>
<ul>
<li>100w个数中找出最大的100个数。</li>
</ul>
<p>方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。</p>
<p>方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。</p>
<p>方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。</p>
<p>致谢：<a href="http://www.cnblogs.com/youwang/。" target="_blank" rel="external">http://www.cnblogs.com/youwang/。</a></p>
<p>##十个海量数据处理方法大总结</p>
<p>下面的方法全部来自<a href="http://hi.baidu.com/yanxionglu/blog/博客，对海量数据的处理方法进行了一个一般性的总结，当然这些方法可能并不能完全覆盖所有的问题，但是这样的一些方法也基本可以处理绝大多数遇到的问题。下面的一些问题基本直接来源于公司的面试笔试题目，方法不一定最优，如果你有更好的处理方法，欢迎讨论。" target="_blank" rel="external">http://hi.baidu.com/yanxionglu/blog/博客，对海量数据的处理方法进行了一个一般性的总结，当然这些方法可能并不能完全覆盖所有的问题，但是这样的一些方法也基本可以处理绝大多数遇到的问题。下面的一些问题基本直接来源于公司的面试笔试题目，方法不一定最优，如果你有更好的处理方法，欢迎讨论。</a></p>
<h3 id="Bloom-filter"><a href="#Bloom-filter" class="headerlink" title="Bloom filter"></a>Bloom filter</h3><p>适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集</p>
<h3 id="基本原理及要点："><a href="#基本原理及要点：" class="headerlink" title="基本原理及要点："></a>基本原理及要点：</h3><p>对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。</p>
<p>还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)<em>(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于n</em>lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。</p>
<p>举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。</p>
<p>注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。</p>
<p>扩展：<br>Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。</p>
<p>问题实例：给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？</p>
<p>根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。</p>
<h3 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h3><p>适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存</p>
<p>基本原理及要点：<br>hash函数选择，针对字符串，整数，排列，具体相应的hash方法。<br>碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。</p>
<p>扩展：<br>d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。</p>
<p>问题实例：<br>1).海量日志数据，提取出某日访问百度次数最多的那个IP。<br>IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。</p>
<h3 id="bit-map"><a href="#bit-map" class="headerlink" title="bit-map"></a>bit-map</h3><p>适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下</p>
<p>基本原理及要点：使用bit数组来表示某些元素是否存在，比如8位电话号码</p>
<p>扩展：bloom filter可以看做是对bit-map的扩展</p>
<p>问题实例：<br>1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。<br>8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。<br>2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p>
<p>将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>适用范围：海量数据前n大，并且n比较小，堆可以放入内存</p>
<p>基本原理及要点：最大堆求前n小，最小堆求前n大。方法，比如求前n小，我们比较当前元素与最大堆里的最大元素，如果它小于最大元素，则应该替换那个最大元素。这样最后得到的n个元素就是最小的n个。适合大数据量，求前n小，n的大小比较小的情况，这样可以扫描一遍即可得到所有的前n元素，效率很高。</p>
<p>扩展：双堆，一个最大堆与一个最小堆结合，可以用来维护中位数。</p>
<p>问题实例：<br>1)100w个数中找最大的前100个数。<br>用一个100个元素大小的最小堆即可。</p>
<h3 id="双层桶划分—-其实本质上就是【分而治之】的思想"><a href="#双层桶划分—-其实本质上就是【分而治之】的思想" class="headerlink" title="双层桶划分—-其实本质上就是【分而治之】的思想"></a>双层桶划分—-其实本质上就是【分而治之】的思想</h3><p>适用范围：第k大，中位数，不重复或重复的数字<br>基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。可以通过多次缩小，双层只是一个例子。</p>
<p>扩展：<br>问题实例：<br>1).2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。<br>有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</p>
<p>2).5亿个int找它们的中位数。<br>这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。</p>
<p>实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。</p>
<h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><p>适用范围：大数据量的增删改查</p>
<p>基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</p>
<h3 id="倒排索引-Inverted-index"><a href="#倒排索引-Inverted-index" class="headerlink" title="倒排索引(Inverted index)"></a>倒排索引(Inverted index)</h3><p>适用范围：搜索引擎，关键字查询</p>
<p>基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。</p>
<p>　以英文为例，下面是要被索引的文本：<br>T0 = “it is what it is”<br>T1 = “what is it”<br>T2 = “it is a banana”</p>
<p>我们就能得到下面的反向文件索引：</p>
<p>“a”:{2}<br>“banana”: {2}<br>“is”: {0, 1, 2}<br>“it”: {0, 1, 2}<br>“what”:   {0, 1}</p>
<p>　检索的条件”what”,”is”和”it”将对应集合的交集。</p>
<p>正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。</p>
<p>扩展：<br>问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。</p>
<h3 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h3><p>适用范围：大数据的排序，去重</p>
<p>基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树</p>
<p>扩展：</p>
<p>问题实例：<br>1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。</p>
<p>这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1m做hash有些不够，所以可以用来排序。内存可以当输入缓冲区使用。</p>
<h3 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h3><p>适用范围：数据量大，重复多，但是数据种类小可以放入内存</p>
<p>基本原理及要点：实现方式，节点孩子的表示方式</p>
<p>扩展：压缩实现。</p>
<p>问题实例：<br>1).有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。<br>2).1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？<br>3).寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。</p>
<h3 id="分布式处理-mapreduce"><a href="#分布式处理-mapreduce" class="headerlink" title="分布式处理 mapreduce"></a>分布式处理 mapreduce</h3><p>适用范围：数据量大，但是数据种类小可以放入内存</p>
<p>基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。</p>
<p>扩展：<br>问题实例：<br>1).The canonical example application of MapReduce is a process to count the appearances of<br>each different word in a set of documents:<br>2).海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。<br>3).一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？</p>
<p>经典问题分析<br>上千万or亿数据（有重复），统计其中出现次数最多的前N个数据,分两种情况：可一次读入内存，不可一次读入。</p>
<p>可用思路：trie树+堆，数据库索引，划分子集分别统计，hash，分布式计算，近似统计，外排序</p>
<p>所谓的是否能一次读入内存，实际上应该指去除重复后的数据量。如果去重后数据可以放入内存，我们可以为数据建立字典，比如通过 map，hashmap，trie，然后直接进行统计即可。当然在更新每条数据的出现次数的时候，我们可以利用一个堆来维护出现次数最多的前N个数据，当然这样导致维护次数增加，不如完全统计后在求前N大效率高。</p>
<p>如果数据无法放入内存。一方面我们可以考虑上面的字典方法能否被改进以适应这种情形，可以做的改变就是将字典存放到硬盘上，而不是内存，这可以参考数据库的存储方法。</p>
<p>当然还有更好的方法，就是可以采用分布式计算，基本上就是map-reduce过程，首先可以根据数据值或者把数据hash(md5)后的值，将数据按照范围划分到不同的机子，最好可以让数据划分后可以一次读入内存，这样不同的机子负责处理各种的数值范围，实际上就是map。得到结果后，各个机子只需拿出各自的出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是reduce过程。</p>
<p>实际上可能想直接将数据均分到不同的机子上进行处理，这样是无法得到正确的解的。因为一个数据可能被均分到不同的机子上，而另一个则可能完全聚集到一个机子上，同时还可能存在具有相同数目的数据。比如我们要找出现次数最多的前100个，我们将1000万的数据分布到10台机器上，找到每台出现次数最多的前 100个，归并之后这样不能保证找到真正的第100个，因为比如出现次数最多的第100个可能有1万个，但是它被分到了10台机子，这样在每台上只有1千个，假设这些机子排名在1000个之前的那些都是单独分布在一台机子上的，比如有1001个，这样本来具有1万个的这个就会被淘汰，即使我们让每台机子选出出现次数最多的1000个再归并，仍然会出错，因为可能存在大量个数为1001个的发生聚集。因此不能将数据随便均分到不同机子上，而是要根据hash 后的值将它们映射到不同的机子上处理，让不同的机器处理一个数值范围。</p>
<p>　 而外排序的方法会消耗大量的IO，效率不会很高。而上面的分布式方法，也可以用于单机版本，也就是将总的数据根据值的范围，划分成多个不同的子文件，然后逐个处理。处理完毕之后再对这些单词的及其出现频率进行一个归并。实际上就可以利用一个外排序的归并过程。</p>
<p>　 另外还可以考虑近似计算，也就是我们可以通过结合自然语言属性，只将那些真正实际中出现最多的那些词作为一个字典，使得这个规模可以放入内存。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[海量数据处理]]></title>
      <url>http://yoursite.com/2015/09/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>作者：July、youwang、yanxionglu。<br>出处：<a href="http://blog.csdn.net/v_JULY_v。" target="_blank" rel="external">http://blog.csdn.net/v_JULY_v。</a></p>
<h2 id="十道海量数据处理面试题"><a href="#十道海量数据处理面试题" class="headerlink" title="十道海量数据处理面试题"></a>十道海量数据处理面试题</h2><ul>
<li>提取出某日访问百度次数最多的那个IP。</li>
</ul>
<p>首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。<br>或者如下阐述（雪域之鹰）：<br>算法思想：分而治之+Hash<br>1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理；<br>2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址；<br>3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址；<br>4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；</p>
<ul>
<li>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。<br>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</li>
</ul>
<p>典型的Top K算法，还是在这篇文章里头有所阐述，详情请参见：十一、从头到尾彻底解析Hash表算法。<br>文中，给出的最终算法是：<br>第一步、先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计（之前写成了排序，特此订正。July、2011.04.27）；<br>第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。<br>  即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N’*O（logK），（N为1000万，N’为300万）。ok，更多，详情，请参考原文。<br>或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p>
<ul>
<li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</li>
</ul>
<p>方案：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。<br>如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。<br>对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。</p>
<ul>
<li>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</li>
</ul>
<p>还是典型的TOP K算法，解决方案如下：<br>方案1：<br>顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。<br>找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。<br>对这10个文件进行归并排序（内排序与外排序相结合）。<br>方案2：<br> 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。<br>方案3：<br>与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p>
<ul>
<li>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</li>
</ul>
<p>方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。<br>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。<br>遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。<br>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。<br>方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</p>
<ul>
<li>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</li>
</ul>
<p>方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p>
<p>方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。</p>
<ul>
<li>腾讯面试题：给40亿个不重复的unsigned </li>
</ul>
<p>int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</p>
<p>与上第6题类似，我的第一反应时快速排序+二分查找。以下是其它更好的方法：<br>方案1：oo，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p>
<p>dizengrong：<br>方案2：这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下：<br>又因为2^32为40亿多，所以给定一个数可能在，也可能不在其中；<br>这里我们把40亿个数中的每一个用32位的二进制来表示<br>假设这40亿个数开始放在一个文件中。</p>
<p>然后将这40亿个数分成两类:<br>1.最高位为0<br>2.最高位为1<br>并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=20亿，而另一个&gt;=20亿（这相当于折半了）；<br>与要查找的数的最高位比较并接着进入相应的文件再查找</p>
<p>再然后把这个文件为又分成两类:<br>1.次最高位为0<br>2.次最高位为1</p>
<p>并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=10亿，而另一个&gt;=10亿（这相当于折半了）；<br>与要查找的数的次最高位比较并接着进入相应的文件再查找。<br>…….<br>以此类推，就可以找到了,而且时间复杂度为O(logn)，方案2完。</p>
<p>附：这里，再简单介绍下，位图方法：<br>使用位图法判断整形数组是否存在重复<br>判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。</p>
<p>位图法比较适合于这种情况，它的做法是按照集合中最大元素max创建一个长度为max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上1，如遇到5就给新数组的第六个元素置1，这样下次再遇到5想置位时发现新数组的第六个元素已经是1了，这说明这次的数据肯定和以前的数据存在着重复。这种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为2N。如果已知数组的最大值即能事先给新数组定长的话效率还能提高一倍。</p>
<ul>
<li>怎么在海量数据中找出重复次数最多的一个？</li>
</ul>
<p>方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p>
<ul>
<li>上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。</li>
</ul>
<p>方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第2题提到的堆机制完成。</p>
<ul>
<li>一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</li>
</ul>
<p>方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n</em>lg10)。所以总的时间复杂度，是O(n<em>le)与O(n</em>lg10)中较大的哪一个。</p>
<ul>
<li>100w个数中找出最大的100个数。</li>
</ul>
<p>方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。</p>
<p>方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。</p>
<p>方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。</p>
<p>致谢：<a href="http://www.cnblogs.com/youwang/。" target="_blank" rel="external">http://www.cnblogs.com/youwang/。</a></p>
<p>##十个海量数据处理方法大总结</p>
<p>下面的方法全部来自<a href="http://hi.baidu.com/yanxionglu/blog/博客，对海量数据的处理方法进行了一个一般性的总结，当然这些方法可能并不能完全覆盖所有的问题，但是这样的一些方法也基本可以处理绝大多数遇到的问题。下面的一些问题基本直接来源于公司的面试笔试题目，方法不一定最优，如果你有更好的处理方法，欢迎讨论。" target="_blank" rel="external">http://hi.baidu.com/yanxionglu/blog/博客，对海量数据的处理方法进行了一个一般性的总结，当然这些方法可能并不能完全覆盖所有的问题，但是这样的一些方法也基本可以处理绝大多数遇到的问题。下面的一些问题基本直接来源于公司的面试笔试题目，方法不一定最优，如果你有更好的处理方法，欢迎讨论。</a></p>
<h3 id="Bloom-filter"><a href="#Bloom-filter" class="headerlink" title="Bloom filter"></a>Bloom filter</h3><p>适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集</p>
<h3 id="基本原理及要点："><a href="#基本原理及要点：" class="headerlink" title="基本原理及要点："></a>基本原理及要点：</h3><p>对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。</p>
<p>还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)<em>(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于n</em>lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。</p>
<p>举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。</p>
<p>注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。</p>
<p>扩展：<br>Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。</p>
<p>问题实例：给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？</p>
<p>根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。</p>
<h3 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h3><p>适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存</p>
<p>基本原理及要点：<br>hash函数选择，针对字符串，整数，排列，具体相应的hash方法。<br>碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。</p>
<p>扩展：<br>d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。</p>
<p>问题实例：<br>1).海量日志数据，提取出某日访问百度次数最多的那个IP。<br>IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。</p>
<h3 id="bit-map"><a href="#bit-map" class="headerlink" title="bit-map"></a>bit-map</h3><p>适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下</p>
<p>基本原理及要点：使用bit数组来表示某些元素是否存在，比如8位电话号码</p>
<p>扩展：bloom filter可以看做是对bit-map的扩展</p>
<p>问题实例：<br>1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。<br>8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。<br>2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p>
<p>将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>适用范围：海量数据前n大，并且n比较小，堆可以放入内存</p>
<p>基本原理及要点：最大堆求前n小，最小堆求前n大。方法，比如求前n小，我们比较当前元素与最大堆里的最大元素，如果它小于最大元素，则应该替换那个最大元素。这样最后得到的n个元素就是最小的n个。适合大数据量，求前n小，n的大小比较小的情况，这样可以扫描一遍即可得到所有的前n元素，效率很高。</p>
<p>扩展：双堆，一个最大堆与一个最小堆结合，可以用来维护中位数。</p>
<p>问题实例：<br>1)100w个数中找最大的前100个数。<br>用一个100个元素大小的最小堆即可。</p>
<h3 id="双层桶划分—-其实本质上就是【分而治之】的思想"><a href="#双层桶划分—-其实本质上就是【分而治之】的思想" class="headerlink" title="双层桶划分—-其实本质上就是【分而治之】的思想"></a>双层桶划分—-其实本质上就是【分而治之】的思想</h3><p>适用范围：第k大，中位数，不重复或重复的数字<br>基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。可以通过多次缩小，双层只是一个例子。</p>
<p>扩展：<br>问题实例：<br>1).2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。<br>有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</p>
<p>2).5亿个int找它们的中位数。<br>这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。</p>
<p>实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。</p>
<h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><p>适用范围：大数据量的增删改查</p>
<p>基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</p>
<h3 id="倒排索引-Inverted-index"><a href="#倒排索引-Inverted-index" class="headerlink" title="倒排索引(Inverted index)"></a>倒排索引(Inverted index)</h3><p>适用范围：搜索引擎，关键字查询</p>
<p>基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。</p>
<p>　以英文为例，下面是要被索引的文本：<br>T0 = “it is what it is”<br>T1 = “what is it”<br>T2 = “it is a banana”</p>
<p>我们就能得到下面的反向文件索引：</p>
<p>“a”:{2}<br>“banana”: {2}<br>“is”: {0, 1, 2}<br>“it”: {0, 1, 2}<br>“what”:   {0, 1}</p>
<p>　检索的条件”what”,”is”和”it”将对应集合的交集。</p>
<p>正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。</p>
<p>扩展：<br>问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。</p>
<h3 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h3><p>适用范围：大数据的排序，去重</p>
<p>基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树</p>
<p>扩展：</p>
<p>问题实例：<br>1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。</p>
<p>这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1m做hash有些不够，所以可以用来排序。内存可以当输入缓冲区使用。</p>
<h3 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h3><p>适用范围：数据量大，重复多，但是数据种类小可以放入内存</p>
<p>基本原理及要点：实现方式，节点孩子的表示方式</p>
<p>扩展：压缩实现。</p>
<p>问题实例：<br>1).有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。<br>2).1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？<br>3).寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。</p>
<h3 id="分布式处理-mapreduce"><a href="#分布式处理-mapreduce" class="headerlink" title="分布式处理 mapreduce"></a>分布式处理 mapreduce</h3><p>适用范围：数据量大，但是数据种类小可以放入内存</p>
<p>基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。</p>
<p>扩展：<br>问题实例：<br>1).The canonical example application of MapReduce is a process to count the appearances of<br>each different word in a set of documents:<br>2).海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。<br>3).一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？</p>
<p>经典问题分析<br>上千万or亿数据（有重复），统计其中出现次数最多的前N个数据,分两种情况：可一次读入内存，不可一次读入。</p>
<p>可用思路：trie树+堆，数据库索引，划分子集分别统计，hash，分布式计算，近似统计，外排序</p>
<p>所谓的是否能一次读入内存，实际上应该指去除重复后的数据量。如果去重后数据可以放入内存，我们可以为数据建立字典，比如通过 map，hashmap，trie，然后直接进行统计即可。当然在更新每条数据的出现次数的时候，我们可以利用一个堆来维护出现次数最多的前N个数据，当然这样导致维护次数增加，不如完全统计后在求前N大效率高。</p>
<p>如果数据无法放入内存。一方面我们可以考虑上面的字典方法能否被改进以适应这种情形，可以做的改变就是将字典存放到硬盘上，而不是内存，这可以参考数据库的存储方法。</p>
<p>当然还有更好的方法，就是可以采用分布式计算，基本上就是map-reduce过程，首先可以根据数据值或者把数据hash(md5)后的值，将数据按照范围划分到不同的机子，最好可以让数据划分后可以一次读入内存，这样不同的机子负责处理各种的数值范围，实际上就是map。得到结果后，各个机子只需拿出各自的出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是reduce过程。</p>
<p>实际上可能想直接将数据均分到不同的机子上进行处理，这样是无法得到正确的解的。因为一个数据可能被均分到不同的机子上，而另一个则可能完全聚集到一个机子上，同时还可能存在具有相同数目的数据。比如我们要找出现次数最多的前100个，我们将1000万的数据分布到10台机器上，找到每台出现次数最多的前 100个，归并之后这样不能保证找到真正的第100个，因为比如出现次数最多的第100个可能有1万个，但是它被分到了10台机子，这样在每台上只有1千个，假设这些机子排名在1000个之前的那些都是单独分布在一台机子上的，比如有1001个，这样本来具有1万个的这个就会被淘汰，即使我们让每台机子选出出现次数最多的1000个再归并，仍然会出错，因为可能存在大量个数为1001个的发生聚集。因此不能将数据随便均分到不同机子上，而是要根据hash 后的值将它们映射到不同的机子上处理，让不同的机器处理一个数值范围。</p>
<p>　 而外排序的方法会消耗大量的IO，效率不会很高。而上面的分布式方法，也可以用于单机版本，也就是将总的数据根据值的范围，划分成多个不同的子文件，然后逐个处理。处理完毕之后再对这些单词的及其出现频率进行一个归并。实际上就可以利用一个外排序的归并过程。</p>
<p>　 另外还可以考虑近似计算，也就是我们可以通过结合自然语言属性，只将那些真正实际中出现最多的那些词作为一个字典，使得这个规模可以放入内存。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大数据（一）]]></title>
      <url>http://yoursite.com/2015/09/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>转载自<br>海量数据处理：十道面试题与十个海量数据处理方法总结<br>作者：July、youwang、yanxionglu</p>
<h2 id="何谓海量数据处理？"><a href="#何谓海量数据处理？" class="headerlink" title="何谓海量数据处理？"></a>何谓海量数据处理？</h2><p>所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。<br>那解决办法呢?针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom filter/Hash/bit-map/堆/数据库或倒排索引/trie树，针对空间，无非就一个办法：大而化小，分而治之（hash映射），你不是说规模太大嘛，那简单啊，就把规模大化为规模小的，各个击破不就完了嘛。<br>至于所谓的单机及集群问题，通俗点来讲，单机就是处理装载数据的机器有限(只要考虑cpu，内存，硬盘的数据交互)，而集群，机器有多辆，适合分布式处理，并行计算(更多考虑节点和节点间的数据交互)。<br>再者，通过本blog内的有关海量数据处理的文章：Big Data Processing，我们已经大致知道，处理海量数据问题，无非就是：</p>
<p>分而治之/hash映射 + hash统计 + 堆/快速/归并排序；<br>双层桶划分<br>Bloom filter/Bitmap；<br>Trie树/数据库/倒排索引；<br>外排序；<br>分布式处理之Hadoop/Mapreduce。</p>
<p>从set/map谈到hashtable/hash_map/hash_set<br>稍后本文第二部分中将多次提到hash_map/hash_set，下面稍稍介绍下这些容器，以作为基础准备。一般来说，STL容器分两种，<br>序列式容器(vector/list/deque/stack/queue/heap)，<br>关联式容器。关联式容器又分为set(集合)和map(映射表)两大类，以及这两大类的衍生体multiset(多键集合)和multimap(多键映射表)，这些容器均以RB-tree完成。此外，还有第3类关联式容器，如hashtable(散列表)，以及以hashtable为底层机制完成的hash_set(散列集合)/hash_map(散列映射表)/hash_multiset(散列多键集合)/hash_multimap(散列多键映射表)。也就是说，set/map/multiset/multimap都内含一个RB-tree，而hash_set/hash_map/hash_multiset/hash_multimap都内含一个hashtable。<br>所谓关联式容器，类似关联式数据库，每笔数据或每个元素都有一个键值(key)和一个实值(value)，即所谓的Key-Value(键-值对)。当元素被插入到关联式容器中时，容器内部结构(RB-tree/hashtable)便依照其键值大小，以某种特定规则将这个元素放置于适当位置。</p>
<p> 包括在非关联式数据库中，比如，在MongoDB内，文档(document)是最基本的数据组织形式，每个文档也是以Key-Value（键-值对）的方式组织起来。一个文档可以有多个Key-Value组合，每个Value可以是不同的类型，比如String、Integer、List等等。<br>{ “name” : “July”,<br>  “sex” : “male”,<br>“age” : 23 }  </p>
<p>set/map/multiset/multimap<br>set，同map一样，所有元素都会根据元素的键值自动被排序，因为set/map两者的所有各种操作，都只是转而调用RB-tree的操作行为，不过，值得注意的是，两者都不允许两个元素有相同的键值。<br>不同的是：set的元素不像map那样可以同时拥有实值(value)和键值(key)，set元素的键值就是实值，实值就是键值，而map的所有元素都是pair，同时拥有实值(value)和键值(key)，pair的第一个元素被视为键值，第二个元素被视为实值。<br>至于multiset/multimap，他们的特性及用法和set/map完全相同，唯一的差别就在于它们允许键值重复，即所有的插入操作基于RB-tree的insert_equal()而非insert_unique()。</p>
<p>hash_set/hash_map/hash_multiset/hash_multimap<br>hash_set/hash_map，两者的一切操作都是基于hashtable之上。不同的是，hash_set同set一样，同时拥有实值和键值，且实质就是键值，键值就是实值，而hash_map同map一样，每一个元素同时拥有一个实值(value)和一个键值(key)，所以其使用方式，和上面的map基本相同。但由于hash_set/hash_map都是基于hashtable之上，所以不具备自动排序功能。为什么?因为hashtable没有自动排序功能。<br>至于hash_multiset/hash_multimap的特性与上面的multiset/multimap完全相同，唯一的差别就是它们hash_multiset/hash_multimap的底层实现机制是hashtable（而multiset/multimap，上面说了，底层实现机制是RB-tree），所以它们的元素都不会被自动排序，不过也都允许键值重复。<br>所以，综上，说白了，什么样的结构决定其什么样的性质，因为set/map/multiset/multimap都是基于RB-tree之上，所以有自动排序功能，而hash_set/hash_map/hash_multiset/hash<em>multimap都是基于hashtable之上，所以不含有自动排序功能，至于加个前缀multi</em>无非就是允许键值重复而已。<br>此外，<br>关于什么hash，请看blog内此篇文章；<br>关于红黑树，请参看blog内系列文章，<br>关于hash_map的具体应用：请看这里，关于hash_set：请看此文。<br>OK，接下来，请看本文第二部分、处理海量数据问题之六把密匙。</p>
<h4 id="密钥一-分而治之"><a href="#密钥一-分而治之" class="headerlink" title="密钥一 分而治之"></a>密钥一 分而治之</h4><p>分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序<br>海量日志数据，提取出某日访问百度次数最多的那个IP。<br>既然是海量数据处理，那么可想而知，给我们的数据那就一定是海量的。针对这个数据的海量，我们如何着手呢?对的，无非就是分而治之/hash映射 + hash统计 + 堆/快速/归并排序，说白了，就是先映射，而后统计，最后排序：<br>分而治之/hash映射：针对数据太大，内存受限，只能是：把大文件化成(取模映射)小文件，即16字方针：大而化小，各个击破，缩小规模，逐个解决<br>hash_map统计：当大文件转化了小文件，那么我们便可以采用常规的hash_map(ip，value)来进行频率统计。<br>堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。<br>具体而论，则是： “首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如%1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map对那1000个文件中的所有IP进行频率统计，然后依次找出各个文件中频率最大的那个IP）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。”–十道海量数据处理面试题与十个方法大总结。</p>
<p>关于本题，还有几个问题，如下：</p>
<p>Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中的情况，即这里采用的是mod1000算法，那么相同的IP在hash取模后，只可能落在同一个文件中，不可能被分散的。因为如果两个IP相等，那么经过Hash(IP)之后的哈希值是相同的，将此哈希值取模（如模1000），必定仍然相等。<br>那到底什么是hash映射呢？简单来说，就是为了便于计算机在有限的内存中处理big数据，从而通过一种映射散列的方式让数据均匀分布在对应的内存位置(如大数据通过取余的方式映射成小树存放在内存中，或大文件映射成多个小文件)，而这个映射散列方式便是我们通常所说的hash函数，设计的好的hash函数能让数据均匀分布而减少冲突。尽管数据映射到了另外一些不同的位置，但数据还是原来的数据，只是代替和表示这些原始数据的形式发生了变化而已。<br>OK，有兴趣的，还可以再了解下一致性hash算法，见blog内此文第五部分：<a href="http://blog.csdn.net/v_july_v/article/details/6879101。" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6879101。</a></p>
<ul>
<li>寻找热门查询，300万个查询字符串中统计最热门的10个查询</li>
</ul>
<p>原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p>解答：由上面第1题，我们知道，数据大则划为小的，如如一亿个Ip求Top 10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结。<br>但如果数据规模比较小，能一次性装入内存呢?比如这第2题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去（300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理），而现在只是需要一个合适的数据结构，在这里，HashTable绝对是我们优先的选择。<br>所以我们放弃分而治之/hash映射的步骤，直接上hash统计，然后排序。So，针对此类典型的TOP K问题，采取的对策往往是：hashmap + 堆。如下所示：</p>
<p>hash_map统计：先对这批海量数据预处理。具体方法是：维护一个Key为Query字串，Value为该Query出现次数的HashTable，即hash_map(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计；<br>堆排序：第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是：O（N） + N’ <em> O（logK），（N为1000万，N’为300万）。<br>别忘了这篇文章中所述的堆排序思路：“维护k个元素的最小堆，即用容量为k的最小堆存储最先遍历到的k个数，并假设它们即是最大的k个数，建堆费时O（k），并调整堆(费时O（logk）)后，有k1&gt;k2&gt;…kmin（kmin设为小顶堆中最小元素）。继续遍历数列，每次遍历一个元素x，与堆顶元素比较，若x&gt;kmin，则更新堆（x入堆，用时logk），否则不更新堆。这样下来，总费时O（k</em>logk+（n-k）<em>logk）=O（n</em>logk）。此方法得益于在堆中，查找等各项操作时间复杂度均为logk。”–第三章续、Top K算法问题的实现。<br>当然，你也可以采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p>
<ul>
<li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。<br>由上面那两个例题，分而治之 + hash统计 + 堆/快速排序这个套路，我们已经开始有了屡试不爽的感觉。下面，再拿几道再多多验证下。请看此第3题：又是文件很大，又是内存受限，咋办?还能怎么办呢?无非还是：</li>
</ul>
<p>分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。<br>hash_map统计：对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。<br>堆/归并排序：取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。</p>
<ul>
<li>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。<br>如果每个数据元素只出现一次，而且只出现在某一台机器中，那么可以采取以下步骤统计出现次数TOP10的数据元素：<br>堆排序：在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆，比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大）。<br>求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。<br>但如果同一个元素重复出现在不同的电脑中呢，如下例子所述：</li>
</ul>
<p>这个时候，你可以有两种方法：<br>遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，统计每台电脑中各个元素的出现次数找出TOP10，继而组合100台电脑上的TOP10，找出最终的TOP10。<br>或者，暴力求解：直接统计统计每台电脑中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出TOP10。</p>
<ul>
<li><p>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。<br>方案1：直接上：<br>hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为a0,a1,..a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。<br>hash_map统计：找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。<br>堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序，将排序好的query和对应的query_cout输出到文件中，这样得到了10个排好序的文件（记为）。最后，对这10个文件进行归并排序（内排序与外排序相结合）。根据此方案1，这里有一份实现：<a href="https://github.com/ooooola/sortquery/blob/master/querysort.py。" target="_blank" rel="external">https://github.com/ooooola/sortquery/blob/master/querysort.py。</a><br>除此之外，此题还有以下两个方法：<br>方案2：一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。<br>方案3：与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p>
</li>
<li><p>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？<br>可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p>
</li>
</ul>
<p>分而治之/hash映射：遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为，这里漏写个了a1）中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。<br>hash_set统计：求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。<br>OK，此第一种方法：分而治之/hash映射 + hash统计 + 堆/快速/归并排序，再看最后4道题，如下：</p>
<ul>
<li>怎么在海量数据中找出重复次数最多的一个？</li>
</ul>
<p>方案：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p>
<ul>
<li>上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</li>
</ul>
<p>方案：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后利用堆取出前N个出现次数最多的数据。</p>
<p>一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</p>
<p>方案1：如果文件比较大，无法一次性读入内存，可以采用hash取模的方法，将大文件分解为多个小文件，对于单个小文件利用hash_map统计出每个小文件中10个最常出现的词，然后再进行归并处理，找出最终的10个最常出现的词。<br>方案2：通过hash取模将大文件分解为多个小文件后，除了可以用hash_map统计出每个小文件中10个最常出现的词，也可以用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平准长度），最终同样找出出现最频繁的前10个词（可用堆来实现），时间复杂度是O(n</em>lg10)。</p>
<ul>
<li>1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？</li>
</ul>
<p>方案1：这题用trie树比较合适，hash_map也行。<br>方案2：from xjbzju:，1000w的数据规模插入操作完全不现实，以前试过在stl下100w元素插入set中已经慢得不能忍受，觉得基于hash的实现不会比红黑树好太多，使用vector+sort+unique都要可行许多，建议还是先hash成小文件分开处理再综合。<br>上述方案2中读者xbzju的方法让我想到了一些问题，即是set/map，与hash_set/hash_map的性能比较?共计3个问题，如下：<br>1、hash_set在千万级数据下，insert操作优于set? 这位blog：<a href="http://t.cn/zOibP7t" target="_blank" rel="external">http://t.cn/zOibP7t</a> 给的实践数据可靠不?<br>2、那map和hash_map的性能比较呢? 谁做过相关实验?</p>
<p>3、那查询操作呢，如下段文字所述?</p>
<p>或者小数据量时用map，构造快，大数据量时用hash_map?</p>
<p>rbtree PK hashtable</p>
<p>据朋友№邦卡猫№的做的红黑树和hash table的性能测试中发现：当数据量基本上int型key时，hash table是rbtree的3-4倍，但hash table一般会浪费大概一半内存。</p>
<p>因为hash table所做的运算就是个%，而rbtree要比较很多，比如rbtree要看value的数据 ，每个节点要多出3个指针（或者偏移量） 如果需要其他功能，比如，统计某个范围内的key的数量，就需要加一个计数成员。<br>且1s rbtree能进行大概50w+次插入，hash table大概是差不多200w次。不过很多的时候，其速度可以忍了，例如倒排索引差不多也是这个速度，而且单线程，且倒排表的拉链长度不会太大。正因为基于树的实现其实不比hashtable慢到哪里去，所以数据库的索引一般都是用的B/B+树，而且B+树还对磁盘友好(B树能有效降低它的高度，所以减少磁盘交互次数)。比如现在非常流行的NoSQL数据库，像MongoDB也是采用的B树索引。关于B树系列，请参考本blog内此篇文章：从B树、B+树、B*树谈到R 树。更多请待后续实验论证。</p>
<ul>
<li><p>一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。<br>方案1：首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。</p>
</li>
<li><p>100w个数中找出最大的100个数。<br>方案1：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w<em>100)。<br>方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w</em>100)。<br>方案3：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。<br>接下来，咱们来看第二种方法，双层捅划分。</p>
</li>
</ul>
<h4 id="密匙二、多层划分"><a href="#密匙二、多层划分" class="headerlink" title="密匙二、多层划分"></a>密匙二、多层划分</h4><p>多层划分—-其实本质上还是分而治之的思想，重在“分”的技巧上！<br>适用范围：第k大，中位数，不重复或重复的数字<br>基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。</p>
<p>问题实例：</p>
<ul>
<li>2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。<br>有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</li>
<li>5亿个int找它们的中位数。<br>思路一：这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。<br>实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。<br>思路二@绿色夹克衫：同样需要做两遍统计，如果数据存在硬盘上，就需要读取2次。<br>方法同基数排序有些像，开一个大小为65536的Int数组，第一遍读取，统计Int32的高16位的情况，也就是0-65535，都算作0,65536 - 131071都算作1。就相当于用该数除以65536。Int32 除以 65536的结果不会超过65536种情况，因此开一个长度为65536的数组计数就可以。每读取一个数，数组中对应的计数+1，考虑有负数的情况，需要将结果加32768后，记录在相应的数组内。<br>第一遍统计之后，遍历数组，逐个累加统计，看中位数处于哪个区间，比如处于区间k，那么0- k-1的区间里数字的数量sum应该&lt;n/2（2.5亿）。而k+1 - 65535的计数和也&lt;n/2，第二遍统计同上面的方法类似，但这次只统计处于区间k的情况，也就是说(x / 65536) + 32768 = k。统计只统计低16位的情况。并且利用刚才统计的sum，比如sum = 2.49亿，那么现在就是要在低16位里面找100万个数(2.5亿-2.49亿)。这次计数之后，再统计一下，看中位数所处的区间，最后将高位和低位组合一下就是结果了。</li>
</ul>
<h4 id="密匙三：Bloom-filter-Bitmap"><a href="#密匙三：Bloom-filter-Bitmap" class="headerlink" title="密匙三：Bloom filter/Bitmap"></a>密匙三：Bloom filter/Bitmap</h4><p>Bloom filter<br>关于什么是Bloom filter，请参看blog内此文：</p>
<p>海量数据处理之Bloom Filter详解<br>适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集<br>基本原理及要点：<br>对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。<br>还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)<em>(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于n</em>lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。<br>举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。<br>注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。</p>
<p>扩展：<br>Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。</p>
<p>可以看下上文中的第6题：</p>
<p>“6、给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？</p>
<p>根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。</p>
<p>同时，上文的第5题：给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。”</p>
<p>Bitmap<br>关于什么是Bitmap，请看blog内此文第二部分：<a href="http://blog.csdn.net/v_july_v/article/details/6685962。" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6685962。</a><br>下面关于Bitmap的应用，可以看下上文中的第13题，以及另外一道新题：</p>
<p>“13、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</p>
<p>方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。<br>方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。”</p>
<p>15、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？<br>方案1：frome oo，用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p>
<h4 id="密匙四、Trie树-数据库-倒排索引"><a href="#密匙四、Trie树-数据库-倒排索引" class="headerlink" title="密匙四、Trie树/数据库/倒排索引"></a>密匙四、Trie树/数据库/倒排索引</h4><p>Trie树</p>
<p>适用范围：数据量大，重复多，但是数据种类小可以放入内存<br>基本原理及要点：实现方式，节点孩子的表示方式<br>扩展：压缩实现。<br>问题实例：</p>
<p>上面的第2题：寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。<br>上面的第5题：有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。<br>1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？<br>上面的第8题：一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词。其解决方法是：用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度），然后是找出出现最频繁的前10个词。<br>更多有关Trie树的介绍，请参见此文：从Trie树（字典树）谈到后缀树。</p>
<p>数据库索引<br>适用范围：大数据量的增删改查<br>基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</p>
<p>关于数据库索引及其优化，更多可参见此文：<a href="http://www.cnblogs.com/pkuoliver/archive/2011/08/17/mass-data-topic-7-index-and-optimize.html；" target="_blank" rel="external">http://www.cnblogs.com/pkuoliver/archive/2011/08/17/mass-data-topic-7-index-and-optimize.html；</a><br>关于MySQL索引背后的数据结构及算法原理，这里还有一篇很好的文章：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html；" target="_blank" rel="external">http://blog.codinglabs.org/articles/theory-of-mysql-index.html；</a><br>关于B 树、B+ 树、B* 树及R 树，本blog内有篇绝佳文章：<a href="http://blog.csdn.net/v_JULY_v/article/details/6530142。" target="_blank" rel="external">http://blog.csdn.net/v_JULY_v/article/details/6530142。</a><br>倒排索引(Inverted index)<br>适用范围：搜索引擎，关键字查询<br>基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。<br>　以英文为例，下面是要被索引的文本：<br>T0 = “it is what it is”<br>T1 = “what is it”<br>T2 = “it is a banana”<br>我们就能得到下面的反向文件索引：<br>“a”:{2}<br>“banana”: {2}<br>“is”: {0, 1, 2}<br>“it”: {0, 1, 2}<br>“what”:{0, 1}<br>　检索的条件”what”,”is”和”it”将对应集合的交集。</p>
<p>正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。<br>扩展：<br>问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。</p>
<p>关于倒排索引的应用，更多请参见：</p>
<p>第二十三、四章：杨氏矩阵查找，倒排索引关键词Hash不重复编码实践，<br>第二十六章：基于给定的文档生成倒排索引的编码与实践。</p>
<h4 id="密匙五、外排序"><a href="#密匙五、外排序" class="headerlink" title="密匙五、外排序"></a>密匙五、外排序</h4><p>适用范围：大数据的排序，去重<br>基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树<br>问题实例：<br>1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。<br>这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1M做hash明显不够，所以可以用来排序。内存可以当输入缓冲区使用。</p>
<p>关于多路归并算法及外排序的具体应用场景，请参见blog内此文：</p>
<p>第十章、如何给10^7个数据量的磁盘文件排序</p>
<h4 id="密匙六、分布式处理之Mapreduce"><a href="#密匙六、分布式处理之Mapreduce" class="headerlink" title="密匙六、分布式处理之Mapreduce"></a>密匙六、分布式处理之Mapreduce</h4><p>MapReduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。但如果你要我再通俗点介绍，那么，说白了，Mapreduce的原理就是一个归并排序。</p>
<p>适用范围：数据量大，但是数据种类小可以放入内存<br>基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。<br>问题实例：</p>
<p>The canonical example application of MapReduce is a process to count the appearances of each different word in a set of documents:<br>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。<br>一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？<br>更多具体阐述请参见blog内：</p>
<p>从Hadhoop框架与MapReduce模式中谈海量数据处理，<br>及MapReduce技术的初步了解与学习。<br>其它模式/方法论，结合操作系统知识<br>至此，六种处理海量数据问题的模式/方法已经阐述完毕。据观察，这方面的面试题无外乎以上一种或其变形，然题目为何取为是：秒杀99%的海量数据处理面试题，而不是100%呢。OK，给读者看最后一道题，如下：<br>非常大的文件，装不进内存。每行一个int类型数据，现在要你随机取100个数。<br>我们发现上述这道题，无论是以上任何一种模式/方法都不好做，那有什么好的别的方法呢？我们可以看看：操作系统内存分页系统设计(说白了，就是映射+建索引)。<br>Windows 2000使用基于分页机制的虚拟内存。每个进程有4GB的虚拟地址空间。基于分页机制，这4GB地址空间的一些部分被映射了物理内存，一些部分映射硬盘上的交换文 件，一些部分什么也没有映射。程序中使用的都是4GB地址空间中的虚拟地址。而访问物理内存，需要使用物理地址。 关于什么是物理地址和虚拟地址，请看：<br>物理地址 (physical address): 放在寻址总线上的地址。放在寻址总线上，如果是读，电路根据这个地址每位的值就将相应地址的物理内存中的数据放到数据总线中传输。如果是写，电路根据这个 地址每位的值就将相应地址的物理内存中放入数据总线上的内容。物理内存是以字节(8位)为单位编址的。<br>虚拟地址 (virtual address): 4G虚拟地址空间中的地址，程序中使用的都是虚拟地址。 使用了分页机制之后，4G的地址空间被分成了固定大小的页，每一页或者被映射到物理内存，或者被映射到硬盘上的交换文件中，或者没有映射任何东西。对于一 般程序来说，4G的地址空间，只有一小部分映射了物理内存，大片大片的部分是没有映射任何东西。物理内存也被分页，来映射地址空间。对于32bit的 Win2k，页的大小是4K字节。CPU用来把虚拟地址转换成物理地址的信息存放在叫做页目录和页表的结构里。<br>物理内存分页，一个物理页的大小为4K字节，第0个物理页从物理地址 0x00000000 处开始。由于页的大小为4KB，就是0x1000字节，所以第1页从物理地址 0x00001000 处开始。第2页从物理地址 0x00002000 处开始。可以看到由于页的大小是4KB，所以只需要32bit的地址中高20bit来寻址物理页。<br>返回上面我们的题目：非常大的文件，装不进内存。每行一个int类型数据，现在要你随机取100个数。针对此题，我们可以借鉴上述操作系统中内存分页的设计方法，做出如下解决方案：<br>操作系统中的方法，先生成4G的地址表，在把这个表划分为小的4M的小文件做个索引，二级索引。30位前十位表示第几个4M文件，后20位表示在这个4M文件的第几个，等等，基于key value来设计存储，用key来建索引。</p>
<p>但如果现在只有10000个数，然后怎么去随机从这一万个数里面随机取100个数？请读者思考。更多海里数据处理面试题，请参见此文第一部分：<a href="http://blog.csdn.net/v_july_v/article/details/6685962。" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6685962。</a></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>十道海量数据处理面试题与十个方法大总结；<br>海量数据处理面试题集锦与Bit-map详解；<br>十一、从头到尾彻底解析Hash表算法；<br>海量数据处理之Bloom Filter详解；<br>从Trie树（字典树）谈到后缀树；<br>第三章续、Top K算法问题的实现；<br>第十章、如何给10^7个数据量的磁盘文件排序；<br>从B树、B+树、B*树谈到R 树；<br>第二十三、四章：杨氏矩阵查找，倒排索引关键词Hash不重复编码实践；<br>第二十六章：基于给定的文档生成倒排索引的编码与实践；<br>从Hadhoop框架与MapReduce模式中谈海量数据处理；<br>第十六~第二十章：全排列，跳台阶，奇偶排序，第一个只出现一次等问题；<br><a href="http://blog.csdn.net/v_JULY_v/article/category/774945；" target="_blank" rel="external">http://blog.csdn.net/v_JULY_v/article/category/774945；</a><br>STL源码剖析第五章，侯捷著；<br>2012百度实习生招聘笔试题：<a href="http://blog.csdn.net/hackbuteer1/article/details/7542774。" target="_blank" rel="external">http://blog.csdn.net/hackbuteer1/article/details/7542774。</a></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>经过上面这么多海量数据处理面试题的轰炸，我们依然可以看出这类问题是有一定的解决方案/模式的，所以，不必将其神化。然这类面试题所包含的问题还是比较简单的，若您在这方面有更多实践经验，欢迎随时来信与我不吝分享：zhoulei0907@yahoo.cn。当然，自会注明分享者及来源。<br>不过，相信你也早就意识到，若单纯论海量数据处理面试题，本blog内的有关海量数据处理面试题的文章已涵盖了你能在网上所找到的70~80%。但有点，必须负责任的敬告大家：无论是这些海量数据处理面试题也好，还是算法也好，面试时，70~80%的人不是倒在这两方面，而是倒在基础之上(诸如语言，数据库，操作系统，网络协议等等)，所以，无论任何时候，基础最重要，没了基础，便什么都不是。<br>最后，推荐国外一面试题网站：<a href="http://www.careercup.com/，以及个人正在读的Redis/MongoDB绝佳站点：http://blog.nosqlfan.com/。" target="_blank" rel="external">http://www.careercup.com/，以及个人正在读的Redis/MongoDB绝佳站点：http://blog.nosqlfan.com/。</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sql笔记]]></title>
      <url>http://yoursite.com/2015/09/05/sql%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="sql学习"><a href="#sql学习" class="headerlink" title="sql学习"></a>sql学习</h2><h3 id="sql学习-1"><a href="#sql学习-1" class="headerlink" title="sql学习"></a>sql学习</h3><h4 id="查询每个月倒数第2天入职的员工的信息"><a href="#查询每个月倒数第2天入职的员工的信息" class="headerlink" title="查询每个月倒数第2天入职的员工的信息"></a>查询每个月倒数第2天入职的员工的信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT last_name,hire_date </div><div class="line">FROM employees </div><div class="line">WHERE hire_date = LAST_DAY(hire_date) -1</div></pre></td></tr></table></figure>
<h4 id="查询隔行数据"><a href="#查询隔行数据" class="headerlink" title="查询隔行数据"></a>查询隔行数据</h4><figure class="highlight plain"><figcaption><span>row_number() over(order by sno) n wher n % 2 =1```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 将空值转换为有效值 </div><div class="line"></div><div class="line">```select sno,bookname,author,isnull(book,&apos;无&apos;) as book from tb_space</div></pre></td></tr></table></figure>
<h4 id="第N行数据"><a href="#第N行数据" class="headerlink" title="第N行数据"></a>第N行数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from (select top n from tb_space )aa</div><div class="line">where not exist (select * from (select top n-1 from tb_space)bb </div><div class="line">where aa.sno = bb.sno )</div></pre></td></tr></table></figure>
<h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><p>right(xh,len(xh)-1) 从右边开始取指定个数的字符<br>left(xh,len(xh)-1) 从左边开始去指定个数的字符<br>substring(expresion,start,length) 子串<br>select * from tb_space order by 2,3 按照第2列，第3列排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">case...when</div><div class="line">select(</div><div class="line">case job</div><div class="line">when &apos;会计&apos; then salary*1.5;</div><div class="line">when &apos;秘书&apos; then salary*2.0;</div><div class="line">end as new_salary</div><div class="line">) order by new_salary</div></pre></td></tr></table></figure></p>
<h4 id="对重复的内容不作统计"><a href="#对重复的内容不作统计" class="headerlink" title="对重复的内容不作统计"></a>对重复的内容不作统计</h4><p>select count(distinct duty) as duty<br>不包括最大最小值计算平均值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">select avg(salary)</div><div class="line">from tb_space where salary not in (</div><div class="line">	(select min(salary) as minSalary from tb_treatment)</div><div class="line">	union </div><div class="line">	(selct max(salary) as maxSalary from tb_treatment)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h3 id="语法特点："><a href="#语法特点：" class="headerlink" title="语法特点："></a>语法特点：</h3><p>1.没有“ ”，字符串使用‘ ’包含<br>2.没有逻辑相等，赋值和逻辑相等都是=<br>3.类型不再是最严格的。任何数据都可以包含在‘ ’以内<br>4.没有bool值的概念，但是在视图中可以输入true/false<br>5.它也有关系运算符：&gt; &lt; &gt;= &lt;= = &lt;&gt; != ,它返回一个bool值<br>6.它也有逻辑运算符： ！(not) &amp;&amp;(and) ||(or)<br>7.它不区别大小写<br>数据库完整性（Database Integrity）是指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。</p>
<h3 id="事务的四个特点ACID"><a href="#事务的四个特点ACID" class="headerlink" title="事务的四个特点ACID:"></a>事务的四个特点ACID:</h3><p>A:原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。它是一个整体，不能再拆分<br>C：一致性：事务在完成时，必须使所有的数据都保持一致状态。。某种程度的一致<br>I:隔离性：事务中隔离，每一个事务是单独的请求将单独的处理，与其它事务没有关系，互不影响<br>D：持久性：如果事务一旦提交，就对数据的修改永久保留</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>存储过程为标准SQL增加了如下功能：<br>条件执行、循环控制结构、命名变量、命名过程、语句块（调用存储过程让DBMS执行一系列SQL语句）</p>
<h3 id="存储过程的优点"><a href="#存储过程的优点" class="headerlink" title="存储过程的优点"></a>存储过程的优点</h3><p>1）封装  只需要了解过程调用的输入输出就可以安全的使用数据库，防止用户跳过完整性检查<br>2）改善性能  调用存储过程时，DBMS可快速的执行存储过程中的语句，可直接转到语句的执行，无需分析，确认，优化和生成执行计划，这些步骤实现已经完成<br>3）减少网络流量<br>4）减少工作量 编译存储过程之后，许多用户和应用程序都可执行相同的语句序列，而不必重新输入和重新向DBMS提交，当执行需要许多SQL语句或是复杂逻辑的语句时，执行已经调试并测试通过的SQL语句批处理，减少了引入程序错误的风险<br>5）安全性 系统管理员可向单独的用户授予对数据库对象的最小访问权限</p>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>SELECT CONCAT(Cname,Tnum) FROM course WHERE Cnum=03</p>
<h4 id="left-截取指定字符串的指定个数字符"><a href="#left-截取指定字符串的指定个数字符" class="headerlink" title="left 截取指定字符串的指定个数字符"></a>left 截取指定字符串的指定个数字符</h4><p>SELECT LEFT(Cname,5) FROM course WHERE Cnum=01<br>SELECT RIGHT(Cname,5) FROM course WHERE Cnum=01</p>
<h4 id="charIndex"><a href="#charIndex" class="headerlink" title="charIndex()"></a>charIndex()</h4><p>SELECT LOCATE(‘ne’,cname) FROM course WHERE cnum=01<br>SELECT SUBSTRING(Cname,1,3) FROM course</p>
<h3 id="delete-和-truncate"><a href="#delete-和-truncate" class="headerlink" title="delete 和 truncate"></a>delete 和 truncate</h3><p>delete from Teacher where Age&lt;20<br>–特点:<br>–1.删除是一条一条进行删除的<br>–2.每一条记录的删除都需要将操作写入到日志文件中<br>–3.标识列不会从种子值重新计算,以从上次最后一条标识列值往下计算<br>–4.这种删除可以触发delete触发器</p>
<p>–truncate table 表名 –没有条件，它是一次性删除所有数据<br>–特点：<br>–1.一次性删除所有数据，没有条件，那么日志文件只以最小化的数据写入<br>–2.它可以使用标识列从种子值重新计算<br>–3.它不能触发delete触发器<br>truncate table teacher</p>
<p>update Teacher set Salary=Salary+500 where ClassId=4 and Age&gt;20<br>–sign:正数==1  负数 ==-1  0=0<br>select SIGN(-100)</p>
<p>mysql不存在top关键词，使用limit<br>SELECT <em> FROM course WHERE cnum=(SELECT  cnum FROM sc ORDER BY cnum DESC LIMIT 0,1)<br>–使用top分页<br>select top 5 </em> from Student where StudentNo not in(select top 5 studentno from Student)</p>
<p>视图就是一张虚拟表，可以像使用子查询做为结果集一样使用视图<br>触发器:执行一个可以改变表数据的操作（增加删除和修改），会自动触发另外一系列（类似于存储过程中的模块）的操作。</p>
<p>SQL语法顺序是：<br>SELECT[DISTINCT]<br>FROM<br>WHERE<br>GROUP BY<br>HAVING<br>UNION<br>ORDER BY<br>执行顺序为：<br>FROM<br>WHERE<br>GROUP BY<br>HAVING<br>SELECT<br>DISTINCT<br>UNION<br>ORDER BY<br>The first thing that happens is loading data from the disk into memory, in order to operate on such data.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">WITH a AS (</div><div class="line">  SELECT first_name, last_name, current_date - date_of_birth age</div><div class="line">  FROM author</div><div class="line">)</div><div class="line">SELECT *</div><div class="line">FROM a</div><div class="line">WHERE age &gt; 10000</div></pre></td></tr></table></figure></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>SELECT 语句有很多特殊的规则，至少你应该熟悉以下几条<br>你仅能够使用那些能通过表引用而得来的字段<br>如果你有 GROUP BY 语句，你只能够使用 GROUP BY 语句后面的字段或者聚合函数<br>当你的语句中没有 GROUP BY 的时候，可以使用开窗函数代替聚合函数<br>当你的语句中没有 GROUP BY 的时候，你不能同时使用聚合函数和其它函数<br>有一些方法可以将普通函数封装在聚合函数中</p>
<h3 id="sybase常用SQL"><a href="#sybase常用SQL" class="headerlink" title="sybase常用SQL"></a>sybase常用SQL</h3><p>FROM后的子查询，要定义别名才可使用<br>IQ中若采用 FULL JOIN 连接则不能使用 WHERE 条件，否则FULL JOIN将失效，要筛选条件则用子查询先过滤记录后再FULL JOIN<br>根据SELECT 语句建立[临时]表的方法（ORACLE的CREATE TABLE）为 SELECT ..[*] INTO [‘#’]table_name FROM ..<br>其中如果在table_name加前缀’#’，则为会话级临时表，否则为实体表；<br>存储过程隐式游标语法：<br>FOR A AS B CURSOR FOR SELECT … FROM …<br>DO….<br>END FOR;<br>需要注意的时，这边的A 和 B 在 过程语句中都不能引用，所以为避免过程语句其他字段名与FOR SELECT 语句的字段名称重复，<br>FOR SELECT 语句的字段最好都定义别名区分<br>因Sybase为列存储模式，在执行上INSERT语句会比UPDATE语句慢，尤其表数据越多INSERT效率就越慢；所以在ETL时建议多用UPDATE而不是INSERT<br>空字符串’’在Sybase中也是个字符而不是null值，这点要注意</p>
<h3 id="转换函数："><a href="#转换函数：" class="headerlink" title="转换函数："></a>转换函数：</h3><p>CONVERT(datetype,exp[,format-style])<br>CAST(exp AS data-type)</p>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>DAY(date_exp):返回日期天值，DAYS(date_exp,int):返回日期date_exp加int后的日期；MONTH与MONTHS、YEAR与YEARS同理；<br>DATE(exp):将表达式转换为日期，并删除任何小时、分钟或秒；兼容性：IQ<br>DATEPART(date-part,date-exp): 返回日期分量的对应值(整数)<br>GETDATE():返回系统时间<br>DATENAME(datepart,date_expr):以字符串形式返回date_expr指定部分的值,转换成合适的名字<br>DATEDIFF(datepart,date_expr1,date_expr2):返回date_expr2-date_expr1,通过指定的datepart度量<br>DATEADD（date-part,num-exp,date-exp）:返回按指定date-part分量加num-exp值后生成的date-exp值；</p>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>CEIL(num-exp)：返回大于或等于指定表达式的最小整数；兼容性：IQ&amp;ASE<br>FLOOR(numeric_expr):返回小于或等于指定值的最大整数<br>ABS(num-exp):返回数值表达式的绝对值；兼容性：IQ&amp;ASE<br>TRUNCNUM(1231.1251,2)：截取数值；不四舍五入<br>ROUND(numeric_expr,int_expr)：把数值表达式圆整到int_expr指定的精度<br>RAND([int_expr])：返回0-1之间的随机浮点数，可指定基值<br>SIGN(int_expr)：返回正+1，零0或负-1<br>SQRT(float_expr)：返回指定值的平方根<br>PI()：返回常数3.1415926<br>POWER(numeric_expr,power)：返回numeric_expr的值给power的幂<br>EXP(float_expr)：给出指定值的指数值</p>
<h3 id="常用DDL语句"><a href="#常用DDL语句" class="headerlink" title="常用DDL语句"></a>常用DDL语句</h3><p>1.删除列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE table_name DELETE column_name</div></pre></td></tr></table></figure></p>
<p>2.增加列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE table_name ADD (column_name DATA_TYPE [NOT] NULL)</div></pre></td></tr></table></figure></p>
<p>3.修改列的空与非空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE table_name MODIFY column_name [NOT] NULL</div></pre></td></tr></table></figure></p>
<p>4.修改列名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE table_name RENAME old_column_name TO new_column_name</div></pre></td></tr></table></figure></p>
<p>5.快速建立临时表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * INTO [#]table_name FROM .....</div></pre></td></tr></table></figure></p>
<p>6、修改表名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE old_table_name RENAME new_table_name</div></pre></td></tr></table></figure></p>
<p>7.增加主键约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE tb_name ADD CONSTRAINT pk_name PRIMARY KEY(col_name,..)</div></pre></td></tr></table></figure></p>
<p>8.删除主键约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE tb_name DROP CONSTRAINT pk_name</div></pre></td></tr></table></figure></p>
<p>9.建立自增长字段，与Oracle的SEQUENCE类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE TMP_001 (RES_ID INTEGER IDENTITY NOT NULL)</div></pre></td></tr></table></figure></p>
<p>10.添加表注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COMMENT ON TABLE table_name IS &apos;....&apos;</div></pre></td></tr></table></figure></p>
<p>11.创建索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE INDEX index_name ON table_name(column_name)</div></pre></td></tr></table></figure></p>
<h3 id="mysql笔记"><a href="#mysql笔记" class="headerlink" title="mysql笔记"></a>mysql笔记</h3><p>USE test<br>CREATE TABLE users(id int(4) primary key,name varchar(15),password varchar(15))<br>ALTER TABLE users ADD email VARCHAR(20) ,MODIFY NAME VARCHAR(15)usersusers<br>重命名 RENAME TABLE USERS TO USER<br>DROP TABLE USERS</p>
<p>select[distinct][concat(col 1,”:”,col 2) as col] selection_list<br>from 表名<br>group by grouping_columns<br>order by sorting_columns<br>having secondary_constraint<br>limit count </p>
<h4 id="等同连接"><a href="#等同连接" class="headerlink" title="等同连接"></a>等同连接</h4><p>SELECT tb_mrbook.id,tb_mrbook.bookname,author,price<br>FROM tb_mrbook,tb_bookinfo<br>WHERE tb_mrbook.bookname = tb_bookinfo.bookname<br>AND tb_bookinfo.bookname=”mysql”</p>
<p>SELECT * FROM tb_bookinfo WHERE bookname LIKE ‘%m%’</p>
<p>SELECT * FROM tb_mrbook ORDER BY id DESC LIMIT 3</p>
<h4 id="聚合函数（NULL值被忽略）"><a href="#聚合函数（NULL值被忽略）" class="headerlink" title="聚合函数（NULL值被忽略）"></a>聚合函数（NULL值被忽略）</h4><p>SELECT COUNT(*) FROM tb_bookinfo<br>select sum(price) from tb_bookinfo where price &lt;30.0<br>select AVG(price) from tb_bookinfo<br>select MAX(price) from tb_bookinfo</p>
<h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>SELECT section,tb_login.user,books FROM tb_login LEFT JOIN tb_books ON tb_login.user=tb_books.user<br>右外连接<br>RIGHT JOIN<br>内连接</p>
<h4 id="子查询："><a href="#子查询：" class="headerlink" title="子查询："></a>子查询：</h4><p>IN 关键字<br>SELECT * FROM tb_login WHERE USER IN(SELECT USER FROM tb_books)   对应 NOT IN<br>带比较运算符的子运算符<br>SELECT id,books,ROW FROM tb_books WHERE ROW&gt;=(SELECT ROW FROM tb_row WHERE id=1)<br>ANY<br>select books,row from tb_books where row<any(select row="" from="" tb_row)="" all="" select="" books,row="" tb_book="" where="">=ALL(select row from tb_row)</any(select></p>
<p>合并查询结果 UNION 合并查询结果并去除重复结果，UNION ALL 不会去除重复<br>SELECT USER FROM tb_login<br>UNION<br>SELECT USER FROM tb_books</p>
<p>SELECT * FROM tb_login tt WHERE tt.id=1  起别名<br>SELECT  section AS sss,NAME AS nnn FROM tb_login  为字段取别名</p>
<h4 id="使用正则表达式查询"><a href="#使用正则表达式查询" class="headerlink" title="使用正则表达式查询"></a>使用正则表达式查询</h4><p> SELECT <em> FROM tb_books WHERE USER REGEXP ‘[m|l]’<br>SELECT </em> FROM tb_books WHERE USER REGEXP ‘a<em>c’   ===&gt; Aric  Eric  Jack  Lucy  abc12   </em>表示出现0,1，多次<br>SELECT <em> FROM tb_books WHERE USER REGEXP ‘a</em>c’   ===&gt; Jack    + 表示出现1次，多次</p>
<h4 id="MYSQL函数"><a href="#MYSQL函数" class="headerlink" title="MYSQL函数"></a>MYSQL函数</h4><p>1)数学函数<br>2)字符串函数<br>3)日期和时间函数<br>4)条件判断函数<br>5)系统信息函数<br>6)加密函数<br>7)格式化函数和锁函数</p>
<h4 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h4><p>当用户通过索引查询数据库中的数据时，不需要遍历所有数据库中的所有数据，大幅度提<br>高了查询效率<br>一次编写多次调用–MySQL存储过程<br>名称不区分大小写</p>
<h3 id="web安全"><a href="#web安全" class="headerlink" title="web安全"></a>web安全</h3><p>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串<br>最终达到欺骗服务器执行恶意的SQL命令。<br>将（恶意）的SQL命令注入到后台数据库引擎执行，<br>它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库<br>主要原因是 程序没有细致的过滤用户输入的数据，使得非法数据侵入系统</p>
<p>SQL注入分为平台层注入和代码层注入，前者由于不安全的数据库配置所致，后者由于程序员对输入为进行细致的过滤，执行了非法的数据查询<br>在某些表单中，用户输入的内容直接用来构造动态sql命令，或者作为存储过程的输入参数，这些表单特别容易受到sql注入的攻击</p>
<h4 id="防止sql注入："><a href="#防止sql注入：" class="headerlink" title="防止sql注入："></a>防止sql注入：</h4><p>对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双-进行转换等<br>不使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取<br>不要使用管理员的权限数据库连接，为每个应用使用单独的权限有限的数据库连接<br>不要把机密信息比如密码明文存放，加密或者hash掉密码和敏感信息<br>异常信息给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装<br>使用专业检测sql注入漏洞的工具平台扫描检测</p>
<p>强制产生错误 使用特殊字符来进行sql注入<br>通过正则表达校验用户输入<br>通过参数化存储过程进行数据查询存取<br>参数化SQL语句 数值以参数化的形式提供<br>XMLHttpRequest能够产生异步后台请求<br>同源策略，它是由Netscape提出的一个著名的安全策略。<br>现在所有支持JavaScript 的浏览器都会使用这个策略。<br>所谓同源是指，域名，协议，端口相同。<br>当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。</p>
<p>同源策略防止javascript读取不相关的域中的内容，当它并没有限制javascript创建指向其他域的元素的能力，能够从src或href属性自动获取<br>内容的任何元素都有利于黑客攻击。</p>
<p>专业核弹头翻新,改装,潜艇抛光,喷漆.回收二手航母,大修核反应堆,拆洗导弹发动机、清洗航母油槽、航天飞机保养换三滤.高空作业擦洗卫星表面除尘.星球设计，全球海洋保养及维护，南极冰川修复,地球形状改造及时空改变颠倒业务，并批发歼10，F22 F35 B2轰炸机，各类氢/核弹头。量大从优！有正规发票</p>
<h2 id="sql学习-2"><a href="#sql学习-2" class="headerlink" title="sql学习"></a>sql学习</h2><h3 id="基本sql"><a href="#基本sql" class="headerlink" title="基本sql"></a>基本sql</h3><h4 id="查询每个月倒数第2天入职的员工的信息-1"><a href="#查询每个月倒数第2天入职的员工的信息-1" class="headerlink" title="查询每个月倒数第2天入职的员工的信息"></a>查询每个月倒数第2天入职的员工的信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT last_name,hire_date </div><div class="line">FROM employees </div><div class="line">WHERE hire_date = LAST_DAY(hire_date) -1</div></pre></td></tr></table></figure>
<h4 id="查询隔行数据-1"><a href="#查询隔行数据-1" class="headerlink" title="查询隔行数据"></a>查询隔行数据</h4><figure class="highlight plain"><figcaption><span>row_number() over(order by sno) n wher n % 2 =1```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 将空值转换为有效值 </div><div class="line"></div><div class="line">```select sno,bookname,author,isnull(book,&apos;无&apos;) as book from tb_space</div></pre></td></tr></table></figure>
<h4 id="第N行数据-1"><a href="#第N行数据-1" class="headerlink" title="第N行数据"></a>第N行数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from (select top n from tb_space )aa</div><div class="line">where not exist (select * from (select top n-1 from tb_space)bb </div><div class="line">where aa.sno = bb.sno )</div></pre></td></tr></table></figure>
<h4 id="字符函数-1"><a href="#字符函数-1" class="headerlink" title="字符函数"></a>字符函数</h4><p>right(xh,len(xh)-1) 从右边开始取指定个数的字符<br>left(xh,len(xh)-1) 从左边开始去指定个数的字符<br>substring(expresion,start,length) 子串<br>select * from tb_space order by 2,3 按照第2列，第3列排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">case...when</div><div class="line">select(</div><div class="line">case job</div><div class="line">when &apos;会计&apos; then salary*1.5;</div><div class="line">when &apos;秘书&apos; then salary*2.0;</div><div class="line">end as new_salary</div><div class="line">) order by new_salary</div></pre></td></tr></table></figure></p>
<h4 id="对重复的内容不作统计-1"><a href="#对重复的内容不作统计-1" class="headerlink" title="对重复的内容不作统计"></a>对重复的内容不作统计</h4><p>select count(distinct duty) as duty<br>不包括最大最小值计算平均值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">select avg(salary)</div><div class="line">from tb_space where salary not in (</div><div class="line">    (select min(salary) as minSalary from tb_treatment)</div><div class="line">    union </div><div class="line">    (selct max(salary) as maxSalary from tb_treatment)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h3 id="多列子查询"><a href="#多列子查询" class="headerlink" title="多列子查询"></a>多列子查询</h3><h4 id="成对比较的多列子查询"><a href="#成对比较的多列子查询" class="headerlink" title="成对比较的多列子查询"></a>成对比较的多列子查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SELECT NAME,salary ,department </div><div class="line">FROM employee </div><div class="line">WHERE (salary,department) IN (</div><div class="line">     SELECT MAX(salary),department</div><div class="line">     FROM employee</div><div class="line">     GROUP BY department</div><div class="line">)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SELECT NAME,salary ,department </div><div class="line">FROM employee </div><div class="line">WHERE salary IN (</div><div class="line">     SELECT MAX(salary)</div><div class="line">     FROM employee</div><div class="line">     GROUP BY department</div><div class="line">) AND department IN (</div><div class="line">SELECT DISTINCT department </div><div class="line">    FROM employee</div><div class="line">)</div></pre></td></tr></table></figure>
<p>接口是 实体把自己提供给外界的一种抽象化说明，用以由内部操作分离出外部沟通方法，使其能被修改内部而不影响外界其他<br>实体与其交互的方式</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>则对于任意的序号为i的结点有：(1)如i=1，则序号为i的结点是根结点，无双亲结点，如i&gt;1，则序号为i的结点的双亲结点序号<br>为i/2;（2）如2<em>i&gt;n,则序号为i的结点无左孩子，如2</em>i&lt;=n,则序号为i的结点的左孩子结点序号为2<em>i；(3)如2</em>i+1&gt;n，则序号为<br>i的结点无右孩子，如2<em>i+1&lt;=n,则序号为i的结点的右孩子结点序号为2</em>i+1;<br>二叉树含有n个节点，则二叉链表含有2n个指针域，分支数比节点数少1 ，所以 2n-(n-1) = n+1 个空的链域</p>
<p>spring IOC控制反转，控制权交出去，使用容器创建并维护对象<br>AOP面向切面编程<br>DI(dependency injection) 依赖注入  –》 设值注入  构造注入</p>
<p>java在处理基本数据类型（例如int ,char,double）时，都是采用按值传递的方式执行，除此之外的其它类型都是按引用传递的方式执行。<br>对象除了在函数调用时时引用传递，在使用“=”赋值时也是采用引用传递。</p>
<h4 id="webservice小记"><a href="#webservice小记" class="headerlink" title="webservice小记"></a>webservice小记</h4><p>WebService是一种跨编程语言和跨操作系统平台的远程调用技术。<br>Object方法：<br>getClass() hashCode()  equals(Object)  clone()  toString()  notify()   notifyAll()<br>wait(long) wait(long,int) wait()  finalize()<br>通过使用Web Service,我们可以将应用程序转换为网络应用程序，从而使本地的应用程序可以向全世界发布信息或提供某种服务</p>
<p>1.高内聚，低耦合，模块和程序的高度独立性<br>2.所有的设备都可以像文件一样地操作<br>3.“命令的相互支持性”，命令们通过一个管道或是重定向，可以互相联系在一起</p>
<p>抽象类和接口的区别<br>值类型和引用类型的区别<br>存储过程和函数的区别</p>
<p>表中有A B C三列,用SQL语句实现：当A列大于B列时选择A列否则选择B列，当B列大于C列时选择B列否则选择C列。<br>select (case when a&gt;b then a else b end ),<br>(case when b&gt;c then b esle c end)<br>from table_name</p>
<h4 id="一个日期判断的sql语句？"><a href="#一个日期判断的sql语句？" class="headerlink" title="一个日期判断的sql语句？"></a>一个日期判断的sql语句？</h4><p>请取出tb_send表中日期(SendTime字段)为当天的所有记录?<br>select * from tb where datediff(dd,SendTime,getdate())=0</p>
<h4 id="case…when"><a href="#case…when" class="headerlink" title="case…when"></a>case…when</h4><p>大于或等于80表示优秀，大于或等于60表示及格，小于60分表示不及格。<br>select<br>(case when 语文&gt;=80 then ‘优秀’<br>        when 语文&gt;=60 then ‘及格’<br>else ‘不及格’) as 语文,<br>(case when 数学&gt;=80 then ‘优秀’<br>        when 数学&gt;=60 then ‘及格’<br>else ‘不及格’) as 数学,<br>(case when 英语&gt;=80 then ‘优秀’<br>        when 英语&gt;=60 then ‘及格’<br>else ‘不及格’) as 英语,<br>from table</p>
<p>查询中用到的关键词主要包含六个，并且他们的顺序依次为<br>select–from–where–group by–having–order by -&gt;distinct -&gt;top </p>
<p>1.not and or一起出现时候，not &gt; and &gt; or 优先级顺序</p>
<ol>
<li>使用表达式生成新列<br>eg:<br>SELECT 10 AS NAME<br>UNION ALL<br>SELECT 20<br>UNION ALL<br>SELECT  30<br>UNION ALL<br>SELECT 40</li>
</ol>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><h2 id="Java可以通过JNI调用本地的C-C-代码，本地的C-C-的代码也可以调用java代码。JNI-是本地编程接口，Java和C-C-互相通过的接口。Java通过C-C-使用本地的代码的一个关键性原因在于C-C-代码的高效性。"><a href="#Java可以通过JNI调用本地的C-C-代码，本地的C-C-的代码也可以调用java代码。JNI-是本地编程接口，Java和C-C-互相通过的接口。Java通过C-C-使用本地的代码的一个关键性原因在于C-C-代码的高效性。" class="headerlink" title="Java可以通过JNI调用本地的C/C++代码，本地的C/C++的代码也可以调用java代码。JNI 是本地编程接口，Java和C/C++互相通过的接口。Java通过C/C++使用本地的代码的一个关键性原因在于C/C++代码的高效性。"></a>Java可以通过JNI调用本地的C/C++代码，本地的C/C++的代码也可以调用java代码。JNI 是本地编程接口，Java和C/C++互相通过的接口。Java通过C/C++使用本地的代码的一个关键性原因在于C/C++代码的高效性。</h2><h4 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h4><p>public bool IsAdult(int age)<br>{<br>    var isAdult = age &gt; 18;<br>    return isAdult;</p>
<h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>参数过多<br>public void RegisterUser(string userName, string password, string email, string phone)<br>{ … }<br>重构后<br>public void RegisterUser(User user)</p>
<h2 id="…"><a href="#…" class="headerlink" title="{ … }"></a>{ … }</h2><p>public void RegisterUser(User user, bool sendEmail)<br>{ … }<br>布尔参数在告诉方法不止做一件事，违反了Do one thing<br>重构后：<br>public void RegisterUser(User user)<br>{ … }<br>public void SendEmail(User user)</p>
<h2 id="…-1"><a href="#…-1" class="headerlink" title="{ … }"></a>{ … }</h2><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>String s1 = “Hello”;<br>String s2 = “Hello”; S1=S2=S3<br>String s3 = “Hel” + “lo”;  S1=S3 S3虽然是拼接的，但拼接的都是已知的字符串，编译器优化<br>String s4 = “Hel” + new String(“lo”);  S1!=S3<br>String s5 = new String(“Hello”);   S1和S5是否相等<br>String s6 = s5.intern(); S1=S6 intern()将字符串添加到常量池中<br>String s7 = “H”;<br>String s8 = “ello”;<br>String s9 = s7 + s8; S1!=S9 S7和S8拼接之后在堆中，被S9引用，地址和S1不一样</p>
<h4 id="异或运算及应用"><a href="#异或运算及应用" class="headerlink" title="异或运算及应用"></a>异或运算及应用</h4><p>0^a=a<br>a^a=0<br>a^b^c=a^c^b<br>找出数组中只出现了一次的数（除了一个数只出现一次外，其他数都是出现两次）<br>升级版：数组中只出现1次的两个数字(百度面试题)。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux进阶]]></title>
      <url>http://yoursite.com/2015/09/05/linux%E8%BF%9B%E9%98%B6/</url>
      <content type="html"><![CDATA[<p>welcome to you</p>
<h2 id="linux-skill"><a href="#linux-skill" class="headerlink" title="linux skill"></a>linux skill</h2><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><ol>
<li>Linux系统中的/proc文件系统有什么用？<br>/proc文件系统是一个基于内存的文件系统，其维护着关于当前正在运行的内核状态信息，其中包括CPU、内存、分区划分、I/O地址、直接内存访问通道 和正在运行的进程</li>
<li>如何在/usr目录下找出大小超过10MB的文件？<br>find /usr -size +10M</li>
<li>如何在/home目录下找出120天之前被修改过的文件？<br>find /home -mtime +120</li>
<li>如何在/var目录下找出90天之内未被访问过的文件？<br>find /var ! -atime -90</li>
<li>整个目录树下查找文件core，如发现则无需提示直接删除它们<br>find / -name core -exec {} \;</li>
<li>ll | awk {print $3,owns,$9} 这条命令是在做什么？</li>
<li>Linux中的at命令有什么用？<br>at命令用来安排一个程序在未来的做一次一次性执行。所有提交的任务都被放在 /var/spool/at 目录下并且到了执行时间的时候通过atd守护进程来执行。</li>
<li>linux中lspci命令的作用是什么？<br>lspci命令用来显示你的系统上PCI总线和附加设备的信息。</li>
<li>export PS1 = <code>$LOGNAME@hostname:\$PWD:</code> 这条命令是在做什么？<br>这条export命令会更改登录提示符来显示用户名、本机名和当前工作目录。</li>
<li>CSSViewer<br>它有一个浮动面板，上面不但指明鼠标所在之地的身份，还提供其字体、文本、颜色、背景、框、定位和效果属性的说明。 CSSViewer可以快速提供你所需要的基本CSS信息。</li>
<li>Vim 会记录文件的更改，你很容易可以回退到之前某个时间。该命令是相当直观的。比如： :earlier 1m<br>会把文件回退到 1 分钟以前的状态。<br>可以使用下面的命令进行相反的转换：:later</li>
<li>ls <em>[0-9]</em> 显示包含数字的文件名和目录名</li>
<li>tree 显示文件和目录由根目录开始的树形结构(1)<br>lstree 显示文件和目录由根目录开始的树形结构(2)</li>
<li>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录</li>
<li>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接</li>
</ol>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径</p>
<ol>
<li>useradd -s /bin/sh -d /usr/gem -g group –G adm,root gem<br>新建了一个用户gem，该用户的登录Shell是/bin/sh，它属于group用户组，同时又属于adm和root用户组，group用户组是其主组</li>
<li>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下</li>
<li>tar -zcvf archive.tar.gz dir1 创建一个gzip格式的压缩包</li>
<li>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS</li>
<li>文本处理<br>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT</li>
</ol>
<p>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中</p>
<p>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”</p>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>sed ‘/ <em>#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ </em>$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00*/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分<br>22.<br>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址</p>
<h2 id="UML-skill"><a href="#UML-skill" class="headerlink" title="UML skill"></a>UML skill</h2><p>开发模型： 瀑布模型 螺线模型  增量模型<br>黑盒测试：考虑程序的功能，而不是实际代码<br>百合测试：通过程序代码来设计测试数据，使测试数据能很好覆盖语句及执行路径<br>泛化绘制为从孩子指向双亲的空三角箭头<br>泛化使多态操作成为可能，即操作的实现方法由实际对象的类来决定<br>内部类可以看成是服务类的特殊形式，即类可以服务包含它的外部类，内部类作为外部类的一部分，可以提取器外部类的私有属性<br>如果多个活动者之间存在很多共性，就可以使用泛化来分解共性行为。<br>与包含关系不同，在扩展关系中，箭头的方向是从扩展用例到基用例。<br>通过多态，一个通用接口可以实现不同的行为特征<br>关联用一条无线线段表示，代表一种双向关系</p>
<h2 id="vim-skill"><a href="#vim-skill" class="headerlink" title="vim skill"></a>vim skill</h2><p>U可以撤销一行的改变<br>u命令和ctrl-R来撤销和重做<br>w 2w  b 2b  向前或者向后移动word个长度   e 到达当前单词的末尾<br>fx 在当前航搜寻字符<br>%匹配跳转<br>/the> 匹配以the结尾的单词  /\<the 匹配以the开头的单词="" \<the\="">匹配the<br>set incsearch 在输入时开始搜索<br>3dw 3次删除word   d3w 删除3个word<br>f&lt; 找到第一个&lt;    df&lt; 删除到&lt;   .重复之前的操作<br>four -&gt;&gt; five    /four  cwfive  n .  n .<br>ye y$复制到尾部<br>diw 删除光标所在的单词<br>set filetype 检测语言类型<br>多次匹配 ： /a<em>  匹配 a aa aaa…<br>/(ab)</em><br>/ab+<br>/folder\=<br>/a.*b<br>/foo|bar<br>/one|two|three</the></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo 搭建小记]]></title>
      <url>http://yoursite.com/2015/09/04/hexo-%E6%90%AD%E5%BB%BA%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><h4 id="安装git-bash、ssh-、node-js"><a href="#安装git-bash、ssh-、node-js" class="headerlink" title="安装git bash、ssh 、node.js"></a>安装git bash、ssh 、node.js</h4><p>npm install -g hexo<br>mkdir /g/hexo<br>cd /g/hexo<br>hexo init<br>hexo generate<br>hexo server 可以开启服务<br>hexo deploy</p>
<p>若出现deployer not found 则把type改为git<br>执行 npm install hexo-deployer-git –save<br>修改_config.yml<br>deploy:<br>  type: git<br>  repository: git@github.com:yuchuan512/yuchuan512.github.io.git<br>  branch: master<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/A-limon/pacman.git themes/pacman</div></pre></td></tr></table></figure></p>
<p>修改你的博客根目录下的config.yml配置文件中的theme属性，将其设置为pacman</p>
<h4 id="导航栏添加自定义页面"><a href="#导航栏添加自定义页面" class="headerlink" title="导航栏添加自定义页面"></a>导航栏添加自定义页面</h4><p>手动生成自定义页面： hexo n page “about”<br>编辑 hexo/source/abount/index.md<br>修改 themes/pacman/_config.yml    menu: 关于: /about</p>
<h4 id="模板修改-hexo-scaffolds-中-的-post-md"><a href="#模板修改-hexo-scaffolds-中-的-post-md" class="headerlink" title="模板修改 hexo\scaffolds 中 的 post.md"></a>模板修改 hexo\scaffolds 中 的 post.md</h4><p>title: hexo 搭建小记<br>date: 1441376778000<br>categories:<br>description:</p>
<h3 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h3><p>git config –global user.name [username]<br>git config –global user.email [email]<br>ssh-keygen -t rsa -C “yuchuan512@163.com”<br>把pub文件用sublime打开粘贴到github上<br>若提示 **Host key verification failed. ssh git@github.com 询问的时候输入yes，此时再连接即可成功。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>npm install hexo -g #安装<br>npm update hexo -g #升级<br>hexo init #初始化</p>
<p>hexo n “我的博客” == hexo new “我的博客” #新建文章<br>hexo p == hexo publish<br>hexo g == hexo generate#生成<br>hexo s == hexo server #启动服务预览<br>hexo d == hexo deploy#部署</p>
<p>hexo server #Hexo 会监视文件变动并自动更新， 无须重启服务器。<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP</p>
<p>hexo clean #清除缓存<br>hexo g #生成静态网页<br>hexo d #开始部署</p>
<p>hexo new “postName” #新建文章<br>hexo new page “pageName” #新建页面<br>hexo generate #生成静态页面至public目录<br>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy #将.deploy目录部署到GitHub</p>
<p>hexo new [layout] <title><br>hexo new photo “My Gallery”<br>hexo new “Hello World” –lang tw</title></p>
<h4 id="设置文章摘要"><a href="#设置文章摘要" class="headerlink" title="设置文章摘要"></a>设置文章摘要</h4><p>以上是文章摘要 <a id="more"></a> 以下是余下全文</p>
]]></content>
    </entry>
    
  
  
</search>
